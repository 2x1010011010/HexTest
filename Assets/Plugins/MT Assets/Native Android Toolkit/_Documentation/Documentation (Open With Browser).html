<html lang="en-US">

    <head>
        <!-- #region HEAD -->
        <title>Native Android Toolkit</title>
        <link rel="shortcut icon" type="image/png" href="DocumentationFiles/favicon/favicon" />
        <link rel="shortcut icon" type="image/png" href="DocumentationFiles/favicon/favicon" />
        <link rel="stylesheet" type="text/css" href="DocumentationFiles/css/rainbow-dreamweaver.css">
        <link rel="stylesheet" type="text/css" href="DocumentationFiles/css/all-css-content.css">
        <script src="DocumentationFiles/js/rainbow-custom-min"></script>
        <script src="DocumentationFiles/js/javascript-core"></script>
        <meta name="viewport" content="width=device-width">
        <meta charset="UTF-8">
        <!-- #endregion -->
    </head>

    <body>
        <!-- #region TOPBAR -->
        <div class="topBar">
            <div class="topBarLogoIcon"><img src="DocumentationFiles/logo/logo" height="100%" /></div>
            <div class="topBarLogoTextContainer">
                <div class="topBarLogoText">Native Android Toolkit Documentation</div>
            </div>
            <div class="topBarItemContainer"><a href="https://www.youtube.com/channel/UCqAgiYBwAWajjFUqyJ6_xyw" target="_blank" title="MT Assets On Youtube"><img src="DocumentationFiles/topbar/youtube" /></a></div>
            <div class="topBarItemContainer"><a href="https://windsoft.xyz/mtassets" target="_blank" title="MT Assets Website"><img src="DocumentationFiles/topbar/generic" /></a></div>
            <div class="topBarItemContainer"><a href="https://discord.gg/44aGAt4Sv4" target="_blank" title="MT Assets Community"><img src="DocumentationFiles/topbar/discord" /></a></div>
            <div class="topBarItemContainer"><a href="https://assetstore.unity.com/publishers/40306" target="_blank" title="See More Assets From MT Assets!"><img src="DocumentationFiles/topbar/shop" /></a></div>
            <div class="topBarItemDivider"></div>
            <div class="topBarSupportTextContainer">
                <div class="topBarSupportText">For support and contact</div>
                <div class="topBarSupportTextEmail">mtassets@windsoft.xyz</div>
            </div>
        </div>
        <div class="readProgressContainer">
            <div class="readProgressBar" id="readProgressBar"></div>
        </div>
        <div class="fullscreenImageBackground" id="fullScreenImageViewerBg" onclick="CloseImageFullScreenViewer();"></div>
        <div class="fullscreenImagePopupContent" id="fullScreenImageViewerPop">
            <div class="fullscreenImagePopup">
                <div class="fullscreenImagePopupClose"><img src="DocumentationFiles/tools/close.webp" id="fullScreenImageClose" title="Click here to close Viewer." onclick="CloseImageFullScreenViewer();" /></div>
                <img src="" id="fullScreenImageViewerImg" />
            </div>
        </div>
        <div class="fullscreenCodeBackground" id="fullScreenCodeViewerBg" onclick="CloseExpandedScriptCode();"></div>
        <div class="fullscreenCodePopupContent" id="fullScreenCodeViewerPop">
            <div class="fullscreenCodePopup">
                <div class="fullscreenCodePopupClose">
                    <div>Script Code Viewer</div><img src="DocumentationFiles/tools/close.webp" id="fullScreenCodeClose" title="Click here to close Viewer." onclick="CloseExpandedScriptCode();" />
                </div>
                <div class="fullscreenCodeSandboxViewer" id="fullScreenCodeViewerSandbox"></div>
            </div>
        </div>
        <div class="fullscreenLoadingContent" id="fullscreenLoadingBlock">
            <div class="fullscreenLoadingBg">
                <div class="fullscreenLoading">
                    <div><img src="DocumentationFiles/tools/loading.webp" /></div>
                    <div></div>
                    <div>Loading Documentation</div>
                </div>
            </div>
        </div>
        <!-- #endregion -->
        <!-- SUBBODY -->
        <div class="subBody">
            <!-- SUMMARY -->
            <div class="subBodySummary" id="summary" onscroll="OnScrollSummary(this);" onmouseover="isMouseOverTheSummary(this, true);" onmouseout="isMouseOverTheSummary(this, false);">
                <div id="summaryTitleAndSearch" class="subBodySummaryTitleAndSearch">
                    <div id="summaryTitle" class="subBodySummaryTitle">Summary</div>
                    <div id="summarySearchBar" class="subBodySummarySearchBar"><input type="text" placeholder="Search in Summary..." /></div>
                    <div id="summarySearchStart" class="subBodySummarySearchStart" onclick="StartSearchJob();"><img src="DocumentationFiles/tools/mag-glass-start.webp" /></div>
                    <div id="summarySearchEnd" class="subBodySummarySearchEnd" onclick="FinishSearchJob();"><img src="DocumentationFiles/tools/mag-glass-end.webp" /></div>
                </div>
                <div id="summarySearchResult" class="subBodySummarySearchResults">...</div>
                <!-- -------------------------------------------------------------------------- START OF SUMMARY CONTENT -------------------------------------------------------------------------- -->
                <ul>
                    <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="1">What is the Native Android Toolkit?</a></li>
                    <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="2">First steps to use</a></li>
                    <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="3">How to use this tool</a></li>
                    <li class="summarySubItem">General</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="4">Useful informations about Native Android Toolkit</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="5">Registering Event to get the NAT initialization Callback</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="6">Checking if NAT is initialized</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="7">Native Android Toolkit and Minify</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="8">Compiling the APK of your application to run correctly on Android 12+</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="9">Recommendations on the use of NAT with other Libraries/SDK</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="10">Best way to report Crashs/Errors/Bugs for MT Assets support</a></li>
                    </ul>
                    <li class="summarySubItem">Dependencies Resolver</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="11">What is "Dependencies Resolver" and what is your goal?</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="12">How does it work</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="13">Solving build errors caused by AARs/JARs duplicate in the project</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="14">"Dependencies Resolver" vs "External Dependency Manager for Unity" vs "Play Services Resolver"</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="15">Useful informations about NAT Dependencies Resolver</a></li>
                    </ul>
                    <li class="summarySubItem">Preferences</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="16">What are the Preferences of NAT</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="17">Explaining the Interface</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="19">Some editable parameters in AndroidManifest and GradleProperties</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="22">Enabling or Disabling dependencies embedded in the NAT</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="23">Explaining the Preferences categories</a></li>
                    </ul>
                    <li class="summarySubItem">Dialogs</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="36">About This Class</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="37">Simple Alert Dialog</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="38">Confirmation Alert Dialog</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="39">Neutral Alert Dialog</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="40">Radial List Dialog</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="41">Check List Alert Dialog</a></li>
                    </ul>
                    <li class="summarySubItem">Power Manager</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="43">About This Class</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="44">What is Power Management on Android devices and how it can affect your Application</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="45">Check if Exact Alarms and Tasks are allowed for your Application</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="46">Open Alarms and Reminders Access</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="47">Checking if the device is considered "Problematic" in relation to the Power Manager/Battery Saver</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="48">Requesting AutoStart Enabled if the device is considered "Problematic"</a></li>
                    </ul>
                    <li class="summarySubItem">Notifications</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="50">About This Class</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="51">Show Toast Message</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="52">Send Notification</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="55">Scheduling Notifications</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="59">Limitation of Notifications</a></li>
                    </ul>
                    <li class="summarySubItem">Tasks</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="61">About This Class</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="62">What are Tasks and how do they work?</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="63">How to code Tasks</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64aa">Component: Section</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64">Component: Show Toast</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64a">Component: Send Notification</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64b">Component: Create File</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64c">Component: Delete File</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64d">Component: Reschedule This Task</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64e">Component: Play Sound</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64f">Component: Build And Save String</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64g">Component: Vibrate</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64h">Component: Arithmetic</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64i">Component: Wait For Seconds</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64j">Component: Load Json From Web</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64k">Component: Download File From Web</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64l">Component: File Exists</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64m">Component: Get File Size</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64n">Component: Clear Task Directory</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64o">Component: If And Else</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64p">Component: While</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64q">Component: Call Method</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64r">Component: Go To Section</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="64s">Component: Simple Comment</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="65">Scheduling and managing Tasks</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="66">Limitation of Tasks</a></li>
                    </ul>
                    <li class="summarySubItem">Sharing</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="74">About This Class</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="75">Sharing Texture2D</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="76">Sharing Text Plain</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="77">Copy Text to Clipboard</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="78">Get Text from Clipboard</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="79">Take Screenshot and Get Texture2D Async</a></li>
                    </ul>
                    <li class="summarySubItem">Webview</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="81">About This Class</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="82">Using The Webview</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="83">Access Page With POST/GET and get all returned Cookies</a></li>
                    </ul>
                    <li class="summarySubItem">Permissions</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="86">About This Class</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="86a">Principles of Permissions in the Android</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="87">Opening Permissions Requester Wizard</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="88">Checking if Application have a specific Permission</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="89">Requesting Permissions</a></li>
                    </ul>
                    <li class="summarySubItem">Utils</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="91">About This Class</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="92">Restarting the Application</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="93">Vibrate Device</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="96">Get Device Manufacturer</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="97">Get Device Model</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="98">Get Device Android Version Code</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="99">Speak With Text-To-Speech</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="100">Get Device Current Locale</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="101">Enable/Disable Anti-Screenshot</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="102">Convert DP to Pixels and vice versa</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="104">Convert Pixels Size To Canvas Size</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="105">Get Device Notch Pixels Size</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="106">Opening Play Store In App Review</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="107">Checking if Vibration is Available</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="108">Checking if Wi-Fi is Enabled</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="109">Checking if is Connected to Wi-Fi</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="110">Checking if is using Headset</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="111">Checking if Internet is Available</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="112">Checking if Developer Mode is enabled</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="113">Checking if Google Play Services is Available</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="114">Checking if Device is Rooted</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="115">Checking if Anti-Screenshot is enabled</a></li>
                    </ul>
                    <li class="summarySubItem">Settings</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="117">About This Class</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="118">Open General Settings</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="119">Open This App Settings</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="120">Open Wi-Fi Settings</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="121">Open Bluetooth Settings</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="122">Open Location Settings</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="123">Open Network Operator Settings</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="124">Open Internet Toggle Settings</a></li>
                    </ul>
                    <li class="summarySubItem">Location</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="126">About This Class</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="127">Tracking the device using GPS or Network</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="128">Opening Google Maps</a></li>
                    </ul>
                    <li class="summarySubItem">Camera</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="137">About This Class</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="138">Using the Camera to take Pictures, record Videos and Read Bar/QR Codes</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="139">Generate QR Code from String</a></li>
                    </ul>
                    <li class="summarySubItem">Microphone</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="144">About This Class</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="145">Recording audio through Microphone</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="146">Using the Speech-To-Text</a></li>
                    </ul>
                    <li class="summarySubItem">Applications</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="153">About This Class</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="154">Check if a Application is installed</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="155">Open a Application</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="156">Open a Application With Parameters</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="157">Get this Application Package Name</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="158">Check if Play Store is available</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="159">Open Application in Play Store</a></li>
                    </ul>
                    <li class="summarySubItem">Date Time</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="161">About This Class</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="162">Calendar Util Class</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="163">Open Hour Picker</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="164">Open Date Picker</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="165">Load Current Time of NTP Server</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="166">Get Elapsed Realtime Since Boot</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="167">Know Elapsed Time While Application is Closed</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="168">Know Elapsed Time While Application is Paused/Minimized/Unfocused/Blocked or Suspended</a></li>
                    </ul>
                    <li class="summarySubItem">Files</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="170">About This Class</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="171">About The Android Scoped Storage</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="172">What you need to know before interacting with device Files using the NAT Files API</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="173">Get Absoluth Path For Scope</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="175">Get Internal Memory Usage Info</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="176">Save Media and Do It Available To Gallery</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="177">Check if a Folder is Scannable by the System</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="178">Set a Folder as Scannable/Unscannable</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="179">Get List of Files And Folders of a Directory</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="180">Check if File/Folder Exists</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="181">Get all Attributes from File/Folder</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="182">Copy File/Folder</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="183">Move File/Folder</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="184">Rename File/Folder</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="185">Delete File/Folder</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="186">Create Folder</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="187">Create File</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="188">Load All Bytes From File</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="189">Write All Text</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="190">Read All Text From File</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="193">Open File With Default Application</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="194">Using the system File Picker to "Save As" or "Open" a File</a></li>
                    </ul>
                    <li class="summarySubItem">Audio Player</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="196">About This Class</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="197">Get Audio File Information</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="198">Playing Audios Files natively using streaming without loading to Unity</a></li>
                    </ul>
                    <li class="summarySubItem">Play Games</li>
                    <ul>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="206">About This Class</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="207">Configuring Play Games, Achievements, Events and Leaderboars for your Application</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="208">Everything you need to know about the NAT Play Games API</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="212">Implementing Achievements</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="216">Implementing Events</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="218">Implementing Leaderboards</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="220">Accessing the User Friends List</a></li>
                        <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="224">Loading and Saving progress to Cloud</a></li>
                    </ul>
                    <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="226">Optimization Tips For Using Native Android Toolkit</a></li>
                    <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="227">Demo Scene</a></li>
                    <li><a class="summaryItem" onclick="GoToDivSmoothly(this);" correspondentTopicId="228">Contact and Support</a></li>
                </ul>
                <!-- -------------------------------------------------------------------------- END OF SUMMARY CONTENT -------------------------------------------------------------------------- -->
            </div>
            <div class="subBodyDivider" id="divider">
                <div id="summaryScrollIndicador" class="summaryScrollDownIndicator"><img src="DocumentationFiles/tools/scroll-down.webp" /></div>
            </div>

            <!-- DOCUMENTATION CONTENT -->
            <div class="subBodyContent" id="content">
                <!-- -------------------------------------------------------------------------- START OF DOCUMENTATION CONTENT -------------------------------------------------------------------------- -->

                <!-- #region Welcome to Native Android Toolkit Documentation! -->
                <doc.topic>
                    <doc.topictitle>Welcome to Native Android Toolkit Documentation!</doc.topictitle>

                    By reading this documentation, you will understand how Native Android Toolkit works and how to use it and get the most out of it. Come on! Make sure that this HTML file is in the same directory as the
                    "DocumentationFiles" folder. This way you will not have problems with formatting and displaying the videos and image on the page.
                    <doc.info>
                        If you still have problems with the tool, even after consulting this documentation, please contact <doc.detach>mtassets@windsoft.xyz</doc.detach> for help and support. If you have any questions, problems or feedback,
                        feel free to contact me!
                        <br>
                        <br>
                        I am always willing to help, open to suggestions and always do my best to offer a quick and useful service to my customers! ðŸ˜€
                    </doc.info>
                </doc.topic>
                <!-- #endregion -->

                <!-- #region What is the Native Android Toolkit? -->
                <doc.topic topicid="1">
                    <doc.topictitle>What is the Native Android Toolkit?</doc.topictitle>

                    Native Android Toolkit is a tool that will allow your application made with Unity to access hundreds of native Android functions, on any device running Android. Functions range from Scheduled Notifications to even File
                    Management.
                    <doc.video src="DocumentationFiles/videos/what-is" thumbnail="DocumentationFiles/thumbs/what-is"></doc.video>
                </doc.topic>
                <!-- #endregion -->

                <!-- #region First steps to use -->
                <doc.topic topicid="2">
                    <doc.topictitle>First steps to use</doc.topictitle>

                    As you know, the Native Android Toolkit provides means for your application to be able to access native Android system functions, using a simple and well-written C# API. It turns out that various functions and various
                    mechanisms of NAT rely on two-way communication, where your application can send commands to the Native Android Toolkit and the Native Android Toolkit can send commands to your application, in addition to other things
                    necessary for all mechanisms of Native Android Toolkit can run smoothly.
                    <br>
                    <br>
                    In order for this two-way communication to be possible and for NAT to work smoothly, you need to initialize the Native Android Toolkit and for that you just need to use the C# code below. You can include the code below,
                    in a Script that must be in a GameObject in your scene.

                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Awake()
{
    //Initialize the Native Android Toolkit
    if (NativeAndroidToolkit.isInitialized == false)
        NativeAndroidToolkit.Initialize();
}
                    </code></doc.code>

                    <doc.warn>
                        It is HIGHLY recommended that this initialization occurs exactly in the FIRST scene of your application, that is, the scene that is executed when your application is opened by the user. This is necessary because the
                        Native Android Toolkit is designed to be working as long as your application is open, and many functions depend on this sync with your application, to work as designed and without problems.
                    </doc.warn>
                    <br>
                    <br>
                    <doc.achiev>
                        This was the basics for you to use the Native Android Toolkit! Now you can use the C# APIs of NAT in your application! Continue reading the documentation to understand more about all the features of Native Android
                        Toolkit and all its components and functions too!
                    </doc.achiev>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region How to use this tool -->
                <doc.topic topicid="3">
                    <doc.topictitle>How to use this tool</doc.topictitle>

                    The Native Android Toolkit is an API-based tool, so to use NAT your app just needs to consume the C# APIs provided by the Native Android Toolkit! First, make sure that the Native Android Toolkit has been Initialized, as
                    the last topic taught. To get started, you need to make sure that you have imported the Native Android Toolkit into the C# script you want to use NAT APIs.

                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;
                    </code></doc.code>

                    Once that's done, now just start using the APIs of each Native Android Toolkit class, as in the example below...

                    <doc.code language="csharp"><code>
myMethod()
{
    //Open a native simple alert dialog
    NAT.Dialogs.ShowSimpleAlertDialog("Simple Alert Dialog", "This is a simple alert dialog.", true);
}
                    </code></doc.code>

                    Keep reading the documentation to learn more about all the Native Android Toolkit APIs and classes. You can also adjust any Preferences you want in Native Android Toolkit. You will learn more about Preferences as you
                    continue reading the documentation.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region General: Useful informations about Native Android Toolkit -->
                <doc.topic topicid="4">
                    <doc.topictitle>General: Useful informations about Native Android Toolkit</doc.topictitle>

                    There is some useful information about Native Android Toolkit which might be helpful for you to know.

                    <doc.topicsubtitle>Editor Support</doc.topicsubtitle>
                    The Native Android Toolkit APIs support the Editor in an emulated manner. Calling a C# API from NAT while your application is running in the Editor will cause that API to perform an emulated action. For example, calling
                    the <doc.detach>ShowSimpleAlertDialog()</doc.detach> API in the Editor will cause NAT to display a simple, emulated alert dialog.
                    <br>
                    <br>
                    Note that the APIs emulate the behavior in the Editor as far as possible. Not all functions will work exactly the same as they would on an Android device, so it is still important to test your application on an Android
                    device using the Native Android Toolkit APIs.

                    <doc.topicsubtitle>Does not support platforms other than Editor and Android</doc.topicsubtitle>
                    Native Android Toolkit only supports Editor and Android as platforms. If you call NAT APIs from other platforms like <doc.detach>iOS</doc.detach> or <doc.detach>Windows</doc.detach>, it is likely that nothing will happen
                    or you will get errors depending on the API.

                    <doc.topicsubtitle>Correct way to use Events</doc.topicsubtitle>
                    The Native Android Toolkit has events. Events are how you can register Callbacks in Native Android Toolkit. For example, it is through Events that you get results of asynchronous tasks done by NAT after you call some API
                    method. All the methods linked to each NAT API are documented here, but you need to know the correct way to use them.
                    <br>
                    <br>
                    To use a event, you need to register it BEFORE calling its API. This is necessary because when the API is executed, it will already know what code it needs to execute as a Callback. See the example below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

//FIRST, register the events as Callbacks
NATEvents.onSimpleAlertDialogOk += () =>
{
    demoNATMessages.ShowNotificationOnDemoScene("You hit the \"Ok\" button!");
};
NATEvents.onSimpleAlertDialogCancel += () =>
{
    demoNATMessages.ShowNotificationOnDemoScene("You have canceled the simple alert dialog.");
};

//AFTER, call the API
NAT.Dialogs.ShowSimpleAlertDialog("Simple Alert Dialog", "This is a simple alert dialog.", true);
                    </code></doc.code>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region General: Registering Event to get the NAT initialization Callback -->
                <doc.topic topicid="5">
                    <doc.topictitle>General: Registering Event to get the NAT initialization Callback</doc.topictitle>

                    Sometimes you will need to make sure that the Native Android Toolkit has been initialized, for example when you need to run code only if the tool has launched successfully. For this reason, Native Android Toolkit makes
                    it possible for you to register a Callback to know if the tool was successfully initialized or not.
                    <br>
                    <br>
                    To use this Callback, look at the sample code below, making sure the Callback is registered before calling <doc.detach>NativeAndroidToolkit.Initialize()</doc.detach>.

                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

//Register event that shows that NAT was initialized or not
NATEvents.onInitializeNAT_PostInitialize += (bool isSuccessfully) =>
{
    if (isSuccessfully == true)
        NAT.Notifications.ShowToast("NAT was successfully initialized on Unity and Native side!", true);
    if (isSuccessfully == false)
        NAT.Notifications.ShowToast("There was a problem on initializing the NAT! :(", true);
};

//Finally, initialize the NAT
if (NativeAndroidToolkit.isInitialized == false)
    NativeAndroidToolkit.Initialize();
                    </code></doc.code>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region General: Checking if NAT is initialized -->
                <doc.topic topicid="6">
                    <doc.topictitle>General: Checking if NAT is initialized</doc.topictitle>

                    Anytime you like, you can check whether Native Android Toolkit is Initialized or not. To do this, use the code below...

                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

bool isInitialized = NativeAndroidToolkit.isInitialized;
                    </code></doc.code>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region General: Native Android Toolkit and Minify -->
                <doc.topic topicid="7">
                    <doc.topictitle>General: Native Android Toolkit and Minify</doc.topictitle>

                    The Android Minification process is a process in which the Build process uses tools like "ProGuard" or "R8" to do a minification in the application, where this minification will rename Methods, Classes, Variables and
                    other things to much smaller names, minification will also try to optimize the application where possible. This is a very common practice when building native apps for Android when using Android Studio for example.
                    <br>
                    <br>
                    In Unity, minification is turned off by default. When using the Native Android Toolkit, it is not recommended that you enable minification for your application. The minification process will rename all AAR Core Classes
                    and Methods (native code) of Native Android Toolkit, which will make Unity Side unable to communicate with native Java Side. Also, it will make it more difficult to debug your application deeply.
                    <br>
                    <br>
                    If you are an advanced user on the Android platform, you can enable minification for your application, but it is highly recommended that you add an exception to the native AAR code of the Native Android Toolkit and its
                    dependencies, to avoid malfunctions.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region General: Compiling the APK of your application to run correctly on Android 12+ -->
                <doc.topic topicid="8">
                    <doc.topictitle>General: Compiling the APK of your application to run correctly on Android 12+</doc.topictitle>

                    In Android 12+, there is a change that requires applications to inform some details that will be public so that any third-party application can access them, such as access to the main activity of your application. When
                    using the latest versions of Unity (which also use the more recent versions of Gradle), this information will already be done automatically. Below you can see which versions of Unity are already compliant with these
                    changes.

                    <doc.list>
                        <doc.listr>Unity 2019.4.33f1 or more recent</doc.listr>
                        <doc.listr>Unity 2020.3.22f1 or more recent</doc.listr>
                        <doc.listr>Unity 2021.1.20f1 or more recent</doc.listr>
                        <doc.listr>Unity 2021.2.0b11 or more recent</doc.listr>
                        <doc.listr>Any version equal to or later than Unity 2022.X.X</doc.listr>
                    </doc.list>

                    If you want to compile for Android 12+ and don't use one of these versions, use the <doc.detach>Declare UnityActivity</doc.detach> option in NAT Preferences. this option will be available if you enable the option
                    <doc.detach>Yes Generate New If Not Exists</doc.detach> in <doc.detach>Modify Android Manifest</doc.detach> in NAT Preferences.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region General: Recommendations on the use of NAT with other Libraries/SDK -->
                <doc.topic topicid="9">
                    <doc.topictitle>General: Recommendations on the use of NAT with other Libraries/SDK</doc.topictitle>

                    It is highly recommended that the Native Android Toolkit not be used together with other libraries that do a service that NAT already does. For example, do not use the Native Android Toolkit together with Google Play
                    Games for Unity, as NAT already has the Play Games function and when using another Play Games library, NAT will turn off the dependencies it has, related to Play Games. It may or not, depending on the situation,
                    affect other NAT functionality. Generally the best combination is <b>NAT</b> + <b>Unity Mediation (or Unity ADS)</b> + <b>Unity IAP</b>. With Unity Mediation you can activate AdMob and Unity Ads through mediation, then
                    you will have <b>NAT (+Play Games)</b> + <b>AdMob</b> + <b>Unity ADS</b> + <b>In App Purchase</b>.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region General: Best way to report Crashs/Errors/Bugs for MT Assets support -->
                <doc.topic topicid="10">
                    <doc.topictitle>General: Best way to report Crashs/Errors/Bugs for MT Assets support</doc.topictitle>

                    The Native Android Toolkit has several strategies to prevent compilation errors from happening, but when developing in the Android environment, it is impossible that some small or large error will never happen. NAT is
                    highly tested and has active MT Assets Support. If at any point in the development you have any questions, want to report a bug, need support or come across an error, install a dependency that is outdated or anything
                    like that, that can give you errors, you can count on active Support MT Assets.
                    <br>
                    <br>
                    If you contact MT Assets Support to report a bug, crash, error or unexpected behavior from the Native Android Toolkit, it is necessary that you include a few things so that the support is done as quickly as possible and
                    so that the source of the problem can be identified more easily. See below for the list of things you need to provide.

                    <doc.list>
                        <doc.listr>The Log of the Error (if have)</doc.listr>
                        <doc.listr>The Logcat of the moment the error happened (if possible)</doc.listr>
                        <doc.listr>Inform if your project has other Android plugins like (Unity ADS, Firebase, Play Games and so on). If so, let us know which ones.</doc.listr>
                        <doc.listr>Inform if your project has Plugins "Play Services Resolver" or "External Dependency Manager for Unity"</doc.listr>
                        <doc.listr>Inform if the problem also occurred in an empty project (if possible)</doc.listr>
                        <doc.listr>The version of the Android device that has the problem</doc.listr>
                        <doc.listr>The version of the Android device Manufacture and Model that has the problem</doc.listr>
                        <doc.listr>The version of the Unity Engine of your Project</doc.listr>
                        <doc.listr>The Log of the NAT Dependencies Resolver</doc.listr>
                    </doc.list>

                    See below, how to obtain each of these items.

                    <doc.topicsubtitle>The Log of the Error</doc.topicsubtitle>
                    The error log (if there is one) can be obtained from the Unity Console.
                    <doc.image src="DocumentationFiles/images/1"></doc.image>

                    <doc.topicsubtitle>The Logcat of the moment the error happened</doc.topicsubtitle>
                    Android devices can be debugged through ADB (Android Debug Bridge) and ADB has a command called <doc.detach>Logcat</doc.detach>. This command allows the reading of Logs launched by all Android applications that are
                    running on the device. The moment a Bug/Crash or Error occurs in your application, you can use Android system <doc.detach>Logcat</doc.detach> to capture the error log thrown by the application in real-time and then
                    include it in your message to MT Assets support.
                    <doc.frame contentside="right" contentheight="400px">
                        Unity Engine has a tool called <doc.detach>Android Logcat</doc.detach> that can be downloaded and installed on your project from the <doc.detach>Package Manager</doc.detach>. This tool allows you to access the logcat
                        of any Android device connected to Unity ADB, either by USB or Wi-Fi. Keep following the steps to find out how to install this tool.
                        <doc.frameci src="DocumentationFiles/images/2">Android Logcat, tool of Unity Engine</doc.frameci>
                    </doc.frame>
                    <doc.frame contentside="left" contentheight="400px">
                        <b>Step 1:</b> For start, click the <doc.detach>Window</doc.detach> tab and then click <doc.detach>Package Manager</doc.detach>.
                        <doc.frameci src="DocumentationFiles/images/3"></doc.frameci>
                    </doc.frame>
                    <doc.frame contentside="right" contentheight="400px">
                        <b>Step 2:</b> With the <doc.detach>Package Manager</doc.detach> open, click <doc.detach>Packages</doc.detach> and select <doc.detach>Unity Registry</doc.detach>.
                        <doc.flextext></doc.flextext>
                        <doc.frameci src="DocumentationFiles/images/4"></doc.frameci>
                    </doc.frame>
                    <doc.frame contentside="left" contentheight="400px">
                        <b>Step 3:</b> Look for the <doc.detach>Android Logcat</doc.detach> package and click it.
                        <doc.frameci src="DocumentationFiles/images/5"></doc.frameci>
                    </doc.frame>
                    <doc.frame contentside="right" contentheight="400px">
                        <b>Step 4:</b> In the bottom right corner of <doc.detach>Package Manager</doc.detach>, click the <doc.detach>Install</doc.detach> button to install the package on your project.
                        <doc.frameci src="DocumentationFiles/images/6"></doc.frameci>
                    </doc.frame>
                    <doc.frame contentside="left" contentheight="400px">
                        <b>Step 5:</b> Now click the <doc.detach>Window</doc.detach> tab, then click <doc.detach>Analysis</doc.detach> and then click <doc.detach>Android Logcat</doc.detach>.
                        <doc.frameci src="DocumentationFiles/images/7"></doc.frameci>
                    </doc.frame>
                    <doc.frame contentside="right" contentheight="400px">
                        <b>Step 6:</b> Now make sure your device is connected by USB or Wi-Fi to Unity ADB. To make sure it is connected, make sure it appears in <doc.detach>Build Settings</doc.detach>. If it is appearing, click
                        <doc.detach>Devices</doc.detach> on <doc.detach>Android Logcat</doc.detach>, and then select your device that is connected by USB or Wi-Fi.
                        <doc.frameci src="DocumentationFiles/images/8"></doc.frameci>
                    </doc.frame>
                    <doc.frame contentside="left" contentheight="400px">
                        <b>Step 7:</b> If the logs do not start to appear, click <doc.detach>Reconnect</doc.detach>. If after that they do not appear, possibly the device is disconnected from Unity ADB. You can also monitor connection
                        status through the <doc.detach>Android Logcat</doc.detach> status bar.
                        <doc.frameci src="DocumentationFiles/images/9"></doc.frameci>
                    </doc.frame>
                    <doc.frame contentside="right" contentheight="400px">
                        <b>Step 8:</b> If your device is already connected and the Logs are appearing in realtime, you can run your application on the device. Once it is running, click <doc.detach>No Filter</doc.detach> and select the
                        <doc.detach>Package Name</doc.detach> of your application. Logs will be filtered to show only the Logs of your application. Now try to reproduce the problem and you will see any errors or warnings that may be
                        released within <doc.detach>Android Logcat</doc.detach>. Once you viewed the error press the shortcut <doc.detach>Ctrl + S</doc.detach> to save the entire Log to a TXT file. This TXT file is the file you must send to
                        MT Assets Support!
                        <br>
                        <br>
                        Android Logcat is an amazing tool for android development!
                        <doc.frameci src="DocumentationFiles/images/10"></doc.frameci>
                    </doc.frame>

                    <doc.topicsubtitle>The Log of the NAT Dependencies Resolver</doc.topicsubtitle>
                    This is the Native Android Toolkit information and event Log of Dependencies Resolver. This Log is important because it will show whether or not the NAT has been affected by possible AARs/JARs in your project, as well as
                    other valuable information for MT Assets Support!
                    <br>
                    <br>
                    You can get this Log easily, just go to the way <b>"Assets/Plugins/MT Assets/_AssetsData/Editor"</b> and copy the <b>"NATDependenciesResolverLog.txt"</b> file and include it in your support request!
                    <doc.image src="DocumentationFiles/images/11"></doc.image>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Dependencies Resolver: What is "Dependencies Resolver" and what is your goal? -->
                <doc.topic topicid="11">
                    <doc.topictitle>Dependencies Resolver: What is "Dependencies Resolver" and what is your goal?</doc.topictitle>

                    The purpose of the Native Android Toolkit "Dependencies Resolver" is to prevent AAR or JAR dependencies included with the NAT installation from conflicting with possible AARs or JARs that already exist in your project,
                    proving Build errors like duplicate classes and the like. Read on to understand how the "Dependencies Resolver" works.
                </doc.topic>
                <!-- #endregion -->

                <!-- #region Dependencies Resolver: How does it work -->
                <doc.topic topicid="12">
                    <doc.topictitle>Dependencies Resolver: How does it work</doc.topictitle>

                    The "Dependencies Resolver" only works when called for execution. Dependencies Resolver can be called manually by the user through <doc.detach>Tools</doc.detach> &gt; <doc.detach>MT Assets</doc.detach> &gt;
                    <doc.detach>Native Android Toolkit</doc.detach> &gt; <doc.detach>Dependencies Resolver</doc.detach>. It is also called automatically whenever an AAR or JAR is added or removed from your project. The NAT Dependencies
                    Resolver runs automatically as well, after the Native Android Toolkit installed in the project is updated or overwritten, that is, when it is updated by the Asset Store, Package Manager or Unity Package Importer. it does
                    this so that the Dependencies Resolver can resolve any changes that the new version of NAT being imported brings in the dependencies included with NAT that is in your current project.
                    <br>
                    <br>
                    When it runs, Dependencies Resolver starts by taking a search of all the existing AARs and JARs in your project. It will then compare all of your project's AARs and JARs against the Libraries that are included with the
                    Native Android Toolkit installation. For every AAR or JAR found in your project, which is equal to a library included with NAT, it will disable the NAT Library and then only the Library found in your project will exist.
                    <br>
                    <br>
                    If for example your Native Android Toolkit has the <doc.detach>com.google.android.gms.games 17.0.0</doc.detach> Library and your project has the same <doc.detach>com.google.android.gms.games 15.0.0</doc.detach> Library,
                    NAT will disable the <doc.detach>com.google.android.gms.games 17.0.0</doc.detach> which is included in the installation of Native Android Toolkit so only the <doc.detach>com.google.android.gms.games 15.0.0</doc.detach>
                    Library that is in your project will remain activated. If eventually Library <doc.detach>com.google.android.gms.games 15.0.0</doc.detach> is removed from your project, NAT will activate Library
                    <doc.detach>com.google.android.gms.games 17.0.0</doc.detach> which is disabled and is included with NAT.
                    <br>
                    <br>
                    Thanks to this procedure, the chances of having a duplicated Library in your project, where NAT is the cause of the problem, are enormously reduced, including the chances of having a Build error proven by duplicated
                    classes (Libraries).

                    <doc.topicsubtitle>Viewing dependencies included with NAT</doc.topicsubtitle>
                    All dependencies included with the installation of Native Android Toolkit can be seen through the tool's Preferences window. This can be opened via <doc.detach>Tools</doc.detach> &gt; <doc.detach>MT Assets</doc.detach>
                    &gt; <doc.detach>Native Android Toolkit</doc.detach> &gt; <doc.detach>Preferences</doc.detach>. This documentation will also cover the <doc.detach>Preferences</doc.detach> window later on. Once you open this window,
                    scroll down and you will be able to see the list of all dependencies included in the Native Android Toolkit installation.
                    <doc.image src="DocumentationFiles/images/12"></doc.image>
                    In the <doc.detach>NAT Dependencies Resolver</doc.detach> section you are able to see a complete list of all dependencies included with the Native Android Toolkit installation.
                    <doc.list>
                        <doc.listr>The included dependences that have <doc.icon src="DocumentationFiles/images/14"></doc.icon> are Enabled and currently operating.</doc.listr>
                        <doc.listr>The included dependencies that have <doc.icon src="DocumentationFiles/images/13"></doc.icon> are Disabled because there is already the same dependency present in your project. The respective dependency of NAT is not operating.</doc.listr>
                        <doc.listr>The included added dependences that have <doc.icon src="DocumentationFiles/images/15"></doc.icon> could not be found which means that the file regarding them may have been deleted. This can certainly generate NAT operating failures in the "Dependencies Resolver" module or even the failure of some NAT API or Build errors. The best way to fix this is by re-importing NAT for your project.</doc.listr>
                    </doc.list>
                    Each time that "Dependencies Resolver" from Native Android Toolkit is run, it records all useful information in a log file called <doc.detach>NATDependenciesResolverLog.txt</doc.detach> that is present in the
                    <b>"Assets/Plugins/MT Assets/_AssetsData/Editor"</b> directory. You can check it to understand everything that was done by Dependencies Resolver from Native Android Toolkit if you want it.
                    <doc.info>
                        If a dependency appears in the Preferences without <doc.icon src="DocumentationFiles/images/14"></doc.icon>, <doc.icon src="DocumentationFiles/images/13"></doc.icon> or <doc.icon src="DocumentationFiles/images/15">
                        </doc.icon> means
                        that this dependency included with NAT is duplicated within Native Android Toolkit. The best thing to do is to execute the NAT <doc.detach>Dependencies Resolver</doc.detach> so that it can deal with this problem, but
                        if it does not work, may be necessary to delete the <doc.detach>Plugins/MT Assets/Native Android Toolkit</doc.detach> directory and then re-import NAT for your project to fix the problem.
                    </doc.info>

                    <doc.topicsubtitle>What happens when a Library included with the installation of NAT is disabled</doc.topicsubtitle>
                    Looking at Libraries included with NAT in Native Android Toolkit <doc.detach>Preferences</doc.detach> you may notice that all these dependencies (including your versions) are the necessary dependencies for Native Android
                    Tookit to work smoothly. This means that all these dependencies are part of a selected dependencies group and defined as minimum for Native Android Toolkit and all its C# APIs work smoothly. For example, if your project
                    has exactly all these dependencies, NAT will be executed without any unexpected problems, after all, these are the official dependencies of the NAT and even the dependencies in which all APIs C# have been tested.
                    <br>
                    <br>
                    When any of these dependencies are deactivated means that there is already an equal dependency in your project. This will extremely reduce the chance of some error of Build to happen, but if the deactivated dependency is
                    used by some NAT C# API, this may cause it not to work, if for example the dependency existing in your project is not version equal to or greater than the dependency used by NAT. If this happens, try to update the
                    dependency existing in your project so that it is the same version of the dependency used by Native Android Toolkit.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Dependencies Resolver: Solving build errors caused by AARs/JARs duplicate in the project -->
                <doc.topic topicid="13">
                    <doc.topictitle>Dependencies Resolver: Solving build errors caused by AARs/JARs duplicate in the project</doc.topictitle>

                    When you Build your application and get a duplicate class Build error, it is quite probable that you have come across this error because there is some duplicate AAR/JAR in your project, which makes the Java
                    Classes duplicate and the Libraries cause Build conflicts, which prevents the compiler from doing his job.
                    <br>
                    <br>
                    To correct this error you need to read the Build errors because they will often show you the AAR or JAR directory of problem causer. So you will have a sense of the name of the duplicate Library, thus causing this
                    problem. After identifying the problem Library, you need to find the duplicate. Since now you know the name of the duplicate Library, go to the Preferences of Native Android Toolkit and check if the NAT has a Library
                    with this name. If so, then check if there is an <doc.icon src="DocumentationFiles/images/13"></doc.icon> in this Library. If so, it means that the NAT has this same Library, but the NAT Library is completely disabled
                    and is not the cause of the problem.
                    <br>
                    <br>
                    If there is an <doc.icon src="DocumentationFiles/images/14"></doc.icon> in the Library, it means that it is enabled and possibly causing the conflict problem. You can try to execute the "Dependencies Resolver" from
                    Native Android Toolkit to solve the problem.
                    <doc.info>
                        If the problem is still not fixed, please contact Native Android Toolkit support through email <doc.detach>mtassets@windsoft.xyz</doc.detach> or the <doc.detach>MT Assets Community on Discord</doc.detach>. MT Assets
                        support is agile and can help you with whatever you need!
                    </doc.info>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Dependencies Resolver: "Dependencies Resolver" vs "External Dependency Manager for Unity" vs "Play Services Resolver" -->
                <doc.topic topicid="14">
                    <doc.topictitle>Dependencies Resolver: "Dependencies Resolver" vs "External Dependency Manager for Unity" vs "Play Services Resolver"</doc.topictitle>

                    As is well known, Android is based on a package architecture, where one or more applications that use the same system function depend on the same packages. Thus, it is not necessary that the code of that functionality is
                    copied in each application. Not only does this reduce application size and reduce its complexity, but also facilitates the update process, as this way, when a functionality is updated, it is enough that the application
                    depends on the new version of that respective package.
                    <br>
                    <br>
                    Native Android Toolkit itself depends on packages (Libraries AAR or JAR) to access certain functions of Android devices, a good example of this is access to the device's Camera. When you install other tools or SDKs that
                    interact with the Android system natively like <doc.detach>Unity IAP</doc.detach>, <doc.detach>Unity Mediation</doc.detach> or <doc.detach>Google Play Games</doc.detach>, these tools or SDKs also depend on packages.
                    <br>
                    <br>
                    The problem begins when one or more tools present in your project use the same packages. If each of them install their copies of these packages on their project, they would work well, but when used with other tools, it
                    would cause several build errors caused by duplicate classes (duplicate Libraries). Not to mention that a tool uses an X version and another tool uses a Y version, in which the Y version is old and not compatible with
                    both tools. This would cause one or both tools installed on your project not to work properly.
                    <br>
                    <br>
                    That's where the next theme comes in ...

                    <doc.topicsubtitle>What is "External Dependency Manager for Unity" or "Play Services Resolver"?</doc.topicsubtitle>
                    The <doc.detach>External Dependency Manager for Unity</doc.detach> or <doc.detach>Play Services Resolver</doc.detach> are basically the same thing. The <doc.detach>External Dependency Manager for Unity</doc.detach> is
                    the new name given to <doc.detach>Play Services Resolver</doc.detach>, so both work the same way and are the same thing.
                    <br>
                    <br>
                    Play Services Resolver is a tool that detects the dependences of each plugin in a Unity project and then seeks these dependencies in repositories such as Maven, solving them automatically so that there are no problems
                    with versions, duplicate classes and so on. "Play Services Resolver" is usually included in your project automatically when you install plugins such as Unity Mediation SDK, Unity IAP, Firebase SDK, Google Play Games made
                    by Google and similar ones. When this happens, "Play Services Resolver" installs libraries for these tools automatically. Since these AAR or JAR downloaded by Play Services Resolver are on your project, only one copy of
                    each will be there. This way, all the plugins of your project will use those downloaded dependencies.

                    <doc.topicsubtitle>How does NAT "Dependencies Resolver" fit in here?</doc.topicsubtitle>
                    Aiming at greater convenience and ease of use, Native Android Toolkit already includes with it all the AAR and JAR dependencies it needs to work. These dependencies are bundled with the Native Android Toolkit
                    installation files. This makes the Native Android Toolkit the kind of tool where you just install it in your project and use it. Without having to download anything.
                    <br>
                    <br>
                    The problem with this is that if your project already has a dependency that NAT uses (whether it is downloaded by Play Services Resolver or not), you will have problems with Build errors. That's where the NAT
                    "Dependencies Resolver" module comes in. Native Android Toolkit detects new AARs and JARs installed or removed by Play Services Resolver, and to avoid build problems, Dependencies Resolver from Native Android Toolkit
                    makes the task of disabling AARs/JARs included with NAT, which now already exist In your project, to avoid duplicates. Thus it is possible to avoid the malfunction of NAT.
                    <doc.info>
                        NAT has a file that informs "Play Services Resolver" which essential Libraries NAT needs, and thus "Play Services Resolver" takes into account what NAT needs as well. NAT will only specify to "Play Services Resolver"
                        the essential dependences it must necessarily, or the dependencies in which the NAT needs to be of that version or higher.
                    </doc.info>

                    <doc.topicsubtitle>In short...</doc.topicsubtitle>
                    Native Android Toolkit <doc.detach>Dependencies Resolver</doc.detach> and <doc.detach>Play Services Resolver</doc.detach> are different things. The Play Services Resolver does the heavy lifting, and the NAT Dependencies
                    Resolver only complements it, shaping the Native Android Toolkit to inform it about the already existing dependencies in the project, thus avoiding Build problems mainly.
                    <br>
                    <br>
                    In the end, if your project has Play Services Resolver (with Libraries downloaded or not) you will still be able to use NAT and compile your application without any problems. If your project does NOT have Play Services
                    Resolver or other Plugins, NAT will still work fine!
                    <doc.warn>
                        It is important that you never delete any Library that is installed as a Library included with Native Android Toolkit. Doing this will cause the tool malfunction.
                        <br>
                        <br>
                        If you have any problems involving Native Android Toolkit, it is very important that you contact MT Assets Support on <doc.detach>mtassets@windsoft.xyz</doc.detach>. It will be a pleasure to help you!
                    </doc.warn>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Dependencies Resolver: Useful informations about NAT Dependencies Resolver -->
                <doc.topic topicid="15">
                    <doc.topictitle>Dependencies Resolver: Useful informations about NAT Dependencies Resolver</doc.topictitle>

                    There are some tips that can be useful to you while using Native Android Toolkit, regarding dependencies and Dependencies Resolver module from Native Android Toolkit.

                    <doc.topicsubtitle>Dealing with Plugins dependencies in your project</doc.topicsubtitle>
                    With the Native Android Toolkit included dependencies you usually don't have to worry. As seen before, they are managed by the "Dependencies Resolver" module of the Native Android Toolkit. When the dependencies of
                    third-party plugins, if they make use of "Play Services Resolver" or "External Dependency Manager for Unity", you just have to worry about leaving the tool configured correctly and running it so that the dependencies are
                    resolved.

                    <doc.topicsubtitle>Use the highest Taget API Level, whenever possible</doc.topicsubtitle>
                    Under <doc.detach>Project Settings</doc.detach> &gt; <doc.detach>Player</doc.detach> &gt; <doc.detach>Other Settings</doc.detach> &gt; <doc.detach>Target API Level</doc.detach>, always build your app with the latest
                    API version available if possible. This avoids Build errors caused by dependencies that require a higher <doc.detach>Target API Level</doc.detach> to work.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Preferences: What are the Preferences of NAT -->
                <doc.topic topicid="16">
                    <doc.topictitle>Preferences: What are the Preferences of NAT</doc.topictitle>

                    The Native Android Toolkit Preferences window is a place where you can change all sorts of behaviors or configure your preferred NAT settings. You can access the Preferences from <doc.detach>Tools</doc.detach> &gt;
                    <doc.detach>MT Assets</doc.detach> &gt; <doc.detach>Native Android Toolkit</doc.detach> &gt; <doc.detach>Preferences</doc.detach>. Read on to understand more about this.
                </doc.topic>
                <!-- #endregion -->

                <!-- #region Preferences: Explaining the Interface -->
                <doc.topic topicid="17">
                    <doc.topictitle>Preferences: Explaining the Interface</doc.topictitle>

                    <doc.frame contentside="right" contentheight="350px">
                        From the frame on the Left side of the Preferences window, you can browse the Preference categories.
                        <br>
                        <br>
                        With Preferences organized into categories, it's easier to find what you want to edit in Native Android Toolkit.
                        <doc.flextext></doc.flextext>
                        <doc.frameci src="DocumentationFiles/images/16"></doc.frameci>
                    </doc.frame>

                    <doc.frame contentside="right" contentheight="350px">
                        In the Right frame, we see the content of each category. After selecting a Preferences category, the content here will update to show Preferences for the desired category.
                        <doc.flextext></doc.flextext>
                        <doc.frameci src="DocumentationFiles/images/17"></doc.frameci>
                    </doc.frame>

                    <doc.frame contentside="right" contentheight="350px">
                        In the footer of the window, you will find the <doc.detach>Save Preferences</doc.detach> button. Once you have changed anything in the Preferences window, you must click the <doc.detach>Save Preferences</doc.detach>
                        button so that the changes are saved in all modules of the Native Android Toolkit.
                        <doc.flextext></doc.flextext>
                        <doc.frameci src="DocumentationFiles/images/18"></doc.frameci>
                    </doc.frame>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Preferences: Some editable parameters in AndroidManifest and GradleProperties -->
                <doc.topic topicid="19">
                    <doc.topictitle>Preferences: Some editable parameters in AndroidManifest and GradleProperties</doc.topictitle>

                    Before getting into this topic, we need to understand a few things first...

                    <doc.topicsubtitle>What is Android Manifest?</doc.topicsubtitle>
                    The Android Manifest is a file that EVERY application developed for Android must have. This file basically describes key features of the application, such as permissions that will be used, existing activities, services
                    that can run in the background, etc. No Android application will work without an <doc.detach>AndroidManifest.xml</doc.detach> file. You can get more information about this by clicking
                    <a href="https://developer.android.com/guide/topics/manifest/manifest-intro" target="_blank">here</a>.

                    <doc.topicsubtitle>What is Gradle Properties?</doc.topicsubtitle>
                    Gradle is an open source compilation system. It is currently the official build system used to build Android applications. Basically the <doc.detach>gradle.properties</doc.detach> files are responsible for providing
                    settings and options for Gradle to take into account during the compilation process. You can get more information by clicking
                    <a href="https://developer.android.com/studio/build" target="_blank">here</a>.

                    <doc.topicsubtitle>What is Unity relationship to these files?</doc.topicsubtitle>
                    Whenever Unity compiles your Android application, it generates <doc.detach>AndroidManifest.xml</doc.detach>, <doc.detach>gradle.properties</doc.detach> and many other files that are hidden for you so you can only worry
                    about creating your game or application. During the compilation process any necessary file is generated by Unity so that in the end an APK is produced as a result.
                    <br>
                    <br>
                    All files generated by Unity during the compilation process are configured as default and with settings focused on the execution of UnityPlayer (activity that will be your game or application running on the Android
                    device). However, sometimes it may be necessary to modify some of these files so that some aspect of your application or compilation is changed. Unity allows this, but it is necessary that you define a file referring to
                    what you need, in your project.
                    <br>
                    <br>
                    Accessing the settings, in <doc.detach>Edit</doc.detach> &gt; <doc.detach>Project Settings...</doc.detach> &gt; <doc.detach>Player</doc.detach> &gt; <doc.detach>Publishing Settings</doc.detach> you are able to define
                    custom files for everything you need to modify. For example, enabling the <doc.detach>Custom Main Manifest</doc.detach> option will cause Unity to create a file called <doc.detach>AndroidManifest.xml</doc.detach> inside
                    the <b>"Assets/Plugins"</b> path of your project.
                    <br>
                    <br>
                    Editing this Unity generated file, and adding the things you want to modify, will make the items you add to this file go into your project builds, for Android. The same thing goes for the
                    <doc.detach>gradle.properties</doc.detach> file.

                    <doc.topicsubtitle>What are the editable parameters in these files?</doc.topicsubtitle>
                    And finally... The Native Android Toolkit, through the Preferences window, allows you to edit some parameters of these files.
                    <doc.frame contentside="right" contentheight="350px">
                        In the file <doc.detach>AndroidManifest.xml</doc.detach> the Native Android Toolkit has the following editable parameters...
                        <doc.list>
                            <doc.listr><doc.detach>Modify Android Manifest</doc.detach> - Toggling this parameter to <b>"Yes Generate New If Not Exists"</b> will cause NAT to generate an AndroidManifest file for your project and allow NAT to edit this file only where necessary, only in the parameters you change.</doc.listr>
                            <doc.listr>
                                <doc.detach>Declare Unity Activity</doc.detach> - Android applications work on an <b>"Activities"</b> principle like the <b>"Windows"</b> of the Windows OS. Opening an app by tapping its icon will open the main activity of that app. As the application wants, it can open or close windows as the user uses it, you can get more information about Android Activities by clicking <a href="https://developer.android.com/guide/components/activities/intro-activities" target="_blank">here</a>. In the case of applications built with Unity, when opening the application the first activity opened is the <b>"UnityPlayerActivity"</b>. This is the activity configured as the main activity and it is where your application made with Unity will run, so this activity is already declared and configured as the main activity in the <b>"AndroidManifest"</b> file by Unity. As by default this activity is always declared by Unity, this option is already activated. You can disable it if you don't want to declare it in your custom <b>"AndroidManifest"</b> file.
                                <doc.list>
                                    <doc.listr><doc.detach>Is Main Activity</doc.detach> - A main activity, as stated earlier, is an activity that will open automatically whenever the app is opened from the Android device's apps screen. In the case of Unity, the default main activity is <b>"UnityPlayerActivity"</b>. An Android application cannot open and will not appear in the application list if it does not have a main activity. Disabling this option will make <b>"UnityPlayerActivity"</b> no longer the main activity and this will allow you to set another activity as the main one if you are an advanced enough user to do so.</doc.listr>
                        </doc.list>
                        </doc.listr>
                        <doc.listr><doc.detach>Skip Permissions Dialog</doc.detach> - If this option is activated, the <b>"UnityPlayerActivity"</b> activity will not display a dialog asking for all AndroidManifest permissions automatically as soon as your application is opened by the user, which can happen on some devices. When enabling this permission, you will need to use the NAT Permissions API to request the permissions your application may need. Note that even leaving this option disabled, it may still be necessary to use the NAT Permissions API if your application needs it, as there is no guarantee that permissions will be automatically requested on all devices.</doc.listr>
                        </doc.list>
                        <doc.frameci src="DocumentationFiles/images/20"></doc.frameci>
                    </doc.frame>
                    <doc.warn>
                        If you do not intend to define another main activity for your application, then it is extremely important that you keep the <doc.detach>Is Main Activity</doc.detach> option enabled, because as stated before, an
                        application will not appear in the application list and cannot be opened by the user. if don't have a main activity.
                    </doc.warn>
                    <doc.frame contentside="right" contentheight="350px">
                        In the file <doc.detach>gradle.properties</doc.detach> the Native Android Toolkit has the following editable parameters...
                        <doc.list>
                            <doc.listr><doc.detach>Modify Gradle Properties</doc.detach> - Toggling this parameter to <b>"Yes Generate New If Not Exists"</b> will cause NAT to generate an GradleProperties file for your project and allow NAT to edit this file only where necessary, only in the parameters you change.</doc.listr>
                            <doc.listr><doc.detach>Enable Dexing Artifact Transform</doc.detach> - If you want to allow NAT to edit your GradleProperties file (NAT will only edit where needed) it will add this option so that some NAT stuff works smoothly. Therefore, this option must be disabled for this to occur.</doc.listr>
                        </doc.list>
                        <doc.frameci src="DocumentationFiles/images/21"></doc.frameci>
                    </doc.frame>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Preferences: Enabling or Disabling dependencies embedded in the NAT -->
                <doc.topic topicid="22">
                    <doc.topictitle>Preferences: Enabling or Disabling dependencies embedded in the NAT</doc.topictitle>

                    As explained earlier <a href="#12">here</a> in this documentation Native Android Toolkit already includes all required dependencies when you install Native Android Toolkit. This is for greater ease of use of NAT.
                    However, sometimes it may be necessary to disable some dependencies, for testing purposes for example. Follow the steps below for this...

                    <br>
                    <br>

                    <doc.frame contentside="right" contentheight="400px">
                        <b>Step 1:</b> Open the <doc.detach>Preferences</doc.detach> window, and scroll down to the end of the <doc.detach>Main Preferences</doc.detach> category. Then click on <doc.detach>Edit Dependencies</doc.detach>.
                        <doc.flextext></doc.flextext>
                        <doc.frameci src="DocumentationFiles/images/22"></doc.frameci>
                    </doc.frame>

                    <doc.frame contentside="left" contentheight="400px">
                        <b>Step 2:</b> Now, disable or enable the permissions you prefer and then click the <doc.detach>Done</doc.detach> button.
                        <doc.frameci src="DocumentationFiles/images/23"></doc.frameci>
                    </doc.frame>

                    <doc.info>
                        Note that all disabled dependencies will be enabled again if the NAT <doc.detach>Dependencies Resolver</doc.detach> is run. However, dependencies that have been disabled by the NAT
                        <doc.detach>Dependencies Resolver</doc.detach> will be permanently disabled until the <doc.detach>Dependencies Resolver</doc.detach> deems it necessary to enable them again. For more details, read
                        <a href="#12">this</a> topic.
                    </doc.info>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Preferences: Explaining the Preferences categories -->
                <doc.topic topicid="23">
                    <doc.topictitle>Preferences: Explaining the Preferences categories</doc.topictitle>

                    These are the Preference categories. Generally, each of these refers to a C# API class from the Native Android Toolkit. See more about each of them below...

                    <doc.topicsubtitle>Main Preferences</doc.topicsubtitle>
                    Refers to NAT Core Preferences. Preferences that affect Native Android Toolkit as a whole.

                    <doc.topicsubtitle>Permissions</doc.topicsubtitle>
                    They refer to the NAT C# API Permissions class, as well as the permissions that can be used by NAT. Here you can disable permissions that are used by NAT, so that these permissions do not appear in your application. Here
                    you can disable permissions that will not be used by your application.

                    <doc.topicsubtitle>Notifications</doc.topicsubtitle>
                    This class refers to Notifications preferences. Here for example you can change the notification icon for your application.

                    <doc.topicsubtitle>Webview</doc.topicsubtitle>
                    Here you can set preferences for the NAT Webview C# API as well as customize the Webview.

                    <doc.topicsubtitle>Utils</doc.topicsubtitle>
                    Here you configure the "Utils" class of the C# API of the Native Android Toolkit.

                    <doc.topicsubtitle>Location</doc.topicsubtitle>
                    Here you configure information for the C# API of the NAT, referring to the location. You can also customize the NAT Google Maps view.

                    <doc.topicsubtitle>Camera</doc.topicsubtitle>
                    Here you can customize the NAT Camera view as well as other preferences.

                    <doc.topicsubtitle>Applications</doc.topicsubtitle>
                    In this category, you have access to settings regarding the Android package and application system and its related NAT C# API.

                    <doc.topicsubtitle>Date Time</doc.topicsubtitle>
                    Here you can define the NTP servers that will be used by the C# API of the NAT, as well as other things related to time.

                    <doc.topicsubtitle>Files</doc.topicsubtitle>
                    In this category you can set preferences regarding the C# API of the Files class.

                    <doc.topicsubtitle>Tasks</doc.topicsubtitle>
                    In this category you can set your preferences for NAT Tasks, their respective C# API and also program your own Tasks however you want!

                    <doc.topicsubtitle>Play Games</doc.topicsubtitle>
                    Here you configure access to Google Play Games through the Native Android Toolkit, and even provide information for the NAT C# API.

                    <doc.topicsubtitle>NAT Core Library</doc.topicsubtitle>
                    Here you can control aspects of the native core of NAT.

                    <doc.topicsubtitle>Additional Tools</doc.topicsubtitle>
                    Here you will find tool suggestions that can help you a lot during your development on the Android platform.

                </doc.topic>
                <!-- #endregion -->

                <br>
                <br>
                <br>
                <doc.achiev>
                    From now on, this documentation will focus on the Native Android Toolkit C# API and its respective classes. You will find usage examples and explanations of each NAT API.
                </doc.achiev>
                <br>
                <br>
                <br>

                <!-- #region Dialogs: About This Class -->
                <doc.topic topicid="36">
                    <doc.topictitle>Dialogs: About This Class</doc.topictitle>

                    With this Native Android Toolkti C# API class, your application will be able to access the native dialog system of Android devices. You'll be able to display native dialogs with Callbacks for each user's decision, and
                    more!

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Dialogs: Simple Alert Dialog -->
                <doc.topic topicid="37">
                    <doc.topictitle>Dialogs: Simple Alert Dialog</doc.topictitle>

                    To display a simple dialog, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //============     FIRST, register the callbacks...     ============//
    
    //- onSimpleAlertDialogOk()
    //  Callback in case the user clicks the "Ok" button
    NATEvents.onSimpleAlertDialogOk += () =>
    {
        Debug.Log("Clicked in Ok!");
    };
    //- onSimpleAlertDialogOk()
    //  Callback in case the user clicks the back button, or clicks outside the dialog box, canceling it.
    NATEvents.onSimpleAlertDialogCancel += () =>
    {
        Debug.Log("Cancelled");
    };
    
    //============      Call the code of the NAT C# API     ============//
    
    //- ShowSimpleAlertDialog(title, message, isCancelable);
    //  Show the dialog box.
    NAT.Dialogs.ShowSimpleAlertDialog("Simple Alert Dialog", "This is a simple alert dialog.", true);
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Dialogs: Confirmation Alert Dialog -->
                <doc.topic topicid="38">
                    <doc.topictitle>Dialogs: Confirmation Alert Dialog</doc.topictitle>

                    To display a two-button dialog box, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //First, register the callbacks...
        
    //- onConfirmationDialogNo()
    NATEvents.onConfirmationDialogNo += () =>
    {
        Debug.Log("Clicked in No!");
    };
    //- onConfirmationDialogYes()
    NATEvents.onConfirmationDialogYes += () =>
    {
        Debug.Log("Clicked in Yes!");
    };
    //- onConfirmationDialogCancel()
    NATEvents.onConfirmationDialogCancel += () =>
    {
        Debug.Log("Cancelled");
    };
        
    //Second, call the code of the NAT C# API
        
    //- ShowConfirmationDialog(title, message, isCancelable, yesButtonText, noButtonText);
    NAT.Dialogs.ShowConfirmationDialog("Confirmation Alert Dialog", "This is a confirmation alert dialog.", false, "Yes", "No");
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Dialogs: Neutral Alert Dialog -->
                <doc.topic topicid="39">
                    <doc.topictitle>Dialogs: Neutral Alert Dialog</doc.topictitle>

                    To display a three-button dialog box, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //First, register the callbacks...
        
    //- onNeutralDialogNo()
    NATEvents.onNeutralDialogNo += () =>
    {
        Debug.Log("Clicked in No!");
    };
    //- onNeutralDialogYes()
    NATEvents.onNeutralDialogYes += () =>
    {
        Debug.Log("Clicked in Yes!");
    };
    //- onNeutralDialogNeutral()
    NATEvents.onNeutralDialogNeutral += () =>
    {
        Debug.Log("Clicked in Neutral!");
    };
    //- onNeutralDialogCancel()
    NATEvents.onNeutralDialogCancel += () =>
    {
        Debug.Log("Cancelled");
    };
        
    //Second, call the code of the NAT C# API
        
    //- ShowNeutralDialog(title, message, isCancelable, yesButtonText, noButtonText, neutralButtonText);
    NAT.Dialogs.ShowNeutralDialog("Neutral Alert Dialog", "This is a neutral alert dialog.", false, "Yes", "No", "I don't know");
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Dialogs: Radial List Dialog -->
                <doc.topic topicid="40">
                    <doc.topictitle>Dialogs: Radial List Dialog</doc.topictitle>

                    To display a list of options in which you can only select a single option, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //First, register the callbacks...
        
    //- onRadialListDialogCancel()
    NATEvents.onRadialListDialogCancel += () =>
    {
        Debug.Log("Cancelled");
    };
    //- onRadialListDialogDone()
    NATEvents.onRadialListDialogDone += (int choosed) =>
    {
        if (choosed == 0)
            Debug.Log("Ferrari Selected");
        if (choosed == 1)
            Debug.Log("Audi Selected");
        if (choosed == 2)
            Debug.Log("BMW Selected");
    };
        
    //Second, call the code of the NAT C# API
        
    //- ShowNeutralDialog(title, optionsArray, isCancelable, doneButtonText, defaultOptionSelected);
    NAT.Dialogs.ShowRadialListDialog("Radial List Dialog", new string[] { "Ferrari", "Audi", "BMW" }, true, "Done", 1);
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Dialogs: Check List Alert Dialog -->
                <doc.topic topicid="41">
                    <doc.topictitle>Dialogs: Check List Alert Dialog</doc.topictitle>

                    To display a list of options in which you can select more than one options, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //First, register the callbacks...
        
    //- onCheckboxListDialogCancel()
    NATEvents.onCheckboxListDialogCancel += () =>
    {
        Debug.Log("Cancelled");
    };
    //- onCheckboxListDialogDone()
    NATEvents.onCheckboxListDialogDone += (bool[] chooseds) =>
    {
        if (chooseds[0] == true)
            Debug.Log("You selected 'Pizza'!");
        if (chooseds[1] == true)
            Debug.Log("You selected 'Donuts'!");
        if (chooseds[2] == true)
            Debug.Log("You selected 'Potato'!");
    };
        
    //Second, call the code of the NAT C# API
        
    //- ShowCheckListDialog(title, optionsArray, isCancelable, doneButtonText, defaultOptionSelectedArray);
    NAT.Dialogs.ShowCheckListDialog("Check List Dialog", new string[] { "Pizza", "Donuts", "Potato" }, true, "Done", new bool[] { false, false, false });
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Power Manager: About This Class -->
                <doc.topic topicid="43">
                    <doc.topictitle>Power Manager: About This Class</doc.topictitle>

                    This class offers tools and access to APIs related to Android Power Management systems.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Power Manager: What is Power Management on Android devices and how it can affect your Application -->
                <doc.topic topicid="44">
                    <doc.topictitle>Power Manager: What is Power Management on Android devices and how it can affect your Application</doc.topictitle>

                    As you may know, all Android devices nowadays have the methods of saving battery. The Android system itself already has battery saving strategies, some manufacturers choose to include additional features to extend the
                    battery life of the device. This topic will deepen this and explain more about battery saving on Android devices and how it can affect its application.
                    <br>
                    <br>
                    Now let's learn about some battery economy methods used on Android devices.

                    <doc.topicsubtitle>DOZE</doc.topicsubtitle>
                    This is a battery economy method implemented by Google on Android 6.0 or higher devices. You can have more information about it by clicking
                    <a href="https://developer.android.com/training/monitoring-device-state/doze-standby" target="_blank">here</a>. This is usually not a harmful feature for your application, it works as follows... After a time when the
                    device goes inactive, ie without the user uses the device, the device will perform some tasks that were Scheduled for that time or near that time, after that will enter the DOZE mode. In DOZE mode, the device will
                    considerably reduce the use of CPU, postponing pending tasks, reducing the cadence of checks and pausing processes. During the DOZE, if the user continues without using the device, the phone will wake up from time to
                    time to check if there are tasks that need to be done at that time or near that time.
                    <br>
                    <br>
                    The device will also wake up if the user takes the device to use it, press the power button. The device will also wake up moments before a high priority task (such as a clock alarm). If the device wakes up for any of
                    these last reasons cited, the device will only go back to DOZE if it has been time without the user. For example, you may have noticed that in the morning, after sleeping without leaving your phone charging,
                    sometimes you take your phone and come across some notifications coming as soon as you unlock it. Sometimes after a few hours without using cell phone you also notice that. This is because the device was sleeping, and
                    when you wake it up, it performs all low-priority tasks, which makes notifications of some apps and similar things arrive. Note that the phone does not enter the DOZE mode while it is charging, as it is in a source of
                    energy.

                    <doc.topicsubtitle>App Standby Buckets</doc.topicsubtitle>
                    You can have more details about this feature by clicking <a href="https://developer.android.com/topic/performance/appstandby" target="_blank">here</a>. This is a feature also implemented by Google on all devices with
                    Android 9.0 or higher. This feature allows the Android device to detect the frequency of use of each installed application. That said, the system has several "buckets" according to each type of frequency ranging from
                    "active" to "rarely used". The system places applications rarely used on a bucket and all applications on this bucket has its dramatically reduced or postponed task executions. Applications that are not used for a few
                    months lose their permissions and can no longer perform background tasks until the user opens them again. Whenever this happens, the user receives a notification that informs him that certain
                    unused applications have lost their permissions.

                    <doc.topicsubtitle>Battery Saver Applications</doc.topicsubtitle>
                    Battery economy applications are never installed by Google on the Android device, as it itself has safe and tested battery saving features. Unfortunately, however, several brands do this by installing these battery
                    economy applications that cannot be uninstalled. Examples are Asus, Samsung, OnePlus and others.
                    <br>
                    <br>
                    The problem with these applications is that in addition to the methods already implemented by Google and Functional, these applications often limit or even restrict the operation of other applications installed on the
                    user device, in some cases some of these applications often kill any other application that is doing some background task.

                    <doc.topicsubtitle>Modified ROMs</doc.topicsubtitle>
                    As you know, many brands use Android and many of them customize the Android system generating a variant that is used on that brand's devices. We can cite some example variants like <doc.detach>Mi UI</doc.detach>
                    (Xiaomi), <doc.detach>OneUI</doc.detach> (Samsung), <doc.detach>Oxygen OS</doc.detach> (OnePlus) and others.
                    <br>
                    <br>
                    The problem with some of these variants is that many of them modify Android so as to extend the battery life artificially, as prohibiting applications that are not on the white list of these ROMs from performing anything
                    on the background, changing the standard behavior of Android system battery savings and etc. Currently the worst modified ROMs are from Samsung and OnePlus that ban 99% of application background executions.
                    <doc.info>
                        There is a website that talks about this theme, classifies the worst brands of mobile phones and even teaches how to configure so that its application is not so affected by these battery saving strategies of some
                        brands. Click here to visit the website <a href="https://dontkillmyapp.com/" target="_blank">Don't kill my app</a>!
                    </doc.info>

                    <doc.topicsubtitle>And how can this affect my application?</doc.topicsubtitle>
                    If your application will not use <b>Scheduled Notifications</b> or <b>Tasks</b>, then it should probably not be affected. Now if your application will use it, then it is this topic that interests you.
                    <br>
                    <br>
                    It is not most brands that implement abusive drum economy strategies. Both to deliver <b>Scheduled Notifications</b> or perform <b>NAT Background Tasks</b>, your app needs to perform background tasks. This is not a
                    Native Android Toolkit rule, all Android application that will deliver a notification or run background code needs to open a service, process or perform a scheduled task. This works well on the vast majority of device
                    brands, but in some, thanks to the abusive battery saving strategies, the notifications or tasks of their application may be affected being delayed or in some cases even prevented.
                    <br>
                    <br>
                    Some brands, for example, kill any application that is running a background code if the user is not using that application for more than a few minutes. Other brands only postpone these background tasks for a few minutes,
                    hours or days. It all depends on each brand, but in general, unfortunately the only way for an application not to be included in these battery economizers is whether the device user includes your application on the
                    device Whitelist.
                    <br>
                    <br>
                    As stated earlier, this is a rule. Any application (whether or not using Native Android Toolkit) needs to perform some background code to send Scheduled Notifications or perform tasks. Famous apps like Facebook, Google
                    Apps, Twitter, WhatsApp, Instagram and others will always be on these brands Whitelists and so they will never have their activities prevented. You will notice that other non-famous or not many famous games will always
                    have some delay in delivering notifications in these more aggressive brands in the drum economy.
                    <br>
                    <br>
                    As stated earlier, the only way to prevent an application from being affected is by adding to the device whiteist. The problem is that not all users know this, so Native Android Toolkit has some internal strategies to
                    try to deliver Scheduled Notifications or Tasks even on devices with such aggressive battery economies. In NAT Preferences you will find options like <doc.detach>Enable Accuracy Notify</doc.detach> or
                    <doc.detach>Enable Accuracy Tasks</doc.detach> that will use another method of scheduling the most aggressive background code that will ensure that the notification or task is delivered as close as possible to the
                    scheduled time by yours application.
                    <br>
                    <br>
                    If you disable these options, NAT will deliver notifications or tasks in the normal way, which will work fine on devices with ROMs that have not been modified to artificially extend battery life. Notifications may be
                    delayed by the system for battery saving reasons. The system will try to launch the notification along with some more grouped tasks that have been scheduled by other applications or in time windows defined by the
                    system, to reduce processing and battery consumption, so although the system will try to deliver the notification closer to the time stipulated, it can still be delayed by a few seconds or minutes. However, if the
                    device has a very aggressive battery saver app, or a ROM modified to artificially extend battery life, then your app may not be able to deliver notifications or scheduled tasks if these NAT options are disabled.
                    <br>
                    <br>
                    Unfortunately there is nothing you can do except advise the user to add your app to the device's whitelist if the user is not receiving ANY notifications or tasks.

                    <doc.topicsubtitle>Conclusion</doc.topicsubtitle>
                    This is an informational topic. Not all cell phones will have problems delivering notifications or tasks, even those that have abusive modifications implemented by brands. But if this happens, you are already informed of
                    the cause. Currently, Samsung, OnePlus and Huawei are the most problematic brands when it comes to aggressive battery saving. In the end, all apps (except the famous ones) are affected by these aggressive battery savers
                    of some cell phones. Unfortunately brands like these implement these abusive battery saving tactics to claim that their devices have longer battery life.
                    <doc.info>
                        We recommend that you check out the <a href="https://dontkillmyapp.com/" target="_blank">Don't kill my app!</a> website to delve deeper into this subject and understand all of this in more detail. This website was
                        created by developers who explain why and how brands aggressively save battery life.
                    </doc.info>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Power Manager: Check if Exact Alarms and Tasks are allowed for your Application -->
                <doc.topic topicid="45">
                    <doc.topictitle>Power Manager: Check if Exact Alarms and Tasks are allowed for your Application</doc.topictitle>

                    The "Exact Alarms and Tasks" feature will allow NAT to accurately schedule tasks and notifications on the device, if this is enabled.
                    <br>
                    <br>
                    Currently, when an application is installed on the device, it automatically gets this feature enabled. From Android 12 onwards, user can disable this feature from system settings.
                    <br>
                    <br>
                    You can use the code below to check if this feature is enabled for your application.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isExactAlarmsAndTasksAllowed();
    bool isEnabled = NAT.PowerManager.isExactAlarmsAndTasksAllowed();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Power Manager: Open Alarms and Reminders Access -->
                <doc.topic topicid="46">
                    <doc.topictitle>Power Manager: Open Alarms and Reminders Access</doc.topictitle>

                    If you need to request access to the feature "Exact Alarms and Tasks" for the user, you can use this method. It will open a system interface for the user to enable this feature on the device, for your application.
                    <br>
                    <br>
                    Calling this method on devices running Android 11 or lower will do nothing as it is not possible to disable this feature on these devices. Just note that before calling this method you must explain to the user that it
                    will redirect them to the device settings screen, explain to them that they need such a feature to ensure that notifications and tasks are delivered accurately. In this way, the user will understand that it is a
                    necessary feature for their application.
                    <br>
                    <br>
                    Use the code below to request access to the feature "Exact Alarms and Tasks" or "Alarm and Reminders Access".
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- OpenAlarmsAndRemindersAccess();
    NAT.PowerManager.OpenAlarmsAndRemindersAccess();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Power Manager: Checking if the device is considered "Problematic" in relation to the Power Manager/Battery Saver -->
                <doc.topic topicid="47">
                    <doc.topictitle>Power Manager: Checking if the device is considered "Problematic" in relation to the Power Manager/Battery Saver</doc.topictitle>

                    A device deemed "problematic" by the Native Android Toolkit is a device that has a very aggressive battery-saving app implemented out of the box, or a ROM that attempts to artificially extend battery life by killing
                    background apps, as described <a href="#44">here</a>...
                    <br>
                    <br>
                    When using the code below NAT will use built-in logic (checking the device vendor and model) to detect if the current device is potentially problematic so that your app has a sense and can display something like an alert
                    box (for example "Not getting notifications?") that helps the user in case they are not getting notifications or something like that.
                    <br>
                    <br>
                    Devices deemed to be problematic may also experience difficulties receiving notifications from Google's Firebase Cloud Messaging, whether they are using the Native Android Toolkit or not, as FCM uses a background code to
                    retrieve these notifications.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isThisDeviceProblematic();
    bool isProblematic = NAT.PowerManager.isThisDeviceProblematic();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Power Manager: Requesting AutoStart Enabled if the device is considered "Problematic" -->
                <doc.topic topicid="48">
                    <doc.topictitle>Power Manager: Requesting AutoStart Enabled if the device is considered "Problematic"</doc.topictitle>

                    On some problematic devices, you can enable "Auto Start" for your application, which will allow your application to start code in the background, which will allow delivery of notifications or tasks.
                    <br>
                    <br>
                    Xiaomi, for example, has MiUI which is a custom Android ROM, which has not so aggressive battery saving strategies. If you leave the "Enable Accuracy Notify" and "Enable Accuracy Tasks" options disabled in the Native
                    Android Toolkit Preferences, Xiaomi phones will still be able to deliver your notifications, but will defer them to an opportune time for the device. However, if "Auto Start" is enabled for your app, notifications and
                    tasks will be delivered more consistently. But if the "Enable Accuracy Notify" and "Enable Accuracy Tasks" options are enabled in NAT, then notifications should be delivered in a much more accurate way.
                    <br>
                    <br>
                    On brands like OnePlus, "Auto Start" can really make a difference. The feature of enabling "Auto Start" will not always work for all devices, but in many cases it can be useful.
                    <br>
                    <br>
                    By calling the code below, your application will open a system window that will redirect the user to the settings screen and teach them how to enable "Auto Start" for that device. This method will do nothing if called on
                    a device not considered to be problematic. Unfortunately, there is no way to check if your app has "Auto Start" enabled or if it is on the Whitelist of these brands, since the devices of these brands do not have ANY kind
                    of native API in their ROMs that allow these checks.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- RequestAutoStartONIfProblematic();
    NAT.PowerManager.RequestAutoStartONIfProblematic();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Notifications: About This Class -->
                <doc.topic topicid="50">
                    <doc.topictitle>Notifications: About This Class</doc.topictitle>

                    The NAT Notifications class provides methods and tools for your application to deliver Notifications and Scheduled Notifications for any time in the future. Your application has full control of
                    notifications very easily with the C# API of this class.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Notifications: Show Toast Message -->
                <doc.topic topicid="51">
                    <doc.topictitle>Notifications: Show Toast Message</doc.topictitle>

                    To display a Toast notification on device screen, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- ShowToast(message, longDuration);
    NAT.Notifications.ShowToast("Toast message", true);
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Notifications: Send Notification -->
                <doc.topic topicid="52">
                    <doc.topictitle>Notifications: Send Notification</doc.topictitle>

                    To send an instant push notification to the device, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- SendNotification(title, message);
    NAT.Notifications.SendNotification("Notification Title", "Message");
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Notifications: Scheduling Notifications -->
                <doc.topic topicid="55">
                    <doc.topictitle>Notifications: Scheduling Notifications</doc.topictitle>

                    In this topic Scheduled Notifications will be discussed and you will learn how to work with these notifications in your application.

                    <doc.topicsubtitle>What are Scheduled Notifications?</doc.topicsubtitle>
                    Scheduled Notifications are Push Notifications that can be scheduled to be delivered at any time in the future. This can be done using the NAT C# API, as you'll see in this topic. These Scheduled Notifications can be
                    useful in situations where you need to notify the user about something. An example of this is in construction games for example.
                    <br>
                    <br>
                    Let's say that in your game, the user is going to put something to build. Construction will take 8 hours to complete. Knowing this, the moment the construction starts, your application will schedule a notification to
                    be delivered in 8 hours, notifying the user that the construction has been completed (even if your game is closed). This strategy is the same as many village and construction games use, such as Clash Of Clans.

                    <doc.topicsubtitle>Notification Channels</doc.topicsubtitle>
                    NAT "Notification Channels" work like "boxes". You need to understand this concept before you start scheduling notifications with NAT. The moment you schedule a notification, you must choose a Channel for that
                    notification, then the notification you've scheduled will be placed in that Channel (or "box") until it is delivered to the user. The moment the notification is delivered, the Channel it was on is released. There are a
                    total of 20 Channels in the NAT, which means you can schedule up to 20 notifications to be delivered.
                    <br>
                    <br>
                    This concept is also important because once a notification is within a Channel, pending delivery, you will still have control over that notification, as you will be able to check if there is any pending notification
                    within the Channel, overwrite the notification that is within a Channel or simply cancel it, releasing that Channel.

                    <doc.topicsubtitle>Scheduling a Notification</doc.topicsubtitle>
                    To schedule a notification you must use the code below. In the example below, a notification will be scheduled to be delivered 3 minutes in the future on Channel 10.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- new NAT.Notifications.ScheduledNotification(channel, title, message)
    new NAT.Notifications.ScheduledNotification(NAT.Notifications.Channel.Ch_10, "Notification Title", "Message")
        .setDaysInFuture(0)
        .setHoursInFuture(0)
        .setMinutesInFuture(3)
        .ScheduleThisNotification();
}
                    </code></doc.code>
                    To create a Repetitive Notification, add the <doc.detach>setAsRepetitiveNotification()</doc.detach> method to the notification construction, as in the example below. In the example below, in addition to the notification
                    being delivered in 3 minutes, it will also be repeated every 3 minutes.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- new NAT.Notifications.ScheduledNotification(channel, title, message)
    new NAT.Notifications.ScheduledNotification(NAT.Notifications.Channel.Ch_10, "Notification Title", "Message")
        .setMinutesInFuture(3)
        .setAsRepetitiveNotification(NAT.Notifications.IntervalType.Minutes, 3)
        .ScheduleThisNotification();
}
                    </code></doc.code>

                    <doc.topicsubtitle>Check if a Channel has a pending Notification to be delivered</doc.topicsubtitle>
                    To check if a Channel has a pending notification to be delivered, use the code below.
                    <br>
                    <br>
                    Note that even after the Android system delivered a notification that was scheduled on a Channel, it can take a few minutes for the Android system to report that that Channel is already free, due to caches and other
                    things in the system. Therefore, if a particular Channel is not free, you can use another.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isNotificationScheduledInChannel(channel);
    NAT.Notifications.ScheduledInfo channelInfo = NAT.Notifications.isNotificationScheduledInChannel(NAT.Notifications.Channel.Ch_10);
    bool havePendentNotification = channelInfo.isScheduledInThisChannel;
    bool haveRepetitiveNotification = channelInfo.isRepetitiveNotification;
}
                    </code></doc.code>

                    <doc.topicsubtitle>Canceling a pending Notification</doc.topicsubtitle>
                    To cancel a notification that is scheduled but not yet delivered, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- CancelScheduledNotification(channel);
    NAT.Notifications.CancelScheduledNotification(NAT.Notifications.Channel.Ch_10);
}
                    </code></doc.code>

                    <doc.topicsubtitle>How to know which Channels do not have scheduled pending Notifications?</doc.topicsubtitle>
                    To get a list of all channels that don't have a notification scheduled on them, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- GetListOfFreeNotificationsChannels();
    int[] freeChannels = NAT.Notifications.GetListOfFreeNotificationsChannels();
}
                    </code></doc.code>

                    <doc.topicsubtitle>Tools for Operation with Channels</doc.topicsubtitle>
                    To do logical operations with the channels (how to convert the channel to int and int to channel), NAT provides some methods, see the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- ChToInt(channel);
    int intChannel = NAT.Notifications.ChannelUtils.ChToInt(NAT.Notifications.Channel.Ch_10);
    //- IntToCh(channelInt);
    NAT.Notifications.Channel channel = NAT.Notifications.ChannelUtils.IntToCh(10);
}
                    </code></doc.code>

                    <doc.topicsubtitle>How to add buttons to your Notifications</doc.topicsubtitle>
                    <doc.frame contentside="right" contentheight="350px">
                        Native Android Toolkit Scheduled Notifications may have buttons set by your application. These buttons are fully functional and even your application is able to detect any user interaction with these buttons. But
                        first you need to understand the concept of <doc.detach>Notifications Actions</doc.detach>.
                        <br>
                        <br>
                        Each button you add to your notification must be linked to a <doc.detach>Notifications Action</doc.detach>. A <doc.detach>Notifications Action</doc.detach> acts as a linked ID to that button. Thus, when a button is
                        pressed by the user, your application is opened and NAT informs for your application, the <doc.detach>Notifications Action</doc.detach> corresponding to the pressed button. This way, your application knows which
                        button was pressed by the user. You can create how many <doc.detach>Notifications Action</doc.detach> desire through NAT Preferences.
                        <doc.flextext></doc.flextext>
                        <doc.frameci src="DocumentationFiles/images/24"></doc.frameci>
                    </doc.frame>
                    To add a button to your Scheduled Notification, you can use <doc.detach>setOnClickAction()</doc.detach>, <doc.detach>addButton1()</doc.detach> or <doc.detach>addButton2()</doc.detach> methods. You must provide a
                    <doc.detach>Notification Action</doc.detach> for each button you add. See the example code below...
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- new NAT.Notifications.ScheduledNotification(channel, title, message)
    new NAT.Notifications.ScheduledNotification(NAT.Notifications.Channel.Ch_10, "Notification Title", "Message")
        .setMinutesInFuture(3)
        .setOnClickAction(NotificationsActions.Action.ClickAction1)
        .addButton1("Button 1", NotificationsActions.Action.ButtonAction1)
        .addButton2("Button 2", NotificationsActions.Action.ButtonAction2)
        .ScheduleThisNotification();
}
                    </code></doc.code>
                    For your app to know when a Notification button is pressed, you must register a Callback to the event <b>BEFORE</b> initializing Native Android Toolkit. If your application is opening normally, then the code inside the
                    event will never be executed, however, if your application is opening because the user pressed a Notification button, then the code registered in the event will be executed. See the code below.
                    <br>
                    <br>
                    As the user clicks a button on your Notification, your application will open and as soon as NAT is initialized, the Callback you registered will be performed, stating the <doc.detach>Notification Action</doc.detach>
                    corresponding to the button that the user clicked. Thus your application can run a logic according to the pressed button and context.
                    <br>
                    <br>
                    Keep in mind that if the user clicks a notification button while your application is already open, it will make their application restart, as if re-opened. So be sure to cancel any Scheduled Notification that has
                    buttons, and only schedule them again at the time the application is closed or paused, using Unity <doc.detach>OnApplicationQuit()</doc.detach> and <doc.detach>OnApplicationPause()</doc.detach> for example.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- onOpenApplicationByNotificationIteraction_PostInitialize(action)
    NATEvents.onOpenApplicationByNotificationIteraction_PostInitialize += (NotificationsActions.Action action) =>
    {
        Debug.Log("The user was pressed the Button linked to " + action + " action.");
    };
}
                    </code></doc.code>

                    <doc.topicsubtitle>Important tips on Scheduling Notifications</doc.topicsubtitle>
                    There are some important tips that are worth highlighting when working with Scheduled Notifications. See below.
                    <doc.list>
                        <doc.listr>It is important that your application has any kind of Notification manager if possible. The Android system forgets any Scheduled Notification when the device is restarted or when your application is killed by a process manager. A good rule (as example) for this is to store all the notifications that your application wants to deliver, in a type of "database" of your application. When your application is opened or resumed, cancel all notifications. When your application is paused or closed, schedule all notifications again that exists in the "database". You can use <doc.detach>OnApplicationPause()</doc.detach> and <doc.detach>OnApplicationQuit()</doc.detach> methods of unity as a detection method for closing, loss of focus, pause and so on. This way, your application will always keep the notifications alive as the user opens or closes your application. So even if the user restarts the device for example, when he opens his application, notifications will be revived to be delivered in the future period. This architecture will also not allow scheduled notifications to be delivered while the user has your application open.</doc.listr>
                        <doc.listr>Avoid scheduling notifications in very close periods, especially repetitive notifications. When your application schedules many notifications to be delivered at short time intervals, the system can understand it as an abuse and apply restrictions on the delivery of notifications of your application, but not only that. There may be an increase in battery consumption on the device if the <doc.detach>Enable Accuracy Notify</doc.detach> option is activated in NAT Preferences. Good interval periods for notifications are between 15 minutes, 30 minutes, 1 hour or more. For repetitive notifications, whenever possible for your application, try to establish a minimum interval of 1 hour.</doc.listr>
                        <doc.listr>Although NAT does its best to ensure delivery of scheduled notifications, there is no guarantee that the notifications you have scheduled will be delivered. Therefore, it never makes your application completely depend on any notification because the task may not be performed on some devices, for some reasons such as, very aggressive battery optimizers (such as Samsung, Hwauei etc), restarting the phone, killing the process of its application, block of notifications by the user and etc. Good examples of notifications are: warn new updates, enter new messages, enter news and any othernormal notifications.</doc.listr>
                    </doc.list>

                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Schedule Exact Alarms=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Notifications: Limitation of Notifications -->
                <doc.topic topicid="59">
                    <doc.topictitle>Notifications: Limitation of Notifications</doc.topictitle>

                    Currently the only limitation of Scheduled Notifications is due to abusive power limitations, imposed by some brands of Android cell phones. These abusive limitations end up killing the application background executions
                    and etc, which may delay or prevent the delivery of Scheduled Notifications of many applications. You can see more about it by clicking <a href="#44">here</a>.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: About This Class -->
                <doc.topic topicid="61">
                    <doc.topictitle>Tasks: About This Class</doc.topictitle>

                    The Native Android Toolkit Tasks class allows your app to run code in the background on the device your app is installed on. This class allows your application to manage Background Tasks in an easy and intuitive way.
                    Keep reading to learn more.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: What are Tasks and how do they work? -->
                <doc.topic topicid="62">
                    <doc.topictitle>Tasks: What are Tasks and how do they work?</doc.topictitle>

                    Tasks are nothing more than codes that run in the background on the device of the user who installed your application. Your application has full control of the Tasks, that way, your application can run them whenever it
                    prefers, and even the Tasks code runs independently of your application. Tasks run at times defined by your application, don't need your application to be open, and can communicate with your application in a few ways.
                    <br>
                    <br>
                    To use Tasks in your application, you must complete the following steps...
                    <doc.list isnumeric="true">
                        <doc.listr><b>Code your Task:</b> First you need to code your task, that is, program what you want your task to do. There are endless things that the NAT Task system can do, you can even perform logical operations that aren't super complex. This programming is done through the Unity Editor, through a simple user interface that works as a "mini IDE".</doc.listr>
                        <doc.listr><b>Schedule your Task:</b> Once you have the Task ready, in Runtime, in your application's C# code you will need to enable the task. For this, you use the NAT C# API, so when you enable the task you can provide additional information for it (such as values for variables) and schedule a time for the task to run. It will run even if your application is closed at that time.</doc.listr>
                        <doc.listr><b>Test:</b> Once you've completed the steps above, now you just have to wait for your Task to run to test it.</doc.listr>
                    </doc.list>
                    The next topics will teach you everything you need to know to use the Native Android Toolkit Tasks!

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: How to code Tasks -->
                <doc.topic topicid="63">
                    <doc.topictitle>Tasks: How to code Tasks</doc.topictitle>

                    In this topic we will start by addressing the main subjects. Let's understand how to code a Task through NAT user interface, in Unity Editor, using "NAT Task Creator". Let's understand how the "Task Creator" works, all
                    its functions and finally we'll code a task. Further ahead, in the next topics we will learn how to activate the task and schedule it to run on the Android device.
                    <doc.warn>
                        To code a Task, it is highly important that you have at least a basic understanding of programming logic, as the Tasks code system is based on this logic.
                    </doc.warn>

                    <doc.topicsubtitle>NAT Task Creator</doc.topicsubtitle>
                    Task Creator works like a "mini IDE". It is through it that you will be able to develop and edit the code of your Task. To open it, you need to access the NAT Preferences, then the "Tasks" category. Then, click on the
                    <doc.detach>Create</doc.detach> button in the "Task Source Code" section. This will bring up the Task Creator interface.
                    <doc.image src="DocumentationFiles/images/25"></doc.image>
                    As your Task's source code is empty, it is necessary to initialize it. To do so, click on the <doc.detach>Create Base Source Code</doc.detach> button.
                    <doc.image src="DocumentationFiles/images/26"></doc.image>
                    And then finally you will see the Task Creator interface. See below.
                    <doc.image src="DocumentationFiles/images/27"></doc.image>
                    Now let's dig deeper.

                    <doc.topicsubtitle>Methods</doc.topicsubtitle>
                    Methods in Task Creator work similarly to Methods in C#. Within the methods you can insert components, which in turn will be executed during the execution of the Task on the target device. You can run other methods
                    whenever you want, use conditions that run methods if the condition is met, and so on. In Task Creator, methods are represented in the graphical interface as follows...
                    <doc.image src="DocumentationFiles/images/28">
                        In the image we see the "main" method!
                    </doc.image>
                    You can click the <doc.detach>Add New Method</doc.detach> button to create new methods in your Task.

                    <doc.topicsubtitle>Components</doc.topicsubtitle>
                    Think of Components as you using C# API calls from some library. Components are inserted inside Methods, there can be more than 1 Component of the same type without problems. All Components do different functions, for
                    example, the <doc.detach>SendNotification</doc.detach> Component sends a notification to the user, while the <doc.detach>LoadJsonFromWeb</doc.detach> Component is able to access an API on a remote server, sending
                    Cookies, POST/GET and capturing the JSON response and making it accessible for your Task. By joining Methods and Components we are able to create cool Tasks that can do infinite things.
                    <br>
                    <br>
                    To add a new Component to a method of your Task, click on the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button corresponding to the desired method. Then, choose a Component from the menu. The new Component
                    is always added at the end of the method in question. Components are displayed as follows within methods...
                    <doc.image src="DocumentationFiles/images/30">
                        Within the "main" method we have the "SendNotification" and "CreateFile" components.
                    </doc.image>
                    Each component will have an <doc.icon src="DocumentationFiles/images/31"></doc.icon> button. By clicking on this button, you will have options to manage that component, such as copying it to another method, moving it up
                    or down, removing it and so on.
                    <br>
                    <br>
                    <b>Understanding the mechanics of Component variables</b>
                    <br>
                    <br>
                    As said earlier, Components are like you're making calls to a C# API of some library. As you may know, when making a call to an API, you need to provide parameters, which in this case are values for variables so that
                    the API can work on top of that and do what it was designated. Using the <doc.detach>SendNotification</doc.detach> Component as an example, it does the job of sending a Push Notification to the user. And for it to work,
                    we need to provide values for the variables <doc.detach>Title</doc.detach> (the title of Notification), <doc.detach>Message</doc.detach> (the message of Notification) and <doc.detach>Click Action</doc.detach> (the
                    Notification Action that will be apply for the Notification).
                    <doc.image src="DocumentationFiles/images/32"></doc.image>
                    In the example image above, if you try to run a task coded in exactly this way, when it runs you will get a notification with title <b>"Notification Title"</b> and message <b>"This is a Notification :)"</b>. This works
                    because you provided the necessary values for this Component to work, and so the Component used the values you provided, doing the job by sending a Notification with the parameters you defined.
                    <br>
                    <br>
                    But wait a minute... What are those Buttons on side of each Component parameter?
                    <doc.image src="DocumentationFiles/images/33"></doc.image>
                    As said before, each Component has parameters that must be filled in for it to work. But there is an addendum here! There are several ways to fill Component parameters! By clicking on the button on sid of each
                    parameter you can choose how you want to provide the value for that parameter. See below all the options to provide values for parameters in NAT Tasks...
                    <doc.list>
                        <doc.listr>editorValue</doc.listr>
                        <doc.listr>runtimeValue</doc.listr>
                        <doc.listr>fileValue</doc.listr>
                        <doc.listr>constantValue</doc.listr>
                        <doc.listr>randomValue</doc.listr>
                    </doc.list>
                    Let's dive into each of these methods...
                    <br>
                    <br>
                    <b>editorValue</b>
                    <br>
                    <br>
                    <doc.image src="DocumentationFiles/images/34"></doc.image>
                    With <doc.detach>editorValue</doc.detach> you are able to provide the value for that parameter, using the Task Creator interface, as in the Unity Inspector. As you can see in the image above. There are no mysteries!
                    <doc.info>
                        The <doc.detach>Â§</doc.detach>, <doc.detach>|</doc.detach>, and <doc.detach>^</doc.detach> characters are not available for use within parameters, as they are characters reserved for the internal syntax of Tasks.
                    </doc.info>
                    <br>
                    <br>
                    <b>runtimeValue</b>
                    <br>
                    <br>
                    <doc.image src="DocumentationFiles/images/35"></doc.image>
                    With <doc.detach>runtimeValue</doc.detach> you, instead of defining a value for that parameter, you are able to associate an ID (Key) to that parameter. That way, when your application schedule the task to run, using the
                    NAT C# API, you'll be able to provide a value for all parameters using that associated ID, in the Task.
                    <doc.image src="DocumentationFiles/images/36"></doc.image>
                    This is how your application can provide different values in runtime, whenever it schedules its Tasks!
                    <doc.warn>
                        It is important that you respect the value type when providing values for <doc.detach>runtimeValues</doc.detach>. If a Component parameter expects a <b>STRING</b> type value, you must use the
                        <doc.detach>setRuntimeValue()</doc.detach> method to provide a <b>STRING</b> type value, if the Component parameter expects an <b>INT</b> type value, you must use the <doc.detach>setRuntimeValue()</doc.detach> method
                        to provide a value of type <b>INT</b>, and so on. Providing a value of the wrong type for the parameter will cause your Task to fail or crash.
                    </doc.warn>
                    <br>
                    <br>
                    <b>fileValue</b>
                    <br>
                    <br>
                    <doc.image src="DocumentationFiles/images/37"></doc.image>
                    With <doc.detach>fileValue</doc.detach> the parameter will be filled in by the contents of a text file! When using <doc.detach>fileValue</doc.detach>, the parameter of that Component will look for the text file that you
                    inform, and will use the text content of that file as a value for it. Keep reading to understand.
                    <br>
                    <br>
                    First you need to keep in mind that Tasks are only able to <b>READ</b> and <b>CREATE</b> files in the <doc.detach>AppFiles/NAT/Tasks</doc.detach> scope! Translating this to an absolute path for android devices will be
                    <b>"/storage/emulated/0/Android/data/&lt;app.package.name&gt;/files/NAT/Tasks"</b> (the <b>"/storage/emulated/0/Android/data/&lt;app.package.name&gt;/files"</b> path is equivalent to the <doc.detach>AppFiles</doc.detach>
                    scope of NAT's Files API). You are also able to use NAT C# Files API to create and read files in the <doc.detach>AppFiles/NAT/Tasks</doc.detach> scope without any problems!
                    <br>
                    <br>
                    Keeping the above information in mind, let's say we have the following <doc.detach>sendNotification</doc.detach> component configured as follows...
                    <doc.image src="DocumentationFiles/images/38"></doc.image>
                    And inside the directory <b>"/storage/emulated/0/Android/data/&lt;app.package.name&gt;/files/NAT/Tasks"</b> (<doc.detach>AppFiles/NAT/Tasks</doc.detach>) of the device, we have the following files...
                    <doc.image src="DocumentationFiles/images/39"></doc.image>
                    As we inform the <doc.detach>Title</doc.detach> parameter that we want to use the file <b>"/storage/emulated/0/Android/data/&lt;app.package.name&gt;/files/NAT/Tasks/title.txt"</b> as a value, and we inform the
                    <doc.detach>Message</doc.detach> parameter that we want to use the file <b>"/storage/emulated/0/Android/data/&lt;app.package.name&gt;/files/NAT/Tasks/message.txt"</b> as a value, when our Task is executed, and the
                    <doc.detach>sendNotification</doc.detach> component is executed, we will see a notification like this...
                    <doc.image src="DocumentationFiles/images/40"></doc.image>
                    It's very easy to understand! Ultimately, files act as variables, where the file name works as the variable name and the file contents work as the variable value. This has the benefit of allowing your application to also
                    access files read and created by Tasks.
                    <br>
                    <br>
                    There is one very important thing to note here. The files must have content compatible with the Component's parameter type. For example, if a parameter of a Component requires a value of type <b>INT</b>, then the file
                    must contain a number of type <b>INT</b>! See the table below for a better example...
                    <doc.table>
                        <doc.tablecw>50%=>50%</doc.tablecw>
                        <doc.tablec>Type Required By The Paramater=>Example of Valid Values For The File (disregard the commas and quote marks!)</doc.tablec>
                        <doc.tabler>STRING=>"text", "word", "words", "1", "1.0", "true"</doc.tabler>
                        <doc.tabler>INT=>"100", "-100"</doc.tabler>
                        <doc.tabler>BOOLEAN=>"true", "false"</doc.tabler>
                        <doc.tabler>FLOAT=>"100", "-100", "100.5", "-100.5"</doc.tabler>
                    </doc.table>
                    If a parameter requires a value of type <b>INT</b>, but you supply a file that has a content of type <b>STRING</b> for example, you will have failures or crashs in the execution of your Task. Therefore, it is important
                    to respect this typing!
                    <doc.info>
                        If you supply a file with FLOAT content to a parameter of type INT, the parameter will read the file converting the FLOAT value to INT!
                    </doc.info>
                    <br>
                    There are components that will read files given in <doc.detach>fileValue</doc.detach> and there are Components that will create files given in <doc.detach>fileValue</doc.detach>. Everything will depend on each Component
                    and parameter. You can learn more about all Task Components in the next topics. In the end, as said before, the files work as variables, which allows your application to create files that can be read by Tasks, allows
                    your Task to create and read files and also this is the main way in which Components can communicate with other Components, because through the <doc.detach>fileValue</doc.detach> a Component is able to read a file that
                    had its content edited or created by another Component and more!
                    <br>
                    <br>
                    When a task is finished its execution, all files created by it, or read by it, will continue to exist there. No files are deleted unless you use some component that has the function of deleting some file. Files that are
                    after performing the task may be read by other Tasks executions or your application without problems. If you want no files to be kept at the end of Tasks execution, as if there was never an execution, you can use the
                    <doc.detach>clearTasksDirectory</doc.detach>.
                    <br>
                    <br>
                    <b>constantValue</b>
                    <br>
                    <br>
                    <doc.image src="DocumentationFiles/images/41"></doc.image>
                    With <doc.detach>constantValue</doc.detach> will be filled by a value of only reading, or a constant. When using <doc.detach>constantValue</doc.detach> you should choose which value of only reading or constant you want,
                    so the value of only reading or constant you have chosen, will be used as a value for the given parameter.
                    <br>
                    <br>
                    It is very simple to understand. Let's say you want to know what the current system time, in Millis, and wants to use this value as the parameter value. Just use <doc.detach>constantValue</doc.detach> and then choose the
                    value <doc.detach>currentDateTimeMillis</doc.detach>. See below, a table that contains all existing values available for <doc.detach>constantValue</doc.detach>.
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Value=>Type=>Description=>Example of Value (ignore the quotes)</doc.tablec>
                        <doc.tabler>appVersion=>STRING=>Returns the current version of your application=>"1.0.0"</doc.tabler>
                        <doc.tabler>currentDateTimeMillis=>STRING=>Returns the current time of the system in Millis=>"1669486282281"</doc.tabler>
                        <doc.tabler>appPackageName=>STRING=>Returns the package name of your application=>"com.domain.example"</doc.tabler>
                        <doc.tabler>downloadFileSuccessCode=>STRING=>Returns the success code of downloading a file using the <doc.detach>DownloadFilefromWeb</doc.detach> component=>"200"</doc.tabler>
                        <doc.tabler>loadJsonSuccessCode=>STRING=>Returns the success code of loading a JSON using the <doc.detach>LoadJsonFromWeb</doc.detach> component=>"200"</doc.tabler>
                        <doc.tabler>currentMediaVolume=>FLOAT=>Returns the current media volume of the device=>0.5</doc.tabler>
                        <doc.tabler>currentBrightness=>FLOAT=>Returns the current brightness of the device=>0.7</doc.tabler>
                        <doc.tabler>currentBrightness=>FLOAT=>Returns the current brightness of the device=>0.7</doc.tabler>
                        <doc.tabler>bundleVersionCode=>INT=>Returns the current version code of your application=>17</doc.tabler>
                        <doc.tabler>deviceApiVersion=>INT=>Returns the current version of the Android API of the device=>31</doc.tabler>
                        <doc.tabler>downloadFileSuccessCode=>INT=>Returns the success code of downloading a file using the <doc.detach>DownloadFilefromWeb</doc.detach> component=>200</doc.tabler>
                        <doc.tabler>loadJsonSuccessCode=>INT=>Returns the success code of loading a JSON using the <doc.detach>LoadJsonFromWeb</doc.detach> component=>200</doc.tabler>
                        <doc.tabler>elapsedHoursSinceLastTaskRun=>INT=>Return the elapsed HOURS since the last execution of a NAT Task of your application=>1</doc.tabler>
                        <doc.tabler>elapsedMinutesSinceLastTaskRun=>INT=>Return the elapsed MINUTES since the last execution of a NAT Task of your application=>30</doc.tabler>
                        <doc.tabler>elapsedDaysSinceLastTaskRun=>INT=>Return the elapsed DAYS since the last execution of a NAT Task of your application=>0</doc.tabler>
                        <doc.tabler>isDeveloperModeEnabled=>BOOL=>Returns if the developer mode is enabled on the device=>false</doc.tabler>
                        <doc.tabler>isDeviceRooted=>BOOL=>Returns if the device is rooted=>false</doc.tabler>
                    </doc.table>
                    <br>
                    <br>
                    <b>randomValue</b>
                    <br>
                    <br>
                    <doc.image src="DocumentationFiles/images/42"></doc.image>
                    With <doc.detach>randomValue</doc.detach>, the parameter will receive a random value between <doc.detach>min</doc.detach> and <doc.detach>max</doc.detach>, where the limits are set by you! That's all, but
                    <doc.detach>randomValue</doc.detach> will only appear for parameters that use <b>INT</b> or <b>FLOAT</b> data.

                    <doc.topicsubtitle>Minimap</doc.topicsubtitle>
                    The Minimap is very simple to understand. It will show all the existing Methods and Components on your Task, and will highlight in blue, the current Methods being seen on your screen at the moment. This helps you
                    to know where you are in your Task code.
                    <doc.image src="DocumentationFiles/images/43"></doc.image>

                    <doc.topicsubtitle>Runtime Keys Display</doc.topicsubtitle>
                    The Runtime Keys display will display all the <doc.detach>Runtime Values</doc.detach> on your Task. So, for example, if you have a component where you defined a <doc.detach>Runtime Value</doc.detach>, as follows...
                    <doc.image src="DocumentationFiles/images/44"></doc.image>
                    You will see the Display as follows...
                    <doc.image src="DocumentationFiles/images/45"></doc.image>
                    For each Runtime Key, you will see the following information...
                    <doc.list>
                        <doc.listr>You will see <doc.icon src="DocumentationFiles/images/46"></doc.icon> or <doc.icon src="DocumentationFiles/images/47"></doc.icon> where <doc.icon src="DocumentationFiles/images/47"></doc.icon> indicates that this Runtime Key is being used by some method <doc.detach>setRuntimeValue()</doc.detach> in your C# code and <doc.icon src="DocumentationFiles/images/46"></doc.icon> code indicates that Runtime Key is not being used anywhere in your C# code.</doc.listr>
                        <doc.listr>Then you will see the type of parameter this Runtime Key is being used, where the type is represented between <doc.icon src="DocumentationFiles/images/48"></doc.icon> (float), <doc.icon src="DocumentationFiles/images/49"></doc.icon> (int), <doc.icon src="DocumentationFiles/images/50"></doc.icon> (string) or <doc.icon src="DocumentationFiles/images/51"></doc.icon> (bool).</doc.listr>
                        <doc.listr>Then you will see the ID of that Runtime Key.</doc.listr>
                        <doc.listr>And lastly you will see an count that will show how many times that Runtime Key appears on your Task code for the same type of parameter.</doc.listr>
                    </doc.list>

                    <doc.topicsubtitle>File Values Display</doc.topicsubtitle>
                    The File Values display will display all references to files using existing <doc.detach>File Values</doc.detach> on your task. So if you have a component where you set a <doc.detach>File Value</doc.detach> as below...
                    <doc.image src="DocumentationFiles/images/52"></doc.image>
                    You will see the Display as follows...
                    <doc.image src="DocumentationFiles/images/53"></doc.image>
                    For each file referenced with File Values on your Task, you will see an item on the display, as the following way...
                    <doc.image src="DocumentationFiles/images/54"></doc.image>
                    <doc.frame contentside="right" contentheight="350px">
                        Here we can see the referenced file. We can see the name of the referenced file, and on side of it, a count of times the file was referenced on your Task.
                        <doc.flextext></doc.flextext>
                        <doc.frameci src="DocumentationFiles/images/55"></doc.frameci>
                    </doc.frame>
                    <doc.frame contentside="right" contentheight="350px">
                        Below, nestled with the referenced file, we have a mini list that shows all referencing occurrences to this file. In each item of this mini list, we can see each component that is referencing to this file, as well as
                        which method each component is at. Thus we have the location of each component that is referencing this file.
                        <doc.flextext></doc.flextext>
                        <doc.frameci src="DocumentationFiles/images/56"></doc.frameci>
                    </doc.frame>

                    <doc.topicsubtitle>Creating a small demo Task</doc.topicsubtitle>
                    Now, to exercise, let's create a Task that will send a notification warning that the Task has started. So this task will pause for 5 seconds and then re-schedule for execution again, to 3 hours from now. To create such
                    Task, we will just need to use the <doc.detach>SendNotification</doc.detach>, <doc.detach>WaitForSeconds</doc.detach> and <doc.detach>RescheduleThisTask</doc.detach> components, see below...
                    <doc.image src="DocumentationFiles/images/57"></doc.image>
                    <br>
                    <br>
                    <b>Understanding the Execution Order</b>
                    <br>
                    <br>
                    The thought to understand the execution of NAT Tasks is as follows... The <doc.detach>main</doc.detach> Method is always the first to perform. It acts as Unity <doc.detach>Start()</doc.detach> method. It will be executed
                    automatically at the beginning of Task. When a Method is executed, all components inside the Method will be executed, but one at a time and in the order from top to bottom.
                    <br>
                    <br>
                    Other Methods other than <doc.detach>main</doc.detach> are not executed automatically. Other methods will only be executed if any component within the <doc.detach>main</doc.detach> Method call for any of these other
                    Methods. If this happens, the execution of the <doc.detach>main</doc.detach> Method is paused in the Component that called the other Method, until the execution of the other Method is completed, so the execution of the
                    <doc.detach>main</doc.detach> Method is continued.
                    <br>
                    <br>
                    <b>Conclusion</b>
                    <br>
                    <br>
                    So, in this task we create for example, the components will be performed as follows...
                    <br>
                    <doc.detach>sendNotification</doc.detach> &gt;&gt; <doc.detach>waitForSeconds</doc.detach> &gt;&gt; <doc.detach>rescheduleThisTask</doc.detach>
                    <br>
                    See the image below to understand better...
                    <doc.image src="DocumentationFiles/images/58"></doc.image>

                    <doc.topicsubtitle>How to capture Crashs or Failures during the execution of my Task?</doc.topicsubtitle>
                    If your Task gives any error, warning or crash during execution, caused by some NAT bug, error on your part or anything like this, you can see the error logs through Unity <b>Android Logcat</b> while the task is
                    executed, or through the <doc.detach>last-crash.txt</doc.detach> file that NAT will save in directory of Tasks <b>"/storage/emulated/0/Android/data/&lt;app.package.name&gt;/files/NAT/Tasks"</b>
                    (<doc.detach>AppFiles/NAT/Tasks </doc.detach>). The <doc.detach>last-crash.txt</doc.detach> file contains all error information and can help solve multiple problems. The <doc.detach>last-crash.txt</doc.detach> file will
                    only be created if there is any warning that is worth mentioning, or if there is any errors or crash while running your task.
                    <doc.info>
                        The <doc.detach>last-crash.txt</doc.detach> file will only be created if the <doc.detach>Log Task Crash To File</doc.detach> option is enabled in Native Android Toolkit Preferences!
                    </doc.info>
                    <doc.warn>
                        If you are not debugging your task, or if it is working well, keep the <doc.detach>Log Task Crash To File</doc.detach> option disabled. This will prevent logs or sensitive information from your application may appear
                        in the file to the end users of your application. It is just a security measure.
                    </doc.warn>

                    <doc.topicsubtitle>Saving The Code</doc.topicsubtitle>
                    Now that you have finished editing your task code, just click the <doc.detach>Save Task Code</doc.detach> button! In this way, the code will be saved by NAT. So just close the <doc.detach>Task Creator</doc.detach> window
                    and then click <doc.detach>Save Preferences</doc.detach> in the NAT Preferences window so that your edited Task and all other information will be available for your application and C# code.
                    <doc.info>
                        You have already learned how to program your Task code! Now keep reading to learn more about each component of NAT Tasks!
                        <br>
                        <br>
                        After that, you will learn about the Tasks C# API, so you will learn how to schedule your Tasks for execution, manage them and more!
                    </doc.info>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: Section -->
                <doc.topic topicid="64aa">
                    <doc.topictitle>Tasks: Component: Section</doc.topictitle>

                    When this component runs on your Task, it does not do any useful work, in terms of functionality like other components, but serves as a marker for your Task key script locations.
                    <br>
                    <br>
                    The <doc.detach>Section</doc.detach> component is available in the <doc.detach>Demarcators</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in the Method
                    to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/78">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>Section Name=>STRING=>Only editorValue</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    First you must define the desired name for your section, just insert the desired name in the component text box, such as <doc.detach>BlockOfFileDownloading</doc.detach>. Section components have the main utilities to
                    demarcate your script, acting as a visual and cosmetic indicator so you can identify key locations from your script faster. In addition, it also works as a "checkpoint" that can be used by other components to jump to
                    certain points in your script like <doc.detach>goto</doc.detach> of C#. You'll see more about <doc.detach>goto</doc.detach> on NAT's Tasks when you get to the conditions here in the documentation. Thanks to this
                    <doc.detach>goto</doc.detach> mechanics, you have more control and less limits to create your scripts. To use <doc.detach>goto</doc.detach> on NAT Tasks, you should use section components.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: Show Toast -->
                <doc.topic topicid="64">
                    <doc.topictitle>Tasks: Component: Show Toast</doc.topictitle>

                    When this component runs on your Task, it does the job of displaying a Android Toast message on the device screen.
                    <br>
                    <br>
                    The <doc.detach>Show Toast</doc.detach> component is available in the <doc.detach>Functions Simple</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in the Method
                    to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/59">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>Toast Message=>STRING=>Any</doc.tabler>
                        <doc.tabler>Long Duration=>BOOL=>Any</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    To use this component you just need to add it to a method and provide a message in parameter <doc.detach>Toast Message</doc.detach>, which will be displayed as Toast.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: Send Notification -->
                <doc.topic topicid="64a">
                    <doc.topictitle>Tasks: Component: Send Notification</doc.topictitle>

                    When this component runs on your Task, he does the job of sending a Push Notification to the user.
                    <br>
                    <br>
                    The <doc.detach>Send Notification</doc.detach> component is available in the <doc.detach>Functions Simple</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in the
                    Method to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/60">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>Title=>STRING=>Any</doc.tabler>
                        <doc.tabler>Message=>STRING=>Any</doc.tabler>
                        <doc.tabler>Click Action=>ENUM=>Only editorValue</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    To use this component you just need to add it to a method and then provide an <doc.detach>Title</doc.detach> and <doc.detach>Message</doc.detach> for the Notification that will be sent when this component is executed.
                    You can set a <b>Notification Action</b> to parameter <doc.detach>Click Action</doc.detach> if you want your application to be able to detect interactions with the Notification launched by this component, as described
                    <a href="#55">here</a>.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: Create File -->
                <doc.topic topicid="64b">
                    <doc.topictitle>Tasks: Component: Create File</doc.topictitle>

                    When this component runs on your Task, it does the job of creating a file with STRING, INT, FLOAT or BOOLEAN content.
                    <br>
                    <br>
                    The <doc.detach>Create File</doc.detach> component is available in the <doc.detach>Functions Simple</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in the
                    Method to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/61">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>Content Type To Write=>ENUM=>Only editorValue</doc.tabler>
                        <doc.tabler>File Content=>STRING, BOOL, FLOAT or INT=>Any</doc.tabler>
                        <doc.tabler>Save On Path=>STRING=>Only fileValue</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    Add this component to your Task and when it runs it will create a file in the NAT Tasks file directory, in scope <b>"/storage/emulated/0/Android/data/&lt;app.package.name&gt;/files/NAT/Tasks"</b>
                    (<doc.detach>AppFiles/NAT/Tasks</doc.detach>). For the file to be created, you need to choose what type of content will be written to the file in <doc.detach>Content Type To Write</doc.detach> and then provide data for
                    the <doc.detach>File Content</doc.detach> parameter. In the <doc.detach>Save On Path</doc.detach> parameter you will be providing the path for the file to be created, inside the files folder of NAT Tasks, as mentioned
                    earlier. Note that if you provide a path with directories, these directories will be automatically created by NAT if any directory does not exist.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: Delete File -->
                <doc.topic topicid="64c">
                    <doc.topictitle>Tasks: Component: Delete File</doc.topictitle>

                    When this component runs on your Task, it does the job of deleting files or directories present in the Tasks file directory.
                    <br>
                    <br>
                    The <doc.detach>Delete File</doc.detach> component is available in the <doc.detach>Functions Simple</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in the
                    Method to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/62">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>Delete On Path=>STRING=>Only fileValue</doc.tabler>
                        <doc.tabler>Delete Recursively=>BOOL=>Any</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    Add this component to your Task. Once this is done, you will only need to inform the path to the file or folder you want to delete in the <doc.detach>Delete On Path</doc.detach> parameter. Yes, this component can exclude
                    files or folders, but only files or folders that are present in the scope <b>"/storage/emulated/0/Android/data/&lt;app.package.name&gt;/files/NAT/Tasks"</b> (<doc.detach>AppFiles/NAT/Tasks</doc.detach>) directory of the
                    device, which is also the Tasks file area. If the path you entered in <doc.detach>Delete On Path</doc.detach> is a folder, you must check the <doc.detach>Delete Recursively</doc.detach> option. The file or folder will be
                    deleted as soon as this component is executed.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: Reschedule This Task -->
                <doc.topic topicid="64d">
                    <doc.topictitle>Tasks: Component: Reschedule This Task</doc.topictitle>

                    When this component runs on your Task, it will do the job of rescheduling your Task for re-run in the future automatically.
                    <br>
                    <br>
                    The <doc.detach>Reschedule This Task</doc.detach> component is available in the <doc.detach>Functions Simple</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in
                    the Method to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/63">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>Years In Future=>INT=>Any</doc.tabler>
                        <doc.tabler>Months In Future=>INT=>Any</doc.tabler>
                        <doc.tabler>Days In Future=>INT=>Any</doc.tabler>
                        <doc.tabler>Hours In Future=>INT=>Any</doc.tabler>
                        <doc.tabler>Minutes In Future=>INT=>Any</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    This component will make your Task to re-schedule itself to run in the future once more. You just need to tell it at what time in the future you want your Task to run automatically, and you can do that by providing the
                    time for the <doc.detach>Years In Future</doc.detach>, <doc.detach>Months In Future</doc.detach>, <doc.detach>Days In Future</doc.detach>, <doc.detach>Hours In Future</doc.detach> and
                    <doc.detach>Minutes In Future</doc.detach> parameters. This component can be used to create repetitive execution Tasks with time intervals like update checks for example.
                    <br>
                    <br>
                    If you intends create repetitive Tasks using this component, it is advisable that you only put it as the last component on your task (for example, at the end of the <doc.detach>main</doc.detach> method) so that it only
                    reschedule your task when it has been completed. This avoids possible execution conflicts at very short time intervals.
                    <doc.warn>
                        If your Task will do some work of accessing a remote server on the Web, it is interesting that you use random values so that your Task executions are done at random and different times, because if you use a fixed
                        time interval and many phones use your application, you will have access spikes on your server which can cause instability on your server.
                    </doc.warn>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: Play Sound -->
                <doc.topic topicid="64e">
                    <doc.topictitle>Tasks: Component: Play Sound</doc.topictitle>

                    When this component runs on your Task, it will do the job of playing an audio file present in the Tasks file directory.
                    <br>
                    <br>
                    The <doc.detach>Play Sound</doc.detach> component is available in the <doc.detach>Functions Simple</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in
                    the Method to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/64">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>Audio Path=>STRING=>Only fileValue</doc.tabler>
                        <doc.tabler>Volume=>FLOAT=>Any</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    You need to have an audio file that is in the files scope of Tasks in <b>"/storage/emulated/0/Android/data/&lt;app.package.name&gt;/files/NAT/Tasks"</b> (<doc.detach>AppFiles/NAT/Tasks</doc.detach>). Then you just need
                    to
                    enter the path to the audio file in <doc.detach>Audio Path</doc.detach>. As soon as this component is executed in your Task it will start playing the file.
                    <br>
                    <br>
                    This component may not play sound while your application is closed. This happens because some devices impose prohibitions so that background tasks do not play sounds while the application is closed.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: Build And Save String -->
                <doc.topic topicid="64f">
                    <doc.topictitle>Tasks: Component: Build And Save String</doc.topictitle>

                    When this component runs on your Task, it will do the work of joining (concatenating) from 2 to 10 STRINGS. The resulting STRING is saved in a file that can later be read by other Tasks components or by your application.
                    <br>
                    <br>
                    The <doc.detach>Build And Save String</doc.detach> component is available in the <doc.detach>Functions Simple</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in
                    the Method to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/65">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>String 1=>STRING=>Any</doc.tabler>
                        <doc.tabler>String 2=>STRING=>Any</doc.tabler>
                        <doc.tabler>String 3=>STRING=>Any</doc.tabler>
                        <doc.tabler>String 4=>STRING=>Any</doc.tabler>
                        <doc.tabler>String 5=>STRING=>Any</doc.tabler>
                        <doc.tabler>String 6=>STRING=>Any</doc.tabler>
                        <doc.tabler>String 7=>STRING=>Any</doc.tabler>
                        <doc.tabler>String 8=>STRING=>Any</doc.tabler>
                        <doc.tabler>String 9=>STRING=>Any</doc.tabler>
                        <doc.tabler>String 10=>STRING=>Any</doc.tabler>
                        <doc.tabler>Save Final String On=>STRING=>Only fileValue</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    This component will concatenate 2 or more STRINGS. To do so, you must inform the <doc.detach>String 1</doc.detach> and <doc.detach>String 2</doc.detach> parameters, the two STRINGS you want to concatenate. The result
                    of the concatenation will be saved in the file informed in parameter <doc.detach>Save Final String On</doc.detach> in scope
                    <b>"/storage/emulated/0/Android/data/&lt;app.package.name&gt;/files/NAT/Tasks"</b> (<doc.detach>AppFiles/NAT/Tasks</doc.detach>).
                    <br>
                    <br>
                    If you need to concatenate more than two STRINGS, click the <doc.detach>Add More One String</doc.detach> button to add the desired amount of fields and then you can concatenate from 2 to 10 STRINGS.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: Vibrate -->
                <doc.topic topicid="64g">
                    <doc.topictitle>Tasks: Component: Vibrate</doc.topictitle>

                    When this component runs on your Task, it will do the job of vibrating the device.
                    <br>
                    <br>
                    The <doc.detach>Vibrate</doc.detach> component is available in the <doc.detach>Functions Simple</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in
                    the Method to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/66">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>Delay=>INT=>Any</doc.tabler>
                        <doc.tabler>Vibration=>INT=>Any</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    This component will vibrate the user's device. For that you need to inform this component the vibration times. It is possible to make 3 vibrations with different durations and different intervals. For this you just need
                    to inform the delay times (interval) in <doc.detach>Delay</doc.detach> and the vibration times in <doc.detach>Vibration</doc.detach>.
                    <br>
                    <br>
                    This component may not vibrate while your application is closed. This happens because some devices impose prohibitions so that background tasks do not vibrate while the application is closed.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: Arithmetic -->
                <doc.topic topicid="64h">
                    <doc.topictitle>Tasks: Component: Arithmetic</doc.topictitle>

                    When this component runs on your Task, it will do the work of performing an arithmetic operation and then saving the result to a file in the Tasks file directory. This file can be consulted by other components or by your
                    application.
                    <br>
                    <br>
                    The <doc.detach>Arithmetic</doc.detach> component is available in the <doc.detach>Functions Simple</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in
                    the Method to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/67">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>Operation=>ENUM=>Only editorValue</doc.tabler>
                        <doc.tabler>Value 1=>FLOAT=>Any</doc.tabler>
                        <doc.tabler>Value 2=>FLOAT=>Any</doc.tabler>
                        <doc.tabler>Save Result On=>STRING=>Only fileValue</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    To perform arithmetic operations, you first need to choose which operation you want to perform, in <doc.detach>Operation</doc.detach>. Next, you need to provide the values for <doc.detach>Value 1</doc.detach> and
                    <doc.detach>Value 2</doc.detach>. The result of the operation will be saved in the file informed in <doc.detach>Save Result On</doc.detach>, in the scope of files of the Tasks in
                    <b>"/storage/emulated/0/Android/data/&lt;app.package.name&gt;/files/NAT/Tasks"</b> (<doc.detach>AppFiles/NAT/Tasks</doc.detach>).

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: Wait For Seconds -->
                <doc.topic topicid="64i">
                    <doc.topictitle>Tasks: Component: Wait For Seconds</doc.topictitle>

                    When this component runs on your Task, it will do the job of pausing your Task's execution for a defined time.
                    <br>
                    <br>
                    The <doc.detach>Wait For Seconds</doc.detach> component is available in the <doc.detach>Functions Simple</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in
                    the Method to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/68">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>Milliseconds To Wait=>INT=>Any</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    To use this component, you just need to inform in the <doc.detach>Milliseconds To Wait</doc.detach> parameter, how many Milliseconds you want your Task to wait before continuing running.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: Load Json From Web -->
                <doc.topic topicid="64j">
                    <doc.topictitle>Tasks: Component: Load Json From Web</doc.topictitle>

                    When this component runs on your Task, it will do the work of querying an API (PHP for example) that is on a remote server and that returns a JSON response. So this component will take all the variables and values that
                    are in the JSON response and save it in the Tasks file scope so that other components and your application have access.
                    <br>
                    <br>
                    The <doc.detach>Load Json From Web</doc.detach> component is available in the <doc.detach>Functions Normal</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in
                    the Method to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/69">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>Json API URL=>STRING=>Any</doc.tabler>
                        <doc.tabler>GET Parameters=>STRING=>Any</doc.tabler>
                        <doc.tabler>POST Parameters=>STRING=>Any</doc.tabler>
                        <doc.tabler>Cookies To Send=>STRING=>Any</doc.tabler>
                        <doc.tabler>Expected Page Header=>STRING=>Any</doc.tabler>
                        <doc.tabler>Save Json Values On=>STRING=>Only fileValue</doc.tabler>
                        <doc.tabler>Save Request Status On=>STRING=>Only fileValue</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    This component will allow your Task to access APIs on remote servers on the Internet. To start, you must inform the URL of the API that the component must access, in <doc.detach>Json API URL</doc.detach>. When the
                    component accesses the API it will save a file using the specified path in <doc.detach>Save Request Status On</doc.detach> which will contain the status code of the request where code <doc.detach>200</doc.detach> means
                    that the request was successful. Next, it will read the JSON code returned by the API, extract all the variables and save them in the folder you specify in the <doc.detach>Save Json Values On</doc.detach> parameter,
                    therefore, in this parameter you must not inform paths for files, but only for folders. Folders that do not exist in the path will be created automatically.
                    <br>
                    <br>
                    But that is not all. When the component accesses the API and receives the response page, the Native Android Toolkit will post process that page to check if it is really an expected page and if it is a page supported by
                    the Native Android Toolkit. Therefore, your API that will be accessed by your Task must return a response page, similar to the example below...
                    <doc.code language="html"><code>
requestSuccess
&lt;br/&gt;
{"variable":"value","variable2":"value2"}
                    </code></doc.code>
                    Where <b>"requestSuccess"</b> is considered by NAT the "Page Header". The <b>"&lt;br/&gt;"</b> is considered by NAT the "Separator Tag" and <b>"{"variable":"value","variable2":"value2"}"</b> is considered the "JSON
                    Response". Right after the component receives the response page from the API, it will split the page into two parts using the "&lt;br/&gt;" tag as a separator. In the first part of page it will check if the string you
                    entered in <doc.detach>Expected Page Header</doc.detach> parameter, exists, if it exists, it means that the page is valid, then it will read the second part of the page extracting the JSON code. If the string informed in
                    <doc.detach>Expected Page Header</doc.detach> does not exist in the first part of the page, the status code <doc.detach>996</doc.detach> will be saved in the Request Status file and the execution of this component will
                    stop there, not even looking for a JSON on the page.
                    <br>
                    <br>
                    Right after extracting the JSON from the API response page, the NAT will check if the JSON is a valid JSON by checking its syntax and etc. If the JSON is invalid, the <doc.detach>998</doc.detach> status code will be
                    saved in the Request Status file and no variables will be saved in the Tasks file scope. If the JSON syntax is valid, this component will save a file for each variable contained in the JSON code, where the file name will
                    be the name of the variable found in the JSON and the file content will be the value of the variable that is in the JSON code. All these files will be saved in the folder informed by you in parameter
                    <doc.detach>Save Json Values On</doc.detach>.
                    <br>
                    <br>
                    Assuming this component got the following response page from your API...
                    <doc.code language="html"><code>
requestSuccess
&lt;br/&gt;
{"car":"honda","model":"civic","year":"2016"}
                    </code></doc.code>
                    You will have the following files being saved in the directory given in <doc.detach>Save Json Values On</doc.detach>...
                    <doc.image src="DocumentationFiles/images/70"></doc.image>
                    Therefore, it is extremely important that before other components of your Task or before your application tries to query values obtained from a JSON API using this component, you must first check if the Request Status
                    file created by this component has the content <doc.detach>200</doc.detach>, which indicates success. If the content is different from <doc.detach>200</doc.detach>, it means that there was a problem accessing the API and
                    therefore the value files were not saved. See below an example code of a PHP API built to be accessed by this component...
                    <doc.image src="DocumentationFiles/images/71"></doc.image>
                    If the Request Status file created by this component contains the number <doc.detach>200</doc.detach>, it means that the API was accessed, the response page is the expected page and the JSON code is valid and had its
                    variables and values saved in the Tasks file scope, which means that you can read these files without any problems as everything was successful.
                    <doc.info>
                        It is important that you keep in mind that when this component is executed, your Task will be paused until the remote request is completed. Only after completing the request will the next components of your Task
                        continue to be executed.
                    </doc.info>
                    <br>
                    <br>
                    <b>Sending POST or GET data</b>
                    <br>
                    <br>
                    To add POST or GET data to the request made by this component, you must add the POST data in the <doc.detach>POST Parameters</doc.detach> parameter of this component and the GET data in the
                    <doc.detach>GET Parameters</doc.detach> parameter of this component. But you must follow the syntax below to pass the POST or GET data.
                    <doc.image src="DocumentationFiles/images/72"></doc.image>
                    For example, to inform to your API that the username is Angelo and the age is 17 years old, you would inform the value <doc.detach>username~AngeloÂ¬age~17</doc.detach> for the parameter
                    <doc.detach>POST Parameters</doc.detach> or <doc.detach>GET Parameters</doc.detach>. The <doc.detach>~</doc.detach> character acts as a separator between parameter name and parameter value, and the
                    <doc.detach>Â¬</doc.detach> character acts as a separator between each parameter of the POST or GET data.
                    <br>
                    <br>
                    You can enter as many parameters as you like, but you must follow the above syntax.
                    <br>
                    <br>
                    <b>Sending Cookies</b>
                    <br>
                    <br>
                    To send Cookies to your API during the request made by this component, you must add these Cookies to the <doc.detach>Cookies To Send</doc.detach> parameter of this component. You must follow the syntax below to pass your
                    Cookies.
                    <doc.image src="DocumentationFiles/images/73"></doc.image>
                    For example, to pass a Login Cookie with name "sessID" and value "34345nkj4olk323n3JN3NJ3232" to your API that is in the domain "example.com", you must provide the
                    <doc.detach>sessID~34345nkj4olk323n3JN3NJ3232~example.com</doc.detach> value for the <doc.detach>Cookies To Send</doc.detach> parameter. The <doc.detach>~</doc.detach> character acts as a separator between Cookie Name,
                    Cookie Value and Cookie Domain, and the <doc.detach>Â¬</doc.detach> character acts as a separator between each Cookie provided to your API.
                    <br>
                    <br>
                    You can enter as many Cookies as you like, but you must follow the above syntax.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: Download File From Web -->
                <doc.topic topicid="64k">
                    <doc.topictitle>Tasks: Component: Download File From Web</doc.topictitle>

                    When this component runs on your Task, will do the work of downloading a file and saving it to the Tasks file scope. Another component or your application will be able to access this file as well.
                    <br>
                    <br>
                    The <doc.detach>Download File From Web</doc.detach> component is available in the <doc.detach>Functions Normal</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in
                    the Method to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/74">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>File URL=>STRING=>Any</doc.tabler>
                        <doc.tabler>Notification Title=>STRING=>Any</doc.tabler>
                        <doc.tabler>Save File On=>STRING=>Only fileValue</doc.tabler>
                        <doc.tabler>Save Status On=>STRING=>Only fileValue</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    This component will download a file and save it to the Tasks file scope on the device. The downloaded file can be read by other components or by your application. To use this component you must inform the
                    <doc.detach>File URL</doc.detach> parameter the URL where the file to be downloaded is. You must also inform where the downloaded file must be saved, for this inform the path to the
                    <doc.detach>Save File On</doc.detach> parameter.
                    <br>
                    <br>
                    This component will also save a Request Status file in the location informed in parameter <doc.detach>Save Status On</doc.detach>. This saved file will contain the status code of the download and if the status code
                    contained in the file is equal to <doc.detach>200</doc.detach> it means that the download was successful and the file was downloaded is located at the specified location. If the status code contained in the file is
                    different from <doc.detach>200</doc.detach>, it means that there was an error in the download and the file was not downloaded. Therefore, before your application or other components of your Task try to access the
                    downloaded file, it is important to check the Request Status file to verify that the download status code is <doc.detach>200</doc.detach>.
                    <doc.info>
                        It is important that you keep in mind that when this component is executed, your Task will be paused until the download is completed. Only after completing the download will the next components of your Task
                        continue to be executed.
                    </doc.info>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: File Exists -->
                <doc.topic topicid="64l">
                    <doc.topictitle>Tasks: Component: File Exists</doc.topictitle>

                    When this component runs on your Task, it will do the work of checking if any files in the Tasks scope exist.
                    <br>
                    <br>
                    The <doc.detach>File Exists</doc.detach> component is available in the <doc.detach>Functions Normal</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in
                    the Method to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/75">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>File To Check=>STRING=>Only fileValue</doc.tabler>
                        <doc.tabler>Save Status On=>STRING=>Only fileValue</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    To use this component, you need to inform the path to the file you want to check if it exists, to the parameter <doc.detach>File To Check</doc.detach>. This component will save a response file in the path specified in
                    <doc.detach>Save Status On</doc.detach> that will contain a boolean value indicating if the file exists or not.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: Get File Size -->
                <doc.topic topicid="64m">
                    <doc.topictitle>Tasks: Component: Get File Size</doc.topictitle>

                    When this component runs on your Task, it will do the job of checking the size of a file present in the Tasks file scope.
                    <br>
                    <br>
                    The <doc.detach>Get File Size</doc.detach> component is available in the <doc.detach>Functions Normal</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in
                    the Method to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/76">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>File To Check=>STRING=>Only fileValue</doc.tabler>
                        <doc.tabler>Save Size As=>ENUM=>Only editorValue</doc.tabler>
                        <doc.tabler>Save Size On=>STRING=>Only fileValue</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    To use this component you must inform which file you want to verify the size in parameter <doc.detach>File To Check</doc.detach>. This component will verify the size of the file and will save a file in the path indicated
                    by the parameter <doc.detach>Save Size On</doc.detach>, which will contain the size of the checked file float formatted.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: Clear Task Directory -->
                <doc.topic topicid="64n">
                    <doc.topictitle>Tasks: Component: Clear Task Directory</doc.topictitle>

                    When this component runs on your Task, it will do the job of cleaning up the entire file scope of Tasks.
                    <br>
                    <br>
                    The <doc.detach>Clear Task Directory</doc.detach> component is available in the <doc.detach>Functions Normal</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in
                    the Method to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/77">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>Save Status On=>STRING=>Only fileValue</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    When this component is run in your Task, it will delete all files and folders present in the Tasks files scope
                    <b>"/storage/emulated/0/Android/data/&lt;app.package.name&gt;/files/NAT/Tasks"</b> (<doc.detach>AppFiles/NAT/Tasks</doc.detach>). It will save a file in the path indicated by the <doc.detach>Save Status On</doc.detach>
                    parameter that will contain a boolean value that indicates whether the cleaning operation was successful.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: If And Else -->
                <doc.topic topicid="64o">
                    <doc.topictitle>Tasks: Component: If And Else</doc.topictitle>

                    When this component runs on your Task, it does the job of adding programming logic to your task. With this component you can create conditions.
                    <br>
                    <br>
                    The <doc.detach>If And Else</doc.detach> component is available in the <doc.detach>Conditions</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in
                    the Method to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/79">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>Conditions=>ENUM=>Only editorValue</doc.tabler>
                        <doc.tabler>Comparation Type=>ENUM=>Only editorValue</doc.tabler>
                        <doc.tabler>Value 1=>STRING/FLOAT/INT/BOOL=>Any</doc.tabler>
                        <doc.tabler>Comparator=>ENUM=>Only editorValue</doc.tabler>
                        <doc.tabler>Value 2=>STRING/FLOAT/INT/BOOL=>Any</doc.tabler>
                        <doc.tabler>Logical Operator=>ENUM=>Only editorValue</doc.tabler>
                        <doc.tabler>If TRUE=>ENUM=>Only editorValue</doc.tabler>
                        <doc.tabler>If FALSE=>ENUM=>Only editorValue</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    This component allows you to define one or more logical conditions and perform different codes depending on the <doc.detach>True</doc.detach> or <doc.detach>False</doc.detach> result of the conditions imposed by you. To
                    start, let's understand how to configure our condition. First we need to choose which type of comparison we are going to do, that is, if we will compare a STRING variable with a STRING, a FLOAT with a FLOAT and so on.
                    For start, you need to choose the type of comparison, so select the type in <doc.detach>Comparation Type</doc.detach>. Now we need to provide the values that will be compared. If you have defined the STRING in
                    <doc.detach>Comparation Type</doc.detach>, then you will see two fields with the name of <doc.detach>STRING 1</doc.detach> and <doc.detach>STRING 2</doc.detach> and so on. You need to provide the values to be compared
                    by the condition in these two fields. That done, you need to select the comparator, ie <doc.detach>equal</doc.detach> or <doc.detach>different</doc.detach> for example. That done, your condition will be ready.
                    <br>
                    <br>
                    For you to understand even more, imagine that we want to compare if the STRING <doc.detach>"car"</doc.detach> is equal to STRING <doc.detach>"model"</doc.detach>. For this, it will be necessary that the condition of this
                    component will be configured as follows...
                    <doc.image src="DocumentationFiles/images/80"></doc.image>
                    Just so that you understand better, with the condition of our component configured in this way, we will have the equivalent of this in C#...
                    <doc.code language="csharp"><code>
if("car" == "model")
{

}
                    </code></doc.code>
                    For one more example, see below another condition configuration made in this component and the equivalent made in C#...
                    <doc.image src="DocumentationFiles/images/81"></doc.image>
                    <br>
                    <br>
                    <b>Defining a code to be executed</b>
                    <br>
                    <br>
                    Now that you have understood the concept of condition in this component and already have a condition made, let's define which code will be executed if the condition is <doc.detach>TRUE</doc.detach> and if the condition
                    is <doc.detach>FALSE</doc.detach>. For this, we just need to set a value for parameters <doc.detach>If TRUE</doc.detach> and <doc.detach>If FALSE</doc.detach>, Where <doc.detach>If TRUE</doc.detach> defines the code that
                    will be executed if the condition thesis <doc.detach>TRUE</doc.detach> and <doc.detach>If FALSE</doc.detach> will be executed if the condition is <doc.detach>FALSE</doc.detach>. Currently you can define one of the types
                    of values listed below for parameters <doc.detach>If TRUE</doc.detach> and <doc.detach>If FALSE</doc.detach>...
                    <doc.list>
                        <doc.listr><b>none</b> - Defining it will make nothing happen. For example, if you define <doc.detach>none</doc.detach> in parameter <doc.detach>If TRUE</doc.detach>, even if the condition gives a result of <doc.detach>True</doc.detach>, nothing will happen. Use this value when you want nothing to happen.</doc.listr>
                        <doc.listr><b>method</b> - Methods will appear in parameter selection boxes on parameters <doc.detach>If TRUE</doc.detach> and <doc.detach>If FALSE</doc.detach> if you have more created methods, in addition to the <doc.detach>main</doc.detach> method that already exists by default. For example, if you have created a method called <doc.detach>DownloadFile</doc.detach>, you will see an option called <doc.detach>call:DownloadFile</doc.detach>. If you select your <doc.detach>call:DownloadFile</doc.detach> method in parameter <doc.detach>If TRUE</doc.detach> and the condition return <doc.detach>True</doc.detach>, then your method <doc.detach>DownloadFile</doc.detach> will be performed.</doc.listr>
                        <doc.listr><b>goto</b> - <doc.detach>Goto</doc.detach> works exactly like <doc.detach>goto</doc.detach> in C#. The component <doc.detach>If And Else</doc.detach> will detect all existing <doc.detach>Section</doc.detach> components in the same method as your <doc.detach>If And Else</doc.detach> component is. For example, if you have a component <doc.detach>Section</doc.detach> in the same method as your <doc.detach>If And Else</doc.detach> component with the name of <doc.detach>StartOfDownloadBlock</doc.detach>, you will see the <doc.detach>goto:StartOfDownloadBlock</doc.detach> option in the selection box of parameters <doc.detach>If TRUE</doc.detach> and <doc.detach>If FALSE</doc.detach>. So if you select option <doc.detach>goto:StartOfDownloadBlock</doc.detach> in parameter <doc.detach>If TRUE</doc.detach> and the condition gives a <doc.detach>True</doc.detach> result, then the Task script execution will jump to the place where the component <doc.detach>Section</doc.detach> with name <doc.detach>StartOfDownloadBlock</doc.detach> is, and will continue to follow the normal order of execution of components, but from that point.</doc.listr>
                        <doc.listr><b>return</b> - Defining this value will cause the method to be interrupted. For example, if you define <doc.detach>return</doc.detach> in parameter <doc.detach>If TRUE</doc.detach> and the condition returns a <doc.detach>True</doc.detach> result, then the method of this component <doc.detach>If And Else</doc.detach> is, will be interrupted even if there are more components to be executed.</doc.listr>
                    </doc.list>
                    See the example below to understand better...
                    <doc.image src="DocumentationFiles/images/82"></doc.image>
                    <doc.info>
                        Note that if the <doc.detach>If And Else</doc.detach> component is not inside method <doc.detach>main</doc.detach>, you will not see any other method being listed in the selection boxes of parameters
                        <doc.detach>If TRUE</doc.detach> and <doc.detach>If FALSE</doc.detach>. This is because in NAT Tasks, you can only call other methods for execution, from the <doc.detach>main</doc.detach> method. Secondary methods
                        (which are created by you) cannot call other methods for execution.
                    </doc.info>
                    <br>
                    <br>
                    <b>Working with more than one condition</b>
                    <br>
                    <br>
                    Sometimes it is necessary to create conditions with multiple comparators and using logical operators like <doc.detach>AND/OR</doc.detach> (&& and ||). With the <doc.detach>If And Else</doc.detach> component you can do
                    this too. It is possible to define up to two conditions by component <doc.detach>If And Else</doc.detach>.
                    <br>
                    <br>
                    To set two conditions, change parameter <doc.detach>Conditions</doc.detach> to <doc.detach>two</doc.detach>. So you only need to choose the logical operator to be used, which can be done by changing parameter
                    <doc.detach>Logical Operator</doc.detach>. The rest you already know. See the image below to have an example.
                    <doc.image src="DocumentationFiles/images/83"></doc.image>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: While -->
                <doc.topic topicid="64p">
                    <doc.topictitle>Tasks: Component: While</doc.topictitle>

                    When this component runs on your Task, it will do the job of repeating a defined method while the condition that you define continues giving TRUE results.
                    <br>
                    <br>
                    The <doc.detach>While</doc.detach> component is available in the <doc.detach>Conditions</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in
                    the Method to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/84">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>Comparation Type=>ENUM=>Only editorValue</doc.tabler>
                        <doc.tabler>Value 1=>STRING/FLOAT/INT/BOOL=>Any</doc.tabler>
                        <doc.tabler>Comparator=>ENUM=>Only editorValue</doc.tabler>
                        <doc.tabler>Value 2=>STRING/FLOAT/INT/BOOL=>Any</doc.tabler>
                        <doc.tabler>While TRUE=>ENUM=>Only editorValue</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    This component allows you to configure a condition and while it is <doc.detach>True</doc.detach>, a method you define will be performed on a loop. To use this component, you need to configure a condition, you can see
                    more about it <a href="#64o">here</a>. Then just define the method you want to execute in <doc.detach>While TRUE</doc.detach> while the condition provides the result of <doc.detach>True</doc.detach>.
                    <br>
                    <br>
                    Note that this component has a maximum limit of possible interactions that is defined by the <doc.detach>Max Loop Iterations</doc.detach> variable in NAT Preferences. So even if the condition provides
                    <doc.detach>True</doc.detach> forever, the loop at some point will be automatically broken, according to the configured interactions limit.
                    <doc.info>
                        As in NAT Tasks, only the <doc.detach>main</doc.detach> method can make calls to other methods, this component is not available in secondary methods (methods that are created by you). This is because for this
                        component to work, it needs to call other methods, as in parameter <doc.detach>While TRUE</doc.detach> it is not possible to use values such as <doc.detach>goto</doc.detach> and <doc.detach>return</doc.detach>.
                    </doc.info>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: Call Method -->
                <doc.topic topicid="64q">
                    <doc.topictitle>Tasks: Component: Call Method</doc.topictitle>

                    When this component runs on your Task, it will do the job of calling another method to execute.
                    <br>
                    <br>
                    The <doc.detach>Call Method</doc.detach> component is available in the <doc.detach>Conditions</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in
                    the Method to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/85">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>Method To Call=>ENUM=>Only editorValue</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    This method acts as a <doc.detach>example();</doc.detach> call made in languages like C#. This method will allow you to call a method to be easily executed. To use it, simply select the method you want to execute in
                    parameter <doc.detach>Method To Call</doc.detach>.
                    <doc.info>
                        As in NAT Tasks, only the <doc.detach>main</doc.detach> method can make calls to other methods, this component is not available in secondary methods (methods that are created by you). This is because for this
                        component to work, it needs to call other methods, as in parameter <doc.detach>Method To Call</doc.detach> it is not possible to use values such as <doc.detach>goto</doc.detach> and <doc.detach>return</doc.detach>.
                    </doc.info>


                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: Go To Section -->
                <doc.topic topicid="64r">
                    <doc.topictitle>Tasks: Component: Go To Section</doc.topictitle>

                    When this component runs on your Task, it will allow the execution of your task script to jump to any point within the method.
                    <br>
                    <br>
                    The <doc.detach>Go To Section</doc.detach> component is available in the <doc.detach>Conditions</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in
                    the Method to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/86">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>Section To Go=>ENUM=>Only editorValue</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    This component acts as the <doc.detach>goto</doc.detach> of C#. Basically it will detect by <doc.detach>Section</doc.detach> components that are in the same method as this component is. Then it will list these components
                    in parameter <doc.detach>Section To Go</doc.detach>. If you have, for example, a <doc.detach>Section</doc.detach> component of name <doc.detach>StartApiRequestBlock</doc.detach> that is at the beginning of your Task and
                    a component <doc.detach>Go To Section</doc.detach> that is at the end of your Task, with parameter <doc.detach>Section To Go</doc.detach> configured as <doc.detach>goto:StartApiRequestBlock</doc.detach> then Task will be
                    performed, however, when the execution executes its component <doc.detach>Go To Section</doc.detach>, it will cause the execution to return to component <doc.detach>Section</doc.detach> that is at the top and then follow
                    normally from that point. It is only possible to use <doc.detach>goto</doc.detach> for <doc.detach>Section</doc.detach> components that are in the same method as this component, ie it is not possible to use
                    <doc.detach>goto</doc.detach> pointing to different methods. You can have a little more detail about <doc.detach>goto</doc.detach> by clicking <a href="#64o">here</a>.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Component: Simple Comment -->
                <doc.topic topicid="64s">
                    <doc.topictitle>Tasks: Component: Simple Comment</doc.topictitle>

                    When this component runs on your Task, it will not do any useful work in Runtime, will only leave a comment in the code of your task that can be useful for you to document things, mark points of interest and so on. The
                    real use of this component is only in the Editor on Task Creator.
                    <br>
                    <br>
                    The <doc.detach>Simple Comment</doc.detach> component is available in the <doc.detach>Comments</doc.detach> section and you can click the <doc.icon src="DocumentationFiles/images/29"></doc.icon> button in
                    the Method to which you want to add this component.
                    <doc.image src="DocumentationFiles/images/87">
                        In the NAT Task Creator, when leaving the mouse over each of these Parameters you will see a Tooltip with a description of the desired Parameter.
                    </doc.image>

                    <doc.topicsubtitle>Parameters of this Component</doc.topicsubtitle>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>50%</doc.tablecw>
                        <doc.tablec>Parameter Name=>Value Type=>Allowed Value Providers</doc.tablec>
                        <doc.tabler>Comment=>STRING=>Only editorValue</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>How to use this Component?</doc.topicsubtitle>
                    To use this component, just enter your comment in the component's text box. This component supports multi-line texts. After adding your comment just save changes to your Task code.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Scheduling and managing Tasks -->
                <doc.topic topicid="65">
                    <doc.topictitle>Tasks: Scheduling and managing Tasks</doc.topictitle>

                    If you have read all about Tasks so far, you may already know how to code your Task and also know what each component does. In this topic we will address how to schedule and execute the Tasks that you programmed in the
                    Unity Editor using NAT Task Creator.
                    <br>
                    <br>
                    Note that Tasks cannot run in the Unity Editor, they are only performed on Android devices, and besides only run when your application requests or schedule to run using the C# API that will be described here in this
                    topic. Therefore, this topic assumes that you already have a programmed and saved Task in your NAT Preferences. After reading this topic you will already be able to schedule your Tasks and schedule them to run on the
                    user device.

                    <doc.topicsubtitle>Scheduling Tasks to be executed</doc.topicsubtitle>
                    Once you have programmed your Task in the Unity Editor in NAT Preferences and saved the changes to Task, the Task will be available for your C# application code, which will make it possible for it to be scheduled for
                    execution by your application and then run on background of the device according to the time your application was scheduled.
                    <br>
                    <br>
                    To schedule your Task for execution, use the code below...
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- new NAT.Tasks.ScheduledTask(executionMode)
    new NAT.Tasks.ScheduledTask(NAT.Tasks.ExecutionMode.ExecuteScheduled)
        .setDaysInFuture(0)
        .setHoursInFuture(0)
        .setMinutesInFuture(3)
        .EnableThisTask();
}
                    </code></doc.code>
                    The code above will schedule your task to run in 3 minutes in the future. Note that only one task can be scheduled at a time. If you schedule a task and there is already a scheduled, the old schedule will be overwhelmed.
                    If you want to start running your Task instantly, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- new NAT.Tasks.ScheduledTask(executionMode)
    new NAT.Tasks.ScheduledTask(NAT.Tasks.ExecutionMode.ForceToExecuteNow)
        .EnableThisTask();
}
                    </code></doc.code>
                    If you have <doc.detach>runtimeValues</doc.detach> defined with <doc.detach>Keys</doc.detach> defined in your Tasks components, you can use the <doc.detach>setRuntimeValue()</doc.detach> method in your Task scheduling
                    builder. For example, if you have a component with a defined <doc.detach>runtimeValue</doc.detach> where Key is <doc.detach>TOAST_MESSAGE</doc.detach>, as below...
                    <doc.image src="DocumentationFiles/images/88"></doc.image>
                    Then you should use code like the one below to schedule your task. This way you will be providing a value to Key <doc.detach>TOAST_MESSAGE</doc.detach> before scheduling your Task. When your Task run and component
                    <doc.detach>Show Toast</doc.detach> is executed, then Toast Message will be <b>"Hello World"</b>.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- new NAT.Tasks.ScheduledTask(executionMode)
    new NAT.Tasks.ScheduledTask(NAT.Tasks.ExecutionMode.ExecuteScheduled)
        .setRuntimeValue("TOAST_MESSAGE", "Hello World")
        .setMinutesInFuture(3)
        .EnableThisTask();
}
                    </code></doc.code>
                    <doc.warn>
                        When using method <doc.detach>setRuntimeValue()</doc.detach> to provide data for <doc.detach>runtimeValues</doc.detach>, it is very important that you provide the correct value type. For example, if the component
                        parameter expects an INT value, then you should use method <doc.detach>setRuntimeValue()</doc.detach> to provide an INT value. Disrespecting this rule may cause your task to fail, crashs or not work as expected.
                    </doc.warn>

                    <doc.topicsubtitle>Checking if there is a scheduled Task</doc.topicsubtitle>
                    To check if there is a scheduled task at the moment and pending to run, use the code below...
                    <br>
                    <br>
                    Note that even if the task that had been scheduled, it was recently executed, there may be a delay until the system reports that there is no more scheduled Task. This happens for some factors such as Android system cache
                    and other things.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isTaskEnabled();
    bool isScheduled = NAT.Tasks.isTaskEnabled();
}
                    </code></doc.code>

                    <doc.topicsubtitle>Canceling the execution of a scheduled Task</doc.topicsubtitle>
                    To cancel the scheduling of a Task, use the code below...
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- DisableTask();
    NAT.Tasks.DisableTask();
}
                    </code></doc.code>

                    <doc.topicsubtitle>Checking if there is any Task running at the moment</doc.topicsubtitle>
                    To check if there is any task being executed right now, use the code below...
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isRunningSomeTaskNow();
    bool isRunning = NAT.Tasks.isRunningSomeTaskNow();
}
                    </code></doc.code>

                    <doc.topicsubtitle>Important tips on Scheduling Tasks</doc.topicsubtitle>
                    There are some important tips that are worth highlighting when working with Scheduled Tasks. See below.
                    <doc.list>
                        <doc.listr>During the development of your Task, if any Crash occurs and you try to run your Task again, it is possible that the Task does not start to run. This error is automatically corrected usually after 30 minutes from the beginning of the last Task execution. This is because the NAT does not allow more than 1 Task to be performed at the same time, and as the last execution has Crashed, it may have intended that it has not finished. You can fix this error by excluding the <doc.detach>isRunningTask.lock</doc.detach> file from the <b>"/storage/emulated/0/Android/data/&lt;app.package.name&gt;/files/NAT/Tasks"</b> directory which is the scope <doc.detach>AppFiles/NAT/Tasks</doc.detach> on your Android device. Take the opportunity to consult the <doc.detach>last-crash.txt</doc.detach> file (at same path) to find out the reason for your Task crash. You can also consult MT Assets Support whenever you find it necessary.</doc.listr>
                        <doc.listr>When using <doc.detach>goto</doc.detach> in NAT Task, be careful not to create codes with eternal loops. If this happens during the execution of your Task on the user devices, they may not understand that it is just a bug, and think that something suspicious may be happening with your application as they will notice even a larger battery consumption, which It can lead to the uninstall of your application.</doc.listr>
                        <doc.listr>If you intend to keep a Task running from times to times on the user device, you can use the <doc.detach>Reschedule This Task</doc.detach> component, but it is also recommended that your application has a Task scheduling manager to control Tasks scheduling on your application. This way your application may re-schedule a Task if it is no longer scheduled. Android devices forget scheduled tasks if your application is killed by a task manager or if the device is rebooted.</doc.listr>
                        <doc.listr>Avoid scheduling Tasks with too short re-scheduling interval, such as repeating the Task every 15 minutes. Especially if your task will do a heavier job like downloading a file. Repeating Tasks at short time intervals may increase the battery consumption of the user device.</doc.listr>
                        <doc.listr>Although NAT does its best to ensure delivery of scheduled tasks, there is no guarantee that the tasks you have scheduled will be delivered. Therefore, it never makes your application completely depend on any tasks because the task may not be performed on some devices, for some reasons such as, very aggressive battery optimizers (such as Samsung, Hwauei etc), restarting the phone, killing the process of your application and etc. Good examples of tasks are: warn new updates, enter new messages, enter news and any othernormal tasks.</doc.listr>
                    </doc.list>

                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Schedule Exact Alarms=>xyz.windsoft.asynctaskssimplified, com.google.code.gson=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Tasks: Limitation of Tasks -->
                <doc.topic topicid="66">
                    <doc.topictitle>Tasks: Limitation of Tasks</doc.topictitle>

                    Currently the only limitation of Scheduled Tasks is due to abusive power limitations, imposed by some brands of Android cell phones. These abusive limitations end up killing the application background executions
                    and etc, which may delay or prevent the delivery of Scheduled Tasks of many applications. You can see more about it by clicking <a href="#44">here</a>.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Sharing: About This Class -->
                <doc.topic topicid="74">
                    <doc.topictitle>Sharing: About This Class</doc.topictitle>

                    The Native Android Toolkit Sharing class provides your application with methods so that it can use the Android system's sharing tools to share text, images, and other things with other applications installed on the
                    user's device. Keep reading to delve deeper into this class!

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Sharing: Sharing Texture2D -->
                <doc.topic topicid="75">
                    <doc.topictitle>Sharing: Sharing Texture2D</doc.topictitle>

                    To share a Unity Texture2D with another application, use the code below. It will open the Android system sharing window that will allow the user to choose an application installed on the device to share.
                    <br>
                    <br>
                    Note: If you set an empty title, NAT will use a simplified interface in the share dialog.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

public Texture2D texture;

void Example()
{
    //- ShareTexture2D(shareTitle, textureToShare, messageOfShare);
    NAT.Sharing.ShareTexture2D("Sharing Texture2D", texture, "This is the example message of share!");
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>androidx.core (and its dependencies)=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Sharing: Sharing Text Plain -->
                <doc.topic topicid="76">
                    <doc.topictitle>Sharing: Sharing Text Plain</doc.topictitle>

                    To share a String with another application, use the code below. It will open the Android system sharing window that will allow the user to choose an application installed on the device to share.
                    <br>
                    <br>
                    Note: If you set an empty title, NAT will use a simplified interface in the share dialog.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- ShareTextPlain(shareTitle, textToShare);
    NAT.Sharing.ShareTextPlain("Sharing Text", "This is the text to be shared! :)");
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Sharing: Copy Text to Clipboard -->
                <doc.topic topicid="77">
                    <doc.topictitle>Sharing: Copy Text to Clipboard</doc.topictitle>

                    To copy a String to the Device Clipboard, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- CopyTextToClipboard(textToBeCopied);
    NAT.Sharing.CopyTextToClipboard("Text to be copied to Clipboard");
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Sharing: Get Text from Clipboard -->
                <doc.topic topicid="78">
                    <doc.topictitle>Sharing: Get Text from Clipboard</doc.topictitle>

                    To get the text that is currently on the user's device Clipboard, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- GetTextFromClipboard();
    string textFromClipboard = NAT.Sharing.GetTextFromClipboard();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Sharing: Take Screenshot and Get Texture2D Async -->
                <doc.topic topicid="79">
                    <doc.topictitle>Sharing: Take Screenshot and Get Texture2D Async</doc.topictitle>

                    If you need to take a Screenshot asynchronously and get a Texture2D already processed and ready to use, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //First, register the callbacks...
    
    //- onCompleteScreenshotTexture2dProcessing(resultTexture)
    NATEvents.onCompleteScreenshotTexture2dProcessing += (Texture2D texture) =>
    {
        Debug.Log("Screenshot size is: " + texture.width + " x " + texture.height);
    };
    
    //Second, call the code of the NAT C# API
    
    //- TakeScreenshotAndGetTexture2D();
    NAT.Sharing.TakeScreenshotAndGetTexture2D();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Webview: About This Class -->
                <doc.topic topicid="81">
                    <doc.topictitle>Webview: About This Class</doc.topictitle>

                    This class provides tools so that your application can interact with the Web and open pages from Sites without the need for the user to leave your application. All this together with systems that give you greater control
                    of user navigation.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Webview: Using The Webview -->
                <doc.topic topicid="82">
                    <doc.topictitle>Webview: Using The Webview</doc.topictitle>

                    In this topic you will learn about the Native Android Toolkit Webview and how to use it. We will cover several topics so that you can delve deeper and understand how it works.

                    <doc.topicsubtitle>How to open Webview</doc.topicsubtitle>
                    First you need to know that there are different types of Webview layout. There are currently <doc.detach>Adaptative PopUp</doc.detach>, <doc.detach>Landscape Fullscreen</doc.detach> and
                    <doc.detach>Portrait Fullscreen</doc.detach>. The Webview will open and function normally in both, but each has some pros and cons that we'll see below. To open the Webview you can use the constructor code below and you
                    can also set any parameters you want.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- new NAT.Webview.WebviewChromium(homeUrl, webviewMode)
    new NAT.Webview.WebviewChromium("https://google.com/", NAT.Webview.WebviewMode.AdaptativePopUp)
        .setTitle("NAT Webview")
        .setShowToolbar(true)
        .setHideRefreshButton(false)
        .setShowControls(true)
        .setHideBackAndForwardButtons(false)
        .setHideHomeButton(false)
        .setNetworkErrorMessage("There was a network problem!")
        .setNetworkErrorButtonMessage("Try Again")
        .setEnableCache(false)
        .setEnableJavaScript(true)
        .setEnableZoom(true)
        .setEnableMediaAutoPlay(true)
        .OpenThisWebview();
}
                    </code></doc.code>
                    As said before, we have some Webview Layouts (or modes), see more about each one...
                    <doc.list>
                        <doc.listr><b>AdaptativePopUp</b> - In this mode the Webview will open inside a window (popup) that will not fully cover your application. This window will adapt according to the device's current resolution and orientation so that it doesn't cover your entire application but isn't a small window either. Your app will continue to run behind that window and the user can close the Webview at their leisure and resume instantly from where they left off. The only negative point of this Webview mode is that videos do not work in it due to limitations of the Android system. If you try to play a video while in this Webview mode, you will only hear the sound of the video.</doc.listr>
                        <doc.listr><b>LandscapeFullscreen and PortraitFullscreen</b> - In this mode the Webview will occupy the entire screen and close your application activity (although it will not close your application completely). As in this mode Webview is able to make use of all device resources without limitations, it is possible to play videos smoothly at any frame rate. When the user closes this Webview, your application's activity is opened again, but it is as if it had been opened again by the user, restarting from the beginning of your application. Also, your application needs to "manually" choose between <doc.detach>LandscapeFullscreen</doc.detach> and <doc.detach>PortraitFullscreen</doc.detach> according to the device's current orientation.</doc.listr>
                    </doc.list>
                    Now that you know the pros and cons and how each layout works you need to know how to choose between the desired layout for the Webview. This choice is made in the Webview's construction code, before opening it. For
                    this, you must inform the type of Webview at the beginning of the code, as in the example below...
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- new NAT.Webview.WebviewChromium(homeUrl, webviewMode)
    new NAT.Webview.WebviewChromium("https://google.com/", NAT.Webview.WebviewMode.LandscapeFullscreen) //<- Inform here
        .OpenThisWebview();
}
                    </code></doc.code>
                    Now, speaking of customizing your Webview, at the time you are writing the Webview construction code, before opening it, you can customize the Webview in several ways. This can be done using the methods before calling
                    the final <doc.detach>OpenThisWebview();</doc.detach> method in the constructor. For example, in the code below, we open the Webview but disable JavaScript.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- new NAT.Webview.WebviewChromium(homeUrl, webviewMode)
    new NAT.Webview.WebviewChromium("https://google.com/", NAT.Webview.WebviewMode.AdaptativePopUp)
        .setEnableJavaScript(false)
        .OpenThisWebview();
}
                    </code></doc.code>
                    The table below contains all the methods you can use to customize your Webview and a description of each one.
                    <doc.table>
                        <doc.tablecw>16%=>8%=>auto</doc.tablecw>
                        <doc.tablec>Method=>Requires=>Description</doc.tablec>
                        <doc.tabler>setTitle=>STRING=>Allows you to define a fixed title for the Webview that will be displayed at all time while the Webview is open. If you don't define any title, the Webview will always show the title of the page currently being displayed to the user, like a normal browser.</doc.tabler>
                        <doc.tabler>setShowToolbar=>BOOL=>Allows you to turn off or on the Webview Top Toolbar.</doc.tabler>
                        <doc.tabler>setHideRefreshButton=>BOOL=>Allows you to disable or enable the Webview Refresh button.</doc.tabler>
                        <doc.tabler>setShowControls=>BOOL=>Allows you to disable or enable the Bottom Toolbar which is where the Webview navigation controls are located.</doc.tabler>
                        <doc.tabler>setHideBackAndForwardButtons=>BOOL=>Allows you to disable or enable the Forward and Back navigation buttons that allow you to move forward or backward through browsed pages.</doc.tabler>
                        <doc.tabler>setHideHomeButton=>BOOL=>Allows you to disable or enable the Webview Home button. This button allows the user to return to the Home page specified in the constructor at any time.</doc.tabler>
                        <doc.tabler>setNetworkErrorMessage=>STRING=>Allows you to define a custom connection error message. The message will be shown to the user whenever there is a problem loading a page, for example, when the device is without internet.</doc.tabler>
                        <doc.tabler>setNetworkErrorButtonMessage=>STRING=>Allows you to define a custom message for the "Try Again" button. This button will be shown to the user whenever there is a problem loading a page, for example, when the device is without internet.</doc.tabler>
                        <doc.tabler>setEnableCache=>BOOL=>Allows you to enable or disable Page Load Caching as the user browses within the Webview. If in your Webview the user can browse more freely and through several pages, this may represent a greater consumption of internet in cases where the user uses mobile data from operators. On the other hand, if in your Webview the user will be restricted to a single site, for example, deactivating this can increase the reliability of the loaded pages, since none of them will be cached.</doc.tabler>
                        <doc.tabler>setEnableJavaScript=>BOOL=>Allows you to disable or enable JavaScript to work in your Webview. By default the Webview has JavaScript enabled but you can disable it using this method for situations where you want to display a static website for example.</doc.tabler>
                        <doc.tabler>setEnableZoom=>BOOL=>Allows you to disable or enable the "pinch zoom" that the user can do to enlarge or reduce the pages.</doc.tabler>
                        <doc.tabler>setEnableMediaAutoPlay=>BOOL=>Allows you to disable or enable media autoplay without interaction that some websites do. If you disable this, media on websites will only start playing if there is some kind of user interaction with the page. If you keep this enabled, the site can automatically play media without user interaction. In many cases, like videos for example, if this option is activated, the site can start showing the video if you want, but without audio.</doc.tabler>
                    </doc.table>

                    <doc.topicsubtitle>Using events to get data from user navigation or know when the Webview was closed</doc.topicsubtitle>
                    With Events you are able to know when a Webview was closed, but not only that. You are also able to receive various data and information collected by the NAT while the user navigated through your application's Webview,
                    data such as browsed pages.
                    <br>
                    <br>
                    In this subtopic you will learn how to use Events for your application's Webviews. The way to use Events will change depending on which Webview mode you have opened, for example if you used
                    <doc.detach>Adaptative PopUp</doc.detach> mode then you should use a event and if you used <doc.detach>Landscape Fullscreen</doc.detach> or <doc.detach>Portrait Fullscreen</doc.detach> mode then you should use another
                    event.
                    <br>
                    <br>
                    <b>Using AdaptativePopUp</b>
                    <br>
                    <br>
                    As seen before, this Webview mode will not interrupt your application's execution flow and when the user closes the Webview, your application will continue to run normally without interruptions. That's why if you are
                    going to use an <doc.detach>AdaptativePopUp</doc.detach> Webview and want to know when the Webview was closed as well as get navigation data, you must register the callback in the event <b>BEFORE</b> opening the Webview.
                    See example below...
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //First, register the callbacks...

    //- onPopUpWebviewClose(webviewBrowsingData)
    NATEvents.onPopUpWebviewClose += (NAT.Webview.WebviewBrowsing webviewBrowsing) =>
    {
        Debug.Log("The user browsed through " + webviewBrowsing.browsedSites.Length + " pages.");
        Debug.Log("The used webview mode is " + webviewBrowsing.webviewType + ".");
    };

    //Second, call the code of the NAT C# API

    //- new NAT.Webview.WebviewChromium(homeUrl, webviewMode)
    new NAT.Webview.WebviewChromium("https://google.com/", NAT.Webview.WebviewMode.AdaptativePopUp)
        .OpenThisWebview();
}
                    </code></doc.code>
                    <doc.info>
                        If the user closes your application while Webview <doc.detach>AdaptativePopUp</doc.detach> is open, this event will not be called, but event
                        <doc.detach>onResumeApplicationAfterCloseFullscreenWebview_PostInitialize</doc.detach> (discussed below) will be the event to be called when your application is opened again in the future.
                        <br>
                        <br>
                        If you don't care about detecting the Webview's navigation information if your application was closed while the Webview was open, then you can just use this event without any problems and ignore
                        <doc.detach>onResumeApplicationAfterCloseFullscreenWebview_PostInitialize</doc.detach>, the event discussed below.
                    </doc.info>
                    <br>
                    <br>
                    <b>Using LandscapeFullscreen or LandscapePortrait</b>
                    <br>
                    <br>
                    As seen before, the Webview in <doc.detach>LandscapeFullscreen</doc.detach> or <doc.detach>LandscapePortrait</doc.detach> mode opens a new activity and when the user closes the Webview, your application restarts from the
                    starting point, as if it had been opened again. Because of this, if you intend to use the Webview of this type, there is another event that will work perfectly in this case. This event returns the same things that the
                    above event would return, however, to use this event you must <b>ALWAYS</b> register the callback in it, but <b>ALWAYS BEFORE</b> initializing the Native Android Toolkit. See sample code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //First, register the callbacks...

    //- onResumeApplicationAfterCloseFullscreenWebview_PostInitialize(webviewBrowsingData)
    NATEvents.onResumeApplicationAfterCloseFullscreenWebview_PostInitialize += (NAT.Webview.WebviewBrowsing webviewBrowsing) =>
    {
        Debug.Log("The user browsed through " + webviewBrowsing.browsedSites.Length + " pages.");
        Debug.Log("The used webview mode is " + webviewBrowsing.webviewType + ".");
    };

    //Second, call the code of the NAT C# API

    if (NativeAndroidToolkit.isInitialized == false)
        NativeAndroidToolkit.Initialize();

    //...
}
                    </code></doc.code>
                    This way, when your application starts and it initalizes the Native Android Toolkit, the Native Android Toolkit in turn will check if the Webview was open. If it was, your code registered in the event will be executed.
                    If the Webview was not open then nothing will happen.
                    <doc.info>
                        The above event will still work even if your application was closed by the user while the Fullscreen Webview was open.
                    </doc.info>

                    <doc.topicsubtitle>Adding Cookies to the Webview</doc.topicsubtitle>
                    If your application has Cookies that it uses to talk to APIs or other things, you can pass those Cookies if you prefer, before opening the Webview. So for example, if you have User Login Cookies of your site, you can set
                    those Cookies to the Webview and then open your site. When the Webview opens on your site, the user is already logged in and does not need to manually log in within the Webview. To add Cookies to the Webview, use the
                    code below.
                    <br>
                    <br>
                    Note that you must use the <doc.detach>https://</doc.detach> protocol in your domain name in the Cookie.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- new NAT.Webview.WebviewCookie(cookieName, cookieContent, cookieDomain)
    NAT.Webview.WebviewCookie cookie = new NAT.Webview.WebviewCookie("sessID", "43nm43klM43KOLNKN2dsds", "https://example.com");

    //- new NAT.Webview.WebviewChromium(homeUrl, webviewMode)
    new NAT.Webview.WebviewChromium("https://google.com/", NAT.Webview.WebviewMode.AdaptativePopUp)
        .addCookie(cookie)
        .OpenThisWebview();
}
                    </code></doc.code>

                    <doc.topicsubtitle>Clearing all Cookies from Webview or UnityWebRequest</doc.topicsubtitle>
                    If you want to clear all Cookies from the Native Android Toolkit Webview, use the code below while the Webview is not open.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- ClearAllCookies(clearMethod);
    NAT.Webview.ClearAllCookies(NAT.Webview.WebviewClearCacheMode.OnlyWebview);
}
                    </code></doc.code>
                    Unity Engine has the <doc.detach>UnityWebRequest</doc.detach> API which is used to make HTTP requests to the web through your C# code. Very useful for making any requests to the web, and it also supports Cookies which
                    means you can provide your Cookies to this API and it will handle them automatically, sending them for each request depending on the domain the Cookies belong to. If you want to clear Cookies from this API instead of the
                    Webview, you can use the code below...
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- ClearAllCookies(clearMethod);
    NAT.Webview.ClearAllCookies(NAT.Webview.WebviewClearCacheMode.OnlyUnityWebRequest);
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Webview: Access Page With POST/GET and get all returned Cookies -->
                <doc.topic topicid="83">
                    <doc.topictitle>Webview: Access Page With POST/GET and get all returned Cookies</doc.topictitle>

                    This method allows you to access an API (PHP for example), sending POST or GET data. Once NAT accesses this API, NAT will get any Cookies returned by the API, as well as the response page.
                    <br>
                    <br>
                    This can be very useful for situations like when you want to use the user's credentials to log in to your site, get the returned login Cookie and then save it for future requests to your API or to use that Cookie in the
                    NAT Webview, so the user doesn't have to re-login each time your site is opened in Webview.
                    <br>
                    <br>
                    Note that for method <doc.detach>AccessSomeURLWithPostDataAndGetAllCookies()</doc.detach> to work, parameter <doc.detach>pageUrl</doc.detach> must be formatted as
                    <doc.detach>https://example.com/folder/page.php</doc.detach> and parameter <doc.detach>pageDomain</doc.detach> must be formatted as <doc.detach>https://example.com</doc.detach>. To use this method, use the code below...
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //First, register the callbacks...

    //- onWebviewGettedAllCookiesFromURL(isRequestSuccessfull, returnedCookies, responseHtml)
    NATEvents.onWebviewGettedAllCookiesFromURL += (bool succesfully, NAT.Webview.WebviewCookie[] cookies, string pageContent) =>
    {
        if (succesfully == true)
            foreach (NAT.Webview.WebviewCookie cookie in cookies)
                Debug.Log("Cookie Name: " + cookie.name + ", Content: " + cookie.content + ", Domain: " + cookie.domain);
        
        Debug.Log("The response HTML is\n\n" + pageContent);
    };

    //Second, call the code of the NAT C# API

    //===================================== FOR POST METHOD =====================================//

    //Preparing the POST data
    NAT.Webview.WebviewPostData postData = new NAT.Webview.WebviewPostData();
    postData.addField("username", "tomRules00");
    postData.addField("password", "0123456789");
    
    //- AccessSomeURLWithPostDataAndGetAllCookies(accessMethod, pageUrl, pageDomain, postFields)
    NAT.Webview.AccessSomeURLWithPostDataAndGetAllCookies(NAT.Webview.WebviewAccessMethod.Post, "https://example.com/apis/login.php", "https://example.com", postData.CloseAndGetPostDataArray());

    //====================================== FOR GET METHOD =====================================//

    //- AccessSomeURLWithPostDataAndGetAllCookies(accessMethod, pageUrl, pageDomain, postFields)
    NAT.Webview.AccessSomeURLWithPostDataAndGetAllCookies(NAT.Webview.WebviewAccessMethod.Get,
                                                          "https://example.com/apis/login.php?username=tomRules00&password=0123456789", "https://example.com",
                                                          new NAT.Webview.WebviewPostField[0]);
}
                    </code></doc.code>
                    <doc.warn>
                        Do not use this method to communicate with APIs using POST or GET as this method was created with the sole purpose of obtaining Cookies. For the purpose of communicating with APIs using POST or GET, Unity's
                        <doc.detach>UnityWebRequest</doc.detach> API is even better.
                    </doc.warn>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Permissions: About This Class -->
                <doc.topic topicid="86">
                    <doc.topictitle>Permissions: About This Class</doc.topictitle>

                    This class provides tools for your application to request permissions, check permissions and other tools related to Android system permissions.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Permissions: Principles of Permissions in the Android -->
                <doc.topic topicid="86a">
                    <doc.topictitle>Permissions: Principles of Permissions in the Android</doc.topictitle>

                    In this topic we will talk about the principles of permissions and good practices. It is interesting that you are aware of this subject, especially if you want to publish your application on Google Play, since the points
                    listed here are observed there, by moderation. In Android system we have non-sensitive permissions (like Internet, Vibration and similar) and sensitive permissions (like Camera, Microphone and similar). This topic is
                    mainly concerned with sensitive permissions, as they are the only ones that can be requested at runtime and are the only ones that the user can revoke or grant. Non-sensitive permissions are very low risk as they
                    generally pose no problems for the user.
                    <doc.warn>
                        Before using a Native Android Toolkit feature that may depend on any permissions, make sure that the permission that that feature needs is enabled in the Native Android Toolkit Preferences. if it's a sensitive
                        permission (like Camera, Location and similar) make sure the user has given you permission, and if not, ask for permission to user using the NAT C# API.
                        <br>
                        <br>
                        Trying to use a feature of Native Android Toolkit that depends on a permission, without your application having that permission can result in bugs or crashes in your application, so always check if your application
                        has that permission if you are going to use a feature that depends on it.
                    </doc.warn>
                    According to Google's documentation, related to Permissions in the Android system, we have the following topics...

                    <doc.topicsubtitle>Guidelines</doc.topicsubtitle>
                    Regarding the guidelines for using permissions in Android apps, we have the following...
                    <doc.list>
                        <doc.listr>Your app can only request permissions that it will actually use. it is not recommended to ask for permissions that will not be used or that will only be used in future updates. just enable Native Android Toolkit permissions and request them on the fly if you are going to actually use them. You can check here in the documentation which Native Android Toolkit functions depend on a certain permission. If your app won't use a certain function that needs a certain permission, disable all permissions that your app doesn't use. you can do this through the NAT Preferences window.</doc.listr>
                        <doc.listr>If the app targets Android 11 (API level 30) or higher and is not used for a few months, the system protects the user's data by automatically resetting the confidential run permissions that the user has granted to the app.</doc.listr>
                    </doc.list>

                    <doc.topicsubtitle>Best practices</doc.topicsubtitle>
                    Entering the topic of good practices, we have the following items...
                    <doc.list>
                        <doc.listr>If possible, ask for permissions in context when the user starts interacting with the feature that requires the permission.</doc.listr>
                        <doc.listr>If a feature that depends on a permission is NOT essential for your application to work, do not block the user. Always provide the option to cancel a permissions-related educational UI flow.</doc.listr>
                        <doc.listr>
                            If a function of your app is NOT essential and the user denies or revokes a required permission for that feature, do a soft degradation so they can continue using the app, possibly disabling the feature that requires the permission.
                            <doc.list>
                                <doc.listr>
                                    Highlight a specific part of the app's UI where functionality will be limited because the app doesn't have the required permission. Here are some examples of what you can do:
                                    <doc.list>
                                        <doc.listr>Show a message where the feature results or data would be displayed.</doc.listr>
                        <doc.listr>Display a different button that contains an error icon and color.</doc.listr>
                    </doc.list>
                    <doc.listr>Don't display a generic message. Instead, mention which features aren't available because the app doesn't have the required permission.</doc.listr>
                    </doc.listr>
                    </doc.list>
                    </doc.listr>
                    <doc.listr>If a feature is NOT essential to the functioning of your application, request permission as late as possible in the flow of your application's use cases. For example, if your app allows users to send audio messages to others, wait for the user to navigate to the messages screen and press the "Send Audio Message" button. After the user presses the button, your app can request access to the microphone.</doc.listr>
                    <doc.listr>When making a permission request, be clear about what you're accessing and why, so users can make informed decisions.</doc.listr>
                    <doc.listr>When accessing sensitive data or hardware, such as the camera or microphone, provide an ongoing indication within your app. This reminder helps users understand exactly when your app accesses restricted data or performs restricted actions.</doc.listr>
                    </doc.list>

                    <doc.topicsubtitle>Types of Permissions used by Native Android Toolkit</doc.topicsubtitle>
                    <b>Normal Permissions</b>
                    <br>
                    <br>
                    These are permissions that allow your app to access other system functions, outside your app's sandbox. these additional functions pose little risk to user privacy and the operation of other apps. the Android system
                    assigns the "normal" level to these permissions and automatically grants them without you having to ask the user for them.
                    <br>
                    <br>
                    Examples: Internet, Access Wifi State and similars...
                    <br>
                    <br>
                    <b>Runtime Permissions</b>
                    <br>
                    <br>
                    Also known as dangerous or sensitive permissions, these give your app additional access to restricted data and allow it to perform restricted actions that more significantly affect the system and other apps. Therefore,
                    you must request runtime permissions on the app before accessing restricted data or performing restricted actions. for that you can use the <b>Permissions class</b> from NAT or the <b>Permissions Requester Wizard</b>
                    from the Permissions class from NAT through the C# API. When your app requests a runtime permission, the system presents a dialog asking for the given runtime permission. Many runtime permissions access private user
                    data, a special type of restricted data that includes potentially sensitive information. Examples of private user data include location and contact information. The system assigns the "dangerous" protection level to
                    runtime permissions.
                    <br>
                    <br>
                    Examples: Camera, Access Fine Location and similars...

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Permissions: Opening Permissions Requester Wizard -->
                <doc.topic topicid="87">
                    <doc.topictitle>Permissions: Opening Permissions Requester Wizard</doc.topictitle>

                    The Native Android Toolkit "Permissions Requester Wizard" is a screen that your application can open to request one or more permissions at the same time from the user. This screen presents a friendly interface that shows
                    the permissions that your application needs as well as an explanation of why each of the permissions requested there is necessary for your application. The user will see a button to give that permission and instantly be
                    able to see if the permission was given or not. At any time, the user can return to your application without blocking. See the image below to better understand this screen...
                    <doc.image src="DocumentationFiles/images/89"></doc.image>
                    <doc.image src="DocumentationFiles/images/90"></doc.image>
                    To open the "Permissions Requester Wizard" use the code below...
                    <br>
                    <br>
                    Note: If you don't need to request a permission, remove the <doc.detach>addPermissionToRequest()</doc.detach> method referring to that permission from the constructor, before finally calling
                    <doc.detach>OpenThisPermissionRequesterWizard()</doc.detach> to open the screen.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- new NAT.Permissions.PermissionRequesterWizard(titleBar, orientation)
    new NAT.Permissions.PermissionRequesterWizard("Permission Requester Wizard", NAT.Permissions.RequesterWizardMode.LandscapeFullscreen)
        .addPermissionToRequest("Camera", NAT.Permissions.AndroidPermission.Camera, "Required for Camera functions to work in this application.")
        .addPermissionToRequest("Access Coarse Location", NAT.Permissions.AndroidPermission.AccessCoarseLocation, "Required for Location functions to work in this application.")
        .addPermissionToRequest("Access Fine Location", NAT.Permissions.AndroidPermission.AccessFineLocation, "Required for Location functions to work in this application.")
        .addPermissionToRequest("Record Audio", NAT.Permissions.AndroidPermission.RecordAudio, "Required for Recording functions to work in this application.")
        .addPermissionToRequest("Access Files And Media", NAT.Permissions.AndroidPermission.AccessFilesAndMedia, "Required for Files functions to work in this application.")
        .setWaitingAndGivenPermissionMessage("(Waiting for you to allow)", "(Permission granted!)")
        .setWarningMessage("This app needs you to provide some permissions for it to work properly. You can see each of the required permissions here and a short explanation of why it is needed.")
        .setGivePermissionButtonMessage("Allow")
        .setDoneButtonMessage("Done, go back to the app!")
        .OpenThisPermissionRequesterWizard();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Permissions: Checking if Application have a specific Permission -->
                <doc.topic topicid="88">
                    <doc.topictitle>Permissions: Checking if Application have a specific Permission</doc.topictitle>

                    To check if your application has a specific permission, use the code below. You just need to pass the permission you want to check as a parameter to method <doc.detach>isPermissionGuaranteed()</doc.detach>.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isPermissionGuaranteed(permissionToCheck)
    bool permissionGuaranteed = NAT.Permissions.isPermissionGuaranteed(NAT.Permissions.AndroidPermission.Camera);
}
                    </code></doc.code>
                    <doc.info>
                        This method may cause your application to freeze quickly, which is caused by the Android system. It might not be a good idea to call this method frequently while your application is running, so it's ideal to have a
                        caching system that will only check once per session if your application has a certain permission.
                    </doc.info>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Permissions: Requesting Permissions -->
                <doc.topic topicid="89">
                    <doc.topictitle>Permissions: Requesting Permissions</doc.topictitle>

                    To request one or more permissions for the user, using the traditional method (without the <doc.detach>Permissions Requester Wizard</doc.detach>), you can use the code below. You can use method
                    <doc.detach>addPermissionToRequest()</doc.detach> in the constructor to add more permissions to request. In the example below, only Camera access permission is being requested.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- new NAT.Permissions.PermissionRequester()
    new NAT.Permissions.PermissionRequester()
        .addPermissionToRequest(NAT.Permissions.AndroidPermission.Camera)
        .RequestThisPermissions();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: About This Class -->
                <doc.topic topicid="91">
                    <doc.topictitle>Utils: About This Class</doc.topictitle>

                    The Utils class provides a series of tools and utilities related to the Android system. With this class your application will be able to do hardware checks, get information about the system and much more.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Restarting the Application -->
                <doc.topic topicid="92">
                    <doc.topictitle>Utils: Restarting the Application</doc.topictitle>

                    To restart your application, without the user having to close it and reopen it manually, use the code below...
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- RestartApplication(restartMessage, restartInterfaceOrientation);
    NAT.Utils.RestartApplication("The application is restarting. Just a moment...", NAT.Utils.RestartInterfaceMode.LandscapeFullscreen);
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Vibrate Device -->
                <doc.topic topicid="93">
                    <doc.topictitle>Utils: Vibrate Device</doc.topictitle>

                    To make the device vibrate for a set duration of time, use the code below. You need to enter the time in milliseconds.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- Vibrate(duration);
    NAT.Utils.Vibrate(300);
}
                    </code></doc.code>
                    To make the device vibrate, in a pattern way, use the code below. You need to inform an array of millisecond values, where the first value of the array represents the first delay, the second value of the array represents
                    the duration of the first vibration, the third value of the array represents one more delay, the fourth value of the array represents one more vibration and so on.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- VibrateWithPattern(vibrationPattern);
    NAT.Utils.VibrateWithPattern(new long[] { 0, 300, 100, 300, 100, 300 });
}
                    </code></doc.code>
                    If you need to vibrate the device in very short time intervals, try to use the code below, as it is optimized for frequent device vibration, which in some specific cases may reduce performance consumption with each
                    vibration call.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- VibratePlus(duration);
    NAT.Utils.VibratePlus(300);
}
                    </code></doc.code>
                    <doc.info>
                        If the device doesn't support Hardware Vibration, calling this method will just fail silently, not posing any problem for your application.
                    </doc.info>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Vibrate=>None=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Get Device Manufacturer -->
                <doc.topic topicid="96">
                    <doc.topictitle>Utils: Get Device Manufacturer</doc.topictitle>

                    To get the device vendor in a String, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- GetDeviceManufacturer();
    string deviceManufacturer = NAT.Utils.GetDeviceManufacturer();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Get Device Model -->
                <doc.topic topicid="97">
                    <doc.topictitle>Utils: Get Device Model</doc.topictitle>

                    To get the device model name in a String, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- GetDeviceModel();
    string deviceModel = NAT.Utils.GetDeviceModel();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Get Device Android Version Code -->
                <doc.topic topicid="98">
                    <doc.topictitle>Utils: Get Device Android Version Code</doc.topictitle>

                    The device version code represents the Android API level of the device, that is, the version of Android that is running on the device. For example, version code 30 represents API Level 30, which is Android 11. You
                    can click <a href="https://source.android.com/docs/setup/about/build-numbers" target="_blank">here</a> to see the list of Android APIs.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- GetDeviceAndroidVersionCode();
    int apiLevel = NAT.Utils.GetDeviceAndroidVersionCode();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Speak With Text-To-Speech -->
                <doc.topic topicid="99">
                    <doc.topictitle>Utils: Speak With Text-To-Speech</doc.topictitle>

                    To make the device speak a String using the device's native Text-To-Speech engine, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- SpeakWithTTS(language, textToSpeech, queueMode)
    NAT.Utils.SpeakWithTTS(NAT.Utils.TTSEngineLanguage.DeviceDefault, "Hello! I'm Native Android Toolkit!", NAT.Utils.TTSEngineQueueMode.FlushQueueAndAdd);
}
                    </code></doc.code>
                    <doc.info>
                        By setting a language other than <doc.detach>DeviceDefault</doc.detach>, NAT will check if the desired language is available before the device starts talking. If the language is not available or installed on the
                        device, the <doc.detach>DeviceDefault</doc.detach> option will be used and the text will be spoken using the default language supported by the device.
                    </doc.info>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Get Device Current Locale -->
                <doc.topic topicid="100">
                    <doc.topictitle>Utils: Get Device Current Locale</doc.topictitle>

                    To get information related to the device's current location, use the code below. It is possible to get the ISO3 country code, the current language configured on the device and even the current currency code. The
                    information is returned in a String and you just need to change the final parameter of method <doc.detach>GetDeviceCurrentLocale();</doc.detach> to the information you want to get.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- GetDeviceCurrentLocale(localeType)
    string locale = NAT.Utils.GetDeviceCurrentLocale(NAT.Utils.LocaleType.ISO3Language);
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Enable/Disable Anti-Screenshot -->
                <doc.topic topicid="101">
                    <doc.topictitle>Utils: Enable/Disable Anti-Screenshot</doc.topictitle>

                    The Android system provides a protection that allows a certain application to prohibit other applications from capturing the screen of that application. But not only that, if that particular application activates this
                    protection, the user is also unable to take screenshots using the Screenshot shortcut (usually Home + Volume) of the Android system or using other applications. With NAT you can enable or disable this protection against
                    Screenshots or Screenrecording using the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- EnableAntiScreenshot(enable)
    NAT.Utils.EnableAntiScreenshot(true);
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Convert DP to Pixels and vice versa -->
                <doc.topic topicid="102">
                    <doc.topictitle>Utils: Convert DP to Pixels and vice versa</doc.topictitle>

                    The <doc.detach>DP</doc.detach> unit of measurement is a unit of measurement commonly used to define the size of interface elements in a native application (made with Android Studio for example) that will run on Android
                    devices. The <doc.detach>DP</doc.detach> measurement unit differs depending on the device and screen size, it scales with the pixel density of each device so defining interface sizes with a single
                    <doc.detach>DP</doc.detach> measurement will make the element have a similar size on different devices. Generally Banner Ads (like Admob, UnityAds) use the <doc.detach>DP</doc.detach> unit of measurement and are usually
                    50 DP height.
                    <br>
                    <br>
                    This is where this method comes in. Many times when we display Banner advertisements for example in our applications, we would like to put a background or border for that Banner, so that it doesn't just appear "out of
                    nowhere" on the user's screen and seems to fit better with the UI of our application made in Unity. We know that Banners are usually 50 DP high, the problem is that this height varies according to each device and there
                    is no effective way to get the Banner size in our Canvas universally so that we can show a border on the Banner or a background.
                    <br>
                    <br>
                    Thanks to this method you can easily convert a size in <doc.detach>DP</doc.detach> to <doc.detach>Pixels</doc.detach>. This method does all the necessary calculations to convert <doc.detach>DP</doc.detach> to
                    <doc.detach>Pixels</doc.detach> easily, taking into consideration the device's screen size, pixel density, etc. To do the conversion, use the code below...
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- ConvertDPToPixels(dpSize)
    int pixels = NAT.Utils.ConvertDPToPixels(50.0f);
}
                    </code></doc.code>
                    The opposite is also possible. To convert <doc.detach>Pixels</doc.detach> to <doc.detach>DP</doc.detach> use the code below...
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- ConvertPixelsToDP(pixelsSize)
    float dp = NAT.Utils.ConvertPixelsToDP(250);
}
                    </code></doc.code>
                    <doc.info>
                        To find out the size of Banner ads and other types of ads that you display in your application, consult your ad network's documentation. The height of 50 DP is the default height for AdMob and Unity Ads Banners, but
                        the size values may vary according to each ads provider.
                    </doc.info>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Convert Pixels Size To Canvas Size -->
                <doc.topic topicid="104">
                    <doc.topictitle>Utils: Convert Pixels Size To Canvas Size</doc.topictitle>

                    As you may know, scaling things inside Canvas using Pixels doesn't work. If you scale an image 50 pixels high and 50 pixels wide in Canvas, it will look either too big or too small, not even close to the actual size of a
                    50x50 pixels image. This happens because Canvas unit of measure is <doc.detach>Unit</doc.detach> which is the default unit of measure for Unity, which is equivalent to <doc.detach>Meters</doc.detach>.
                    <br>
                    <br>
                    This method was created so that you can convert sizes in <doc.detach>Pixels</doc.detach> to <doc.detach>Units</doc.detach>, and the internal calculation takes several things into account, such as screen size, Canvas
                    scale and etc and manages to provide a very accurate conversion.
                    <br>
                    <br>
                    To do this conversion, use the code below. In the example below, let's convert the size of an AdMob Banner (which is <doc.detach>320x50 DP</doc.detach>) to <doc.detach>Pixels</doc.detach> and then convert the Banner size
                    in <doc.detach>Pixels</doc.detach> to a <doc.detach>Canvas Size (Units)</doc.detach>. To convert Pixels to Canvas Size, you must provide a reference to the <doc.detach>Canvas</doc.detach> component of your application
                    interface!
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    int bannerWidth = NAT.Utils.ConvertDPToPixels(320);
    int bannerHeight = NAT.Utils.ConvertDPToPixels(50);

    //- ConvertPixelsSizeToCanvasSize(targetCanvas, pixelsWidth, pixelsHeight)
    NAT.Utils.CanvasSize bannerCanvasSize = NAT.Utils.ConvertPixelsSizeToCanvasSize(GameObject.Find("Canvas").GetComponent<Canvas>(), bannerWidth, bannerHeight);

    Debug.Log("Banner size in Canvas is " + bannerCanvasSize.unitsWidth + "x" + bannerCanvasSize.unitsHeight + "!");
}
                    </code></doc.code>
                    <doc.warn>
                        The <doc.detach>ConvertPixelsSizeToCanvasSize()</doc.detach> method will return a size of <doc.detach>0</doc.detach> if the target <doc.detach>Canvas</doc.detach> component <doc.detach>Render Mode</doc.detach> is not
                        <doc.detach>Screen Space - Overlay</doc.detach>.
                    </doc.warn>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Get Device Notch Pixels Size -->
                <doc.topic topicid="105">
                    <doc.topictitle>Utils: Get Device Notch Pixels Size</doc.topictitle>

                    If you want to get the Notch size of the device, this method was created for that. That way you can use it to know where you can start designing your application's interface. This method will return the Notch size of the
                    device on each side of the screen, but if the device has no Notch, all sides will be zero, since each device has a Notch type and different sizes. Also, this method takes into account the current screen orientation of
                    the device at the time it is called, so if for example, the device has a Notch at the <doc.detach>TOP</doc.detach> of the screen that is 80 Pixels, and the device is in <doc.detach>LANDSCAPE</doc.detach>, this method
                    will report that the <doc.detach>LEFT/RIGHT</doc.detach> side of the device have a Notch with 80 Pixels and if the device is in <doc.detach>PORTRAIT</doc.detach>, this method will report that have a Notch on
                    <doc.detach>TOP/BOTTOM</doc.detach> and the size of the Notch is 80 Pixels.
                    <br>
                    <br>
                    To get the Notch size of the device, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- GetDeviceNotchPixelsSize();
    NAT.Utils.DeviceNotchSize notchSize = NAT.Utils.GetDeviceNotchPixelsSize();
    
    Debug.Log("Device Notch Sizes is... Top: " + notchSize.topPixelsSize + ", Bottom: " + notchSize.bottomPixelsSize +
                                     ", Left: " + notchSize.leftPixelsSize + ", Right: " + notchSize.rightPixelsSize);
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Opening Play Store In App Review -->
                <doc.topic topicid="106">
                    <doc.topictitle>Utils: Opening Play Store In App Review</doc.topictitle>

                    This method allows your app to open an interface for the user to rate your app on the Play Store without leaving your app. For this, when calling this method, a Google Services interface is opened and the user can leave
                    the review without leaving the application.
                    <br>
                    <br>
                    For this method to work, the user's device must support Google Play Services and have the Play Store installed. Your app also needs to be published on the Play Store for the interface to appear. To use this function, use
                    the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- OpenPlayStoreInAppReview();
    NAT.Utils.OpenPlayStoreInAppReview();
}
                    </code></doc.code>
                    The following guidelines also need to be followed to use this method...
                    <doc.list>
                        <doc.listr>Open this review interface after the user has used your app for a certain amount of time, for example 1 week or 3 days.</doc.listr>
                        <doc.listr>Does not excessively ask for user review.</doc.listr>
                        <doc.listr>Before showing this review interface, your app cannot ask the user things like "Would you rate this app 5 stars?" or "Are you enjoying the app?" and etc.</doc.listr>
                        <doc.listr>Google imposes a quota for displaying the Review interface, so calling this method more than once during a short period of time (for example 1 month) may result in it not being displayed to the user for a period of time.</doc.listr>
                        <doc.listr>It's important that you apply your own logic to the app and only display the review interface at strategic moments that enrich the user experience. You can show, for example, when the player is in his base, waiting for something to be ready.</doc.listr>
                        <doc.listr>You must maintain a button that redirects the user to the Play Store so that he can make a review, if the quota has been reached and this review interface is no longer being shown.</doc.listr>
                    </doc.list>
                    Not following the guidelines above or disrespecting them can be understood as an abuse of your application which can lead to punishments in the Google Play Store.
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>com.google.android.play.core.client (and its dependencies)=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Checking if Vibration is Available -->
                <doc.topic topicid="107">
                    <doc.topictitle>Utils: Checking if Vibration is Available</doc.topictitle>

                    To check if the device has hardware support for vibration, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isVibrationAvailable();
    bool vibrationAvailable = NAT.Utils.isVibrationAvailable();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Vibrate=>None=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Checking if Wi-Fi is Enabled -->
                <doc.topic topicid="108">
                    <doc.topictitle>Utils: Checking if Wi-Fi is Enabled</doc.topictitle>

                    To check if wifi is currently enabled, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isWifiEnabled();
    bool isWifiEnabled = NAT.Utils.isWifiEnabled();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Wifi State, Access Network State=>None=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Checking if is Connected to Wi-Fi -->
                <doc.topic topicid="109">
                    <doc.topictitle>Utils: Checking if is Connected to Wi-Fi</doc.topictitle>

                    To check if the device is connected to a wifi today, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isConnectedToWifi();
    bool isConnected = NAT.Utils.isConnectedToWifi();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Wifi State, Access Network State=>None=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Checking if is using Headset -->
                <doc.topic topicid="110">
                    <doc.topictitle>Utils: Checking if is using Headset</doc.topictitle>

                    To check if there is a headset connected to the device, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isUsingHeadset();
    bool isUsing = NAT.Utils.isUsingHeadset();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Checking if Internet is Available -->
                <doc.topic topicid="111">
                    <doc.topictitle>Utils: Checking if Internet is Available</doc.topictitle>

                    To check if there is an internet connection currently working on the device, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isInternetAvailable();
    bool isInternetOk = NAT.Utils.isInternetAvailable();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Wifi State, Access Network State=>None=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Checking if Developer Mode is enabled -->
                <doc.topic topicid="112">
                    <doc.topictitle>Utils: Checking if Developer Mode is enabled</doc.topictitle>

                    To check if the developer mode is activated on the device, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isDeveloperModeEnabled();
    bool isEnabled = NAT.Utils.isDeveloperModeEnabled();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Checking if Google Play Services is Available -->
                <doc.topic topicid="113">
                    <doc.topictitle>Utils: Checking if Google Play Services is Available</doc.topictitle>

                    To check if Google Play Services is installed and currently available on the device, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isGooglePlayServicesAvailable();
    bool isGmsAvailable = NAT.Utils.isGooglePlayServicesAvailable();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>com.google.android.gms.common (and its dependencies)=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Checking if Device is Rooted -->
                <doc.topic topicid="114">
                    <doc.topictitle>Utils: Checking if Device is Rooted</doc.topictitle>

                    To check if the device is rooted, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isDeviceRooted();
    bool isRooted = NAT.Utils.isDeviceRooted();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Utils: Checking if Anti-Screenshot is enabled -->
                <doc.topic topicid="115">
                    <doc.topictitle>Utils: Checking if Anti-Screenshot is enabled</doc.topictitle>

                    To check if the anti Screenshot and Screenrecording system of NAT is currently active, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isAntiScreenshotEnabled();
    bool isEnabled = NAT.Utils.isAntiScreenshotEnabled();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Settings: About This Class -->
                <doc.topic topicid="117">
                    <doc.topictitle>Settings: About This Class</doc.topictitle>

                    This class offers tools so that your application can open specific and native configuration screens of the Android system.
                    <doc.info>
                        It is a good idea to always warn the user what they need to do and why the settings are being open so that they understand why and what they need to do, instead of simply opening a window of settings.
                    </doc.info>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Settings: Open General Settings -->
                <doc.topic topicid="118">
                    <doc.topictitle>Settings: Open General Settings</doc.topictitle>

                    To open the general device settings, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- OpenGeneralSettings();
    NAT.Settings.OpenGeneralSettings();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Settings: Open This App Settings -->
                <doc.topic topicid="119">
                    <doc.topictitle>Settings: Open This App Settings</doc.topictitle>

                    To open the system settings regarding your application, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- OpenThisAppSettings();
    NAT.Settings.OpenThisAppSettings();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Settings: Open Wi-Fi Settings -->
                <doc.topic topicid="120">
                    <doc.topictitle>Settings: Open Wi-Fi Settings</doc.topictitle>

                    To open the wifi settings, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- OpenWifiSettings();
    NAT.Settings.OpenWifiSettings();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Settings: Open Bluetooth Settings -->
                <doc.topic topicid="121">
                    <doc.topictitle>Settings: Open Bluetooth Settings</doc.topictitle>

                    To open the bluetooth settings, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- OpenBluetoothSettings();
    NAT.Settings.OpenBluetoothSettings();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Settings: Open Location Settings -->
                <doc.topic topicid="122">
                    <doc.topictitle>Settings: Open Location Settings</doc.topictitle>

                    To open the localization settings, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- OpenLocationSettings();
    NAT.Settings.OpenLocationSettings();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Settings: Open Network Operator Settings -->
                <doc.topic topicid="123">
                    <doc.topictitle>Settings: Open Network Operator Settings</doc.topictitle>

                    To open the network operator settings, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- OpenNetworkOperatorSettings();
    NAT.Settings.OpenNetworkOperatorSettings();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Settings: Open Internet Toggle Settings -->
                <doc.topic topicid="124">
                    <doc.topictitle>Settings: Open Internet Toggle Settings</doc.topictitle>

                    This method opens a native system popup to enable a wifi connection or mobile data on Android Q or higher devices. But on devices less than Q, the default settings window opens.
                    <br>
                    <br>
                    To open the internet settings, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- OpenInternetToggleSettings();
    NAT.Settings.OpenInternetToggleSettings();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Location: About This Class -->
                <doc.topic topicid="126">
                    <doc.topictitle>Location: About This Class</doc.topictitle>

                    This class offers tracking and mapping tools. With this class your application will also be able to track the user device using GPS or Network in a very easy and intuitive way.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Location: Tracking the device using GPS or Network -->
                <doc.topic topicid="127">
                    <doc.topictitle>Location: Tracking the device using GPS or Network</doc.topictitle>

                    In this topic we will learn how to use Native Android Toolkit to track the device, whether using the device's GPS or Network. We will learn how to receive new locations and more.

                    <doc.topicsubtitle>The basic</doc.topicsubtitle>
                    Before we start, you need to understand that there are two ways to track the device. The first form is using the <doc.detach>Network</doc.detach>. Using the <doc.detach>Network</doc.detach> as a tracking form we will
                    have a very inaccurate location but close enough of the user to at least guess which city is. With <doc.detach>GPS</doc.detach> we have a very accurate tracking form, accurate enough to guess the city, neighborhood and
                    even the user street.
                    <br>
                    <br>
                    The difference between these two forms of tracking (besides accuracy) is the permissions that are needed for each. By tracking the user using <doc.detach>Network</doc.detach>, we need the
                    <doc.detach>Access Coarse Location</doc.detach> permission, and using <doc.detach>GPS</doc.detach>, we need the <doc.detach>Access Fine Location</doc.detach> and <doc.detach>Access Coarse Location</doc.detach>
                    permissions.
                    <doc.warn>
                        Keep in mind that if your application do not have the necessary permissions it will not be possible to track the device.
                    </doc.warn>

                    <doc.topicsubtitle>Requesting Permissions</doc.topicsubtitle>
                    If you plan to track user location through <doc.detach>GPS</doc.detach>, use the code below to request permission to the user.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    new NAT.Permissions.PermissionRequester()
        .addPermissionToRequest(NAT.Permissions.AndroidPermission.AccessCoarseLocation)
        .addPermissionToRequest(NAT.Permissions.AndroidPermission.AccessFineLocation)
        .RequestThisPermissions();
}
                    </code></doc.code>
                    And to check if your application already has the permission to track the device through <doc.detach>GPS</doc.detach>, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    bool havePermission = NAT.Permissions.isPermissionGuaranteed(NAT.Permissions.AndroidPermission.AccessFineLocation);
}
                    </code></doc.code>
                    Now, if you plan to track user location through <doc.detach>Network</doc.detach>, use the code below to request permission to the user.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    new NAT.Permissions.PermissionRequester()
        .addPermissionToRequest(NAT.Permissions.AndroidPermission.AccessCoarseLocation)
        .RequestThisPermissions();
}
                    </code></doc.code>
                    And to check if your application already has the permission to track the device through <doc.detach>Network</doc.detach>, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    bool havePermission = NAT.Permissions.isPermissionGuaranteed(NAT.Permissions.AndroidPermission.AccessCoarseLocation);
}
                    </code></doc.code>

                    <doc.topicsubtitle>Starting to track the Location of the device</doc.topicsubtitle>
                    Before we start tracking the user location, we have to check that the device Location is enabled (this can be done with method <doc.detach>isLocationEnabled()</doc.detach>). If it is not activated, you will not be able
                    to track the user's device, then you can ask the user to enable the Location of the device. In addition we also need to check if there is no tracking being done by NAT. If there is already a tracking being done, you
                    should stop it, as it is not possible to perform more than one track at the same time.
                    <br>
                    <br>
                    Then you must decide whether to use <doc.detach>GPS</doc.detach> or <doc.detach>Network</doc.detach> to track the device. Whatever you decide, all codes below work for <doc.detach>GPS</doc.detach> or
                    <doc.detach>Network</doc.detach> tracking. In the example below, we will use <doc.detach>GPS</doc.detach>, but if you intend to use the <doc.detach>Network</doc.detach>, just change the values where "GPS" below for
                    "Network".
                    <br>
                    <br>
                    To start tracking the user's device, we can use the following code...
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //Only start the Location if the Location is enabled in device, and not have another tracking running
    if (NAT.Location.isLocationEnabled(NAT.Location.LocationProvider.GPS) == true && NAT.Location.isTrackingLocation() == NAT.Location.LocationRunning.None)
    {
        //First, register the callbacks...
        
        //- onLocationChanged(currentProvider, newUpdatedLocalization)
        NATEvents.onLocationChanged += (NAT.Location.LocationProvider provider, NAT.Location.LocationData data) =>
        {
            Debug.Log("The Location of the device has been updated! Latidude: " + data.latitude + ", Longitude: " + data.longitude + ", isCache: " + data.isFirstAndCacheLocation);
        };
        //- onLocationProviderChanged(newProvider, isLocationEnabledNow)
        NATEvents.onLocationProviderChanged += (NAT.Location.LocationProvider provider, bool isEnabledNow) =>
        {
            Debug.Log("The Location provider has changed. The new provider is: " + provider + ". Is the Location still enabled? " + isEnabledNow);
        };
        
        //Second, call the code of the NAT C# API
        
        //- StartTrackingLocation(provider, allowMockProviders, updateTimeInterval, updateDistanceInterval);
        bool started = NAT.Location.StartTrackingLocation(NAT.Location.LocationProvider.GPS, false, NAT.Location.LocationUpdateTime.Each15Seconds, NAT.Location.LocationUpdateDistance.Each10Meters);
        
        if (started == false)
            Debug.LogError("The tracking was not started.");
    }
    if (NAT.Location.isLocationEnabled(NAT.Location.LocationProvider.GPS) == false)
        Debug.LogError("The Location of the device is disabled.");
    if (NAT.Location.isTrackingLocation() == NAT.Location.LocationRunning.GPS)
        Debug.LogError("The device GPS is already being tracked now.");
    if (NAT.Location.isTrackingLocation() == NAT.Location.LocationRunning.Network)
        Debug.LogError("The device Network is already being tracked now.");
}
                    </code></doc.code>
                    Basically, we need to register callbacks at tracking events so that we can receive location updates and so on. Then we need to call the <doc.detach>StartTrackingLocation()</doc.detach> method to start tracking. First
                    let's talk about the <doc.detach>StartTrackingLocation()</doc.detach> method.
                    <br>
                    <br>
                    Method <doc.detach>StartTrackingLocation()</doc.detach> is quite easy to understand, but there are two parameters called <doc.detach>updateTimeInterval</doc.detach> and <doc.detach>updateDistanceInterval</doc.detach>
                    that we can adjust to further improve GPS or Network tracking accuracy. Parameter <doc.detach>updateTimeInterval</doc.detach> allows you to define a time interval so that the location is updated while
                    parameter <doc.detach>updateDistanceInterval</doc.detach> allows you to define a distance interval so that whenever the user moves a quantity of meters from the last known distance the location is updated. These
                    parameters help increase tracking accuracy, but can increase battery consumption as well, so use carefully.
                    <br>
                    <br>
                    Now, talking about event <doc.detach>onLocationProviderChanged</doc.detach>. Event <doc.detach>onLocationProviderChanged</doc.detach> is quite simple, it allows your application to know whenever the location provider
                    changes or when the user activates or disables the Location of the device.
                    <br>
                    <br>
                    Event <doc.detach>onLocationChanged</doc.detach> is the main event here. This is why you will receive callback whenever the tracked location of the device is updated. In this event, you will receive the provider
                    that informed the location as well as all data regarding the new updated location. By receiving the new location of the device, you will receive a object of type <doc.detach>LocationData</doc.detach> that contains
                    several variables that contain information about the new location. In the table below you can see all these variables and what each one represents.
                    <doc.table>
                        <doc.tablecw>25%=>auto</doc.tablecw>
                        <doc.tablec>Variable=>Description</doc.tablec>
                        <doc.tabler>bearing=>It represents the current direction of the device, ie the current angle at which the device is turned (or looking). The value here is returned in degrees and always between 0 and 360. This value is unrelated to the orientation of the device.</doc.tabler>
                        <doc.tabler>bearingAccuracyInDegrees=>Informs the accuracy of the device's view of vision. <b>(This parameter only brings reliable values on Android 8.0 or higher.)</b></doc.tabler>
                        <doc.tabler>longitude=>It represents the longitude of the device, measured in degrees.</doc.tabler>
                        <doc.tabler>latitude=>It represents the latitude of the device, measured in degrees.</doc.tabler>
                        <doc.tabler>horizontalAccuracyInMeters=>It represents a meter radius related to horizontal accuracy (estimate) of the location.</doc.tabler>
                        <doc.tabler>verticalAccuracyInMeters=>It represents a meter radius related to vertical accuracy (estimate) of the location. <b>(This parameter only brings reliable values on Android 8.0 or higher.)</b></doc.tabler>
                        <doc.tabler>speedInMetersPerSecond=>It represents the speed of the device at the time the location was obtained. The speed is measured in meters per second.</doc.tabler>
                        <doc.tabler>speedAcurracyInMetersPerSecond=>It represents an estimate of device speed accuracy in meters. <b>(This parameter only brings reliable values on Android 8.0 or higher.)</b></doc.tabler>
                        <doc.tabler>fixTimeNanos=>It represents the time that this location was obtained, converted into <doc.detach>nanos</doc.detach>, but this representation is very reliable because it is based on a monotonic realtime clock of the system, which cannot be modified by the user. This parameter can be used to verify the validity of a location obtained, because if the value of this variable is greater than the last value obtained, it means that this location is more recent than the last, so it is valid.</doc.tabler>
                        <doc.tabler>timeMillis=>This does an <doc.detach>fixTimeNanos</doc.detach> like work but uses a time converted to <doc.detach>Unix millis</doc.detach>, and is based on the current satellite or device time (depending on the location provider), which may vary according to each satellite or according to the device itself (for example, if the user change the time of the device). Therefore, to perform location validity checks, prefer <doc.detach>fixTimeNanos</doc.detach>.</doc.tabler>
                        <doc.tabler>isMock=>This parameter represents an indicative that informs whether the current location is Mock or not. An Mock location is a false location that may have been forged by the device by other application if the Mock configuration is enabled on the device.</doc.tabler>
                        <doc.tabler>addressSubLocalityName=>This parameter usually returns the name of the neighborhood, province or sublocality in which the coordinate is located. This can return an empty value if it is unknown.</doc.tabler>
                        <doc.tabler>address0Name=>This parameter returns the address line 0 for the returned coordinate. If the address is unknown or inaccessible, this parameter will contain an empty value.</doc.tabler>
                        <doc.tabler>address1Name=>This parameter returns the address line 1 for the returned coordinate. If the address is unknown or inaccessible, this parameter will contain an empty value.</doc.tabler>
                        <doc.tabler>address2Name=>This parameter returns the address line 2 for the returned coordinate. If the address is unknown or inaccessible, this parameter will contain an empty value.</doc.tabler>
                        <doc.tabler>isFirstAndCacheLocation=>This parameter informs if the current location is the first location obtained since the beginning of the device tracking, or if it is an old location, which was stored in cache.</doc.tabler>
                        <doc.tabler>coordinates=>This parameter represents the values <doc.detach>longitude</doc.detach> and <doc.detach>latitude</doc.detach>, but converted into a Unity Vector2. This parameter is more inaccurate when compared to values <doc.detach>longitude</doc.detach> and <doc.detach>latitude</doc.detach> directly.</doc.tabler>
                    </doc.table>
                    <doc.info>
                        Method <doc.detach>isLocationEnabled()</doc.detach> will return <doc.detach>false</doc.detach> if your application does not have the necessary permission to use the device tracking.
                    </doc.info>

                    <doc.topicsubtitle>Checking if there is already a tracking being done</doc.topicsubtitle>
                    To check if there is already a tracking of the location of the device being done, you can use the <doc.detach>isTrackingLocation()</doc.detach> method. It is recommended that you always see if there is no longer a NAT
                    tracking being done, as Native Android Toolkit does not allow more than 1 tracking be done at the same time by your application. See the code below for example.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    bool isTracking = (NAT.Location.isTrackingLocation() != NAT.Location.LocationRunning.None) ? true : false;
}
                    </code></doc.code>

                    <doc.topicsubtitle>Cancel an active tracking</doc.topicsubtitle>
                    To cancel an active tracking, just use the code below! Any callbacks registered at location events will be removed automatically.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    if (NAT.Location.isTrackingLocation() != NAT.Location.LocationRunning.None)
    {
        //- StopTrackingLocation();
        bool stopped = NAT.Location.StopTrackingLocation();
        
        if (stopped == false)
            Debug.LogError("The tracking was not stopped.");
    }
}
                    </code></doc.code>

                    <doc.topicsubtitle>Checking if the Mock Location configuration is activated on the device</doc.topicsubtitle>
                    The Mock Location configuration allows the device to provide false location data to some applications. This false data may come from other applications or from the Android device. The purpose of Mock Location is to
                    enable the developer to provide false locations for the application he is developing, to test it, but when used by general users, this feature can be used by its users to provide false locations for your application.
                    <br>
                    <br>
                    This method allows you to make sure this Mock Location configuration is currently enabled or disabled on the user's device. It may be interesting that you use this method before you start tracking the user device
                    location, especially if your application is in production. If this method tells you that the Mock Location is disabled then you can start tracking the device. Use this as an additional safety layer.
                    <br>
                    <br>
                    To use this method use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isMockEnabled();
    bool isEnabled = NAT.Location.isMockEnabled();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Coarse Location and/or Access Fine Location=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Location: Opening Google Maps -->
                <doc.topic topicid="128">
                    <doc.topictitle>Location: Opening Google Maps</doc.topictitle>

                    In this topic you will learn how to configure Google Maps on Google Cloud so that it can be displayed within your application and also learn how to display and control Google Maps within your application, using Native
                    Android Toolkit.

                    <doc.topicsubtitle>Configuring Google Maps on Google Cloud</doc.topicsubtitle>
                    So you can display Google Maps on your application, first we need to get an API key on Google Cloud for Google Maps. So we will need to set up the Google Maps on Google Cloud on your account. See the steps below to learn
                    how to make this activation.
                    <doc.warn>
                        Note that Google Cloud is a service on demand that sells business access to Google APIs and may ask you to provide a credit card to access Google Maps related services. Google Maps has a free quota that is large
                        enough to perform tests and for few users to use. You will not be charged if you use Google Maps on your application without exceeding this quota. If your application is in production and many users will use Google
                        Maps, keep it in mind!
                    </doc.warn>
                    <doc.list isnumeric="true">
                        <doc.listr>
                            Visit the Google Cloud console at <a href="https://console.cloud.google.com" target="_blank">https://console.cloud.google.com</a>
                            <doc.list>
                                <doc.listr>If you already have a Google Cloud project for your app, select it to work.</doc.listr>
                        <doc.listr>If you don't have a Google Cloud project for your app, create a new project for your app and select it to work.</doc.listr>
                    </doc.list>
                    </doc.listr>
                    <doc.listr>Click on the 3 bar icon in the upper left corner of the Google Cloud homepage.</doc.listr>
                    <doc.listr>Click on "Apis and Services" &gt; "Library"</doc.listr>
                    <doc.listr>In the Service Library, select or search the "Maps SDK For Android" service and click it</doc.listr>
                    <doc.listr>
                        On the page that opens, for "Maps SDK for Android", click "Enable" and you will be taken to the management page of this service.
                        <doc.list>
                            <doc.listr>If you are not taken to the "Google Maps Platform" service page, then go back to <a href="https://console.cloud.google.com" target="_blank">https://console.cloud.google.com</a>, select your app project to work, click on the menu &gt; Apis and Services &gt; APIs and Activated Services &gt; Maps SDK for Android</doc.listr>
                    <doc.listr>You may need to enable revenue on your Google Cloud Account to continue. You will not be charged for anything unless you use a paid service.</doc.listr>
                    <doc.listr>After activating revenue, you may appear to you a dialogue asking what you want to do with Google Maps service. Fill out the form, but in the end there will be a "Activate all Google Maps APIs in this project" APIs. Leaving this option activated will make the Geolocation APIs, Routes and etc also be a member in your project. Just leave this option marked if you need.</doc.listr>
                    <doc.listr>You can enable quotas to limit the amount of map loading requests your API can make.</doc.listr>
                    </doc.list>
                    </doc.listr>
                    <doc.listr>If an API key is not created for you, click on the menu &gt; APIs and Services &gt; APIs and Activated Services &gt; Maps SDK for Android &gt; Credentials &gt; Create Credentials &gt; API Key.</doc.listr>
                    <doc.listr>With the API key created, you can see it on the "Credentials" tab of the "Google Maps Platform".</doc.listr>
                    <doc.listr>Copy your API key (it must look like that "AizasycZPRDEWZTHZCV3BBZ0PX8J076Cire5y4" and should not have spaces) and paste it in Native Android Toolkit Preferences in Tools &gt; MT Assets &gt; Native Android Toolkit &gt; Preferences &gt; Location &gt; Google Maps API Key</doc.listr>
                    <doc.listr>Click "Save Preferences" in the NAT Preference window and then the API key will be applied and saves to the NAT Core source code. This way your app can now open Google Maps using your Google Cloud API key!</doc.listr>
                    </doc.list>

                    <doc.topicsubtitle>Controlling Google Maps in your application</doc.topicsubtitle>
                    Before we learn how to open Google Maps, let's learn about the methods that control the map you can open from Google Maps in your application. We need to know what each method does before opening Google Maps so that we
                    can control it better as soon as it opens.
                    <br>
                    <br>
                    To check if Google Maps is currently open in your application, use the method below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isGoogleMapsOpen();
    bool isOpen = NAT.Location.isGoogleMapsOpen();
}
                    </code></doc.code>
                    To move the Google Maps camera, that is, put Google Maps in a position, use the method below and provide the desired location coordinate you want to display on Google Maps.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- MoveCameraOfGoogleMap(latitude, longitude, zoomLevel);
    NAT.Location.MoveCameraOfGoogleMap(37.42212710483604f, -122.0841061387679f, NAT.Location.GoogleMapsZoom.Streets);
}
                    </code></doc.code>
                    <doc.info>
                        Note that this method will only work if Google Maps is open and loaded!
                    </doc.info>
                    To add a marked to the map, use the code below.
                    <br>
                    <br>
                    Calling <doc.detach>AddMarkerOnGoogleMap()</doc.detach> and providing <doc.detach>True</doc.detach> to parameter <doc.detach>setAsSelected</doc.detach> so that it is selected, will cause other markers to be deselected as
                    it is only possible to select one marker at a time.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- AddMarkerOnGoogleMap(markerTitle, markerIcon, latitude, longitude, setAsSelected);
    NAT.Location.AddMarkerOnGoogleMap("Googleplex", NAT.Location.GoogleMapsMarker.MarkerDefault, 37.42212710483604f, -122.0841061387679f, true);
}
                    </code></doc.code>
                    <doc.info>
                        Note that this method will only work if Google Maps is open and loaded!
                    </doc.info>
                    To remove all map markers, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- RemoveAllMarkersOfGoogleMap();
    NAT.Location.RemoveAllMarkersOfGoogleMap();
}
                    </code></doc.code>
                    <doc.info>
                        Note that this method will only work if Google Maps is open and loaded!
                    </doc.info>

                    <doc.topicsubtitle>Opening Google Maps in your application</doc.topicsubtitle>
                    Finally, to open Google Maps on your application, you need to register the callbacks with Google Maps events and then call the <doc.detach>OpenGoogleMaps()</doc.detach> method to open the map. Be sure to check if there
                    is no Google Maps open in your application as it is not possible to open more than one instance at the same time. See the code below as an example!
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //Only open Google Maps if there is no longer an open
    if (NAT.Location.isGoogleMapsOpen() == false && NAT.Utils.isGooglePlayServicesAvailable() == true)
    {
        //First, register the callbacks...
        
        //- onGoogleMapsLoaded()
        NATEvents.onGoogleMapsLoaded += () =>
        {
            //Add the marker
            NAT.Location.AddMarkerOnGoogleMap("Googleplex", NAT.Location.GoogleMapsMarker.MarkerDefault, 37.42212710483604f, -122.0841061387679f, true);
            
            //Move the camera to Googleplex
            NAT.Location.MoveCameraOfGoogleMap(37.42212710483604f, -122.0841061387679f, NAT.Location.GoogleMapsZoom.Streets);
        };
        //- onGoogleMapsClick(clickLongitude, clickLatitude)
        NATEvents.onGoogleMapsClick += (double longitude, double latitude) =>
        {
            //Remove all markers, to reset
            NAT.Location.RemoveAllMarkersOfGoogleMap();
            
            //Add marker of the click
            NAT.Location.AddMarkerOnGoogleMap("Your Marker", NAT.Location.GoogleMapsMarker.Marker1, latitude, longitude, true);
        };
        //- onGoogleMapsClosed()
        NATEvents.onGoogleMapsClosed += () =>
        {
            Debug.Log("The Google Maps was closed!");
        };
        
        //Second, call the code of the NAT C# API
        
        //- OpenGoogleMaps(mapsTitle);
        NAT.Location.OpenGoogleMaps("My First Google Maps");
    }
}
                    </code></doc.code>
                    <doc.info>
                        Maps display will not work if the device does not support the Google Play Services or the services are not installed, enabled or supported.
                    </doc.info>
                    <doc.warn>
                        Warning: Your application may crash if you have not provided a Google Maps API Key in Native Android Toolkit Preferences!
                    </doc.warn>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>com.google.android.gms.maps (and its dependencies)=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Camera: About This Class -->
                <doc.topic topicid="137">
                    <doc.topictitle>Camera: About This Class</doc.topictitle>

                    The Camera class of the Native Android Toolkit allows your application to easily access the Camera of any Android device, whether it is recording videos, taking photos or reading QR codes or Barcodes.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Camera: Using the Camera to take Pictures, record Videos and Read Bar/QR Codes -->
                <doc.topic topicid="138">
                    <doc.topictitle>Camera: Using the Camera to take Pictures, record Videos and Read Bar/QR Codes</doc.topictitle>

                    With the Camera of the Native Android Toolkit you can program your application to access the device's Camera to take pictures, record videos or read codes. All this in a super easy and intuitive way with the use of
                    Events to know when the user has done something, like taking a picture. You can also customize the Camera that your application will open, in several ways. In this topic you will learn how to open a Camera in your
                    application to take pictures, record videos or read QR codes.

                    <doc.topicsubtitle>The basic</doc.topicsubtitle>
                    First of all, you should know that Camera from Native Android Toolkit is not compatible with devices running Android 4.4 or older. This is due to various Camera access limitations that existed on these older devices.
                    <br>
                    <br>
                    As the Native Android Toolkit's Camera API depends on some native Android libraries, and these are linked to Gradle, we need to make some settings in Native Android Toolkit Preferences. Open NAT Preferences and under the
                    <doc.detach>Main Preferences</doc.detach> category, enable the <doc.detach>Yes Generate New If Not Exists</doc.detach> option for the <doc.detach>Modify Gradle Properties</doc.detach> option. Keep the
                    <doc.detach>Enable Dex. Artif. Transf.</doc.detach> option disabled and then click <doc.detach>Save Preferences</doc.detach> to apply the changes. Ready. A file called <doc.detach>gradle.properties</doc.detach> was
                    generated in your project, if it already exists then this file was just modified to add an option to ensure that the NAT Cameras API is Gradle compatible with your project.

                    <doc.topicsubtitle>Requesting Permissions</doc.topicsubtitle>
                    Permissions are required for your application to be able to use Camera. Without them, the system will not allow access to the device's Camera, so you need to check if your application has access to such permission, if
                    not, you must request it for the user.
                    <br>
                    <br>
                    To request access to the device's Camera, to take Photos, record Videos and scan QR codes or Bar codes, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    new NAT.Permissions.PermissionRequester()
        .addPermissionToRequest(NAT.Permissions.AndroidPermission.Camera)
        .RequestThisPermissions();
}
                    </code></doc.code>
                    To check if your application has access to the Camera permission, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    bool havePermission = NAT.Permissions.isPermissionGuaranteed(NAT.Permissions.AndroidPermission.Camera);
}
                    </code></doc.code>
                    If you intend to use Camera to Record videos, you will ALSO need the Record Audio permission. To request it, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    new NAT.Permissions.PermissionRequester()
        .addPermissionToRequest(NAT.Permissions.AndroidPermission.RecordAudio)
        .RequestThisPermissions();
}
                    </code></doc.code>
                    Finally, to check if your application has the Record Audio permission, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    bool havePermission = NAT.Permissions.isPermissionGuaranteed(NAT.Permissions.AndroidPermission.RecordAudio);
}
                    </code></doc.code>
                    <doc.warn>
                        Note: Your app may crash if the user presses the "Take Photo" or "Record Video" button in the Camera interface, if your app does not have the necessary Camera permissions to complete the action.
                    </doc.warn>

                    <doc.topicsubtitle>Getting Started with the Camera</doc.topicsubtitle>
                    Once our application has the necessary permissions and the settings in the NAT Preferences to use the Camera are already done, we will need to use the <doc.detach>isCameraSupported()</doc.detach> method to check if the
                    device has Camera support and if the Camera is accessible on this device. This check should ALWAYS be done before trying to access the Camera in your application! See the code below for example...
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isCameraSupported();
    bool cameraSupported = NAT.Camera.isCameraSupported();
}
                    </code></doc.code>
                    <doc.warn>
                        The <doc.detach>isCameraSupported()</doc.detach> method will also return false if the settings in the NAT Preferences have not been made. Without Custom Gradle properties, NAT is not able to initialize Camera
                        internally, so it is not possible to open the Camera.
                    </doc.warn>
                    <doc.info>
                        The NAT camera comes from the CameraX API native of Android and maintained by Google, which performs several tests in laboratories to ensure the best possible compatibility between different types of devices from
                        different brands. As the Camera is a feature that can vary greatly from each device and brand implementation, there may come a time when a rare device may be incompatible with NAT Camera. That's why it's important
                        to use this method before calling the Camera to open.
                    </doc.info>
                    <doc.info>
                        For better and more compatibility between devices and native limitations, the Camera will always be displayed in Landscape orientation.
                    </doc.info>

                    <doc.topicsubtitle>Opening Camera to take photos</doc.topicsubtitle>
                    To open the Camera to take pictures, you must first register callbacks to the necessary events and then call the method to open the Camera. See the code below.
                    <br>
                    <br>
                    Note that the Camera will open in a Popup so as not to interrupt your application. Camera has its own interface for user interaction, in
                    which you can customize it. Note that the Camera interface will automatically close once a photo has been taken, although the user can close it before that too.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //Check if the device can open the Camera
    if (NAT.Camera.isCameraSupported() == true)
    {
        //First, register the callbacks...

        //- onCameraTakePhoto(photoTaken)
        NATEvents.onCameraTakePhoto += (Texture2D photo) =>
        {
            Debug.Log("The photo has been taked! The resolution is " + photo.width + " x " + photo.height + "!");
        };
        //- onCameraClose()
        NATEvents.onCameraClose += () =>
        {
            Debug.Log("The Camera was closed before the user took a picture.");
        };

        //Second, call the code of the NAT C# API

        new NAT.Camera.CameraNative(NAT.Camera.CameraMode.PhotoCamera, ScreenOrientation.AutoRotation)
            .setTitle("Photo Camera")
            .setEnableFlash(true)
            .setEnableSwitch(true)
            .setDefaultCamera(NAT.Camera.CameraType.BackCamera)
            .OpenThisCamera();
    }
    if (NAT.Camera.isCameraSupported() == false)
        Debug.LogError("Camera is not supported on this device!");
}
                    </code></doc.code>
                    <doc.info>
                        The Camera will take pictures based on a resolution equal to or close (when available) to the resolution in pixels of the device screen.
                    </doc.info>

                    <doc.topicsubtitle>Opening Camera to record videos</doc.topicsubtitle>
                    To open the Camera to record Videos, you must first register callbacks to the necessary events and then call the method to open the Camera. See the code below.
                    <br>
                    <br>
                    Note that the Camera will open in a Popup so as not to interrupt your application. Camera has its own interface for user interaction, in which you can customize it. Note that the Camera interface will automatically close
                    once the recording has finished, although the user can close it before that too (he can only close the camera if he has not started a recording yet).
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //Check if the device can open the Camera
    if (NAT.Camera.isCameraSupported() == true)
    {
        //First, register the callbacks...

        //- onCameraRecorded(resultVideoPath)
        NATEvents.onCameraRecorded += (string videoPath) =>
        {
            Debug.Log("The path for recorded video is " + videoPath);
        };
        //- onCameraClose()
        NATEvents.onCameraClose += () =>
        {
            Debug.Log("The Camera was closed before the user started record.");
        };

        //Second, call the code of the NAT C# API

        new NAT.Camera.CameraNative(NAT.Camera.CameraMode.VideoCamera, ScreenOrientation.AutoRotation)
            .setTitle("Video Camera")
            .setEnableFlash(true)
            .setEnableSwitch(true)
            .setDefaultCamera(NAT.Camera.CameraType.BackCamera)
            .setVideoCameraDesiredQuality(NAT.Camera.CameraVideoQuality.FullHD)
            .setMaxRecordingSeconds(120)   //<- 0 is infinite
            .OpenThisCamera();
    }
    if (NAT.Camera.isCameraSupported() == false)
        Debug.LogError("Camera is not supported on this device!");
}
                    </code></doc.code>
                    <doc.warn>
                        Note that to record videos with Camera you need <doc.detach>Camera</doc.detach> AND <doc.detach>Record Audio</doc.detach> permissions. If you try to open Camera to record videos without having these two permissions
                        granted to your application, it may crash.
                    </doc.warn>
                    <doc.info>
                        The <doc.detach>setVideoCameraDesiredQuality</doc.detach> method will not guarantee that the desired quality is what you have defined with certainty. Not every device or Camera can support the desired quality you
                        set, so if you set for example HD quality, and it is not supported by the device, a similar and close quality will be automatically set by the system.
                    </doc.info>
                    <doc.info>
                        You don't need file permissions to manipulate the result Video in the path returned by the recording finish event!
                    </doc.info>

                    <doc.topicsubtitle>Opening Camera to read Barcodes and QR Codes</doc.topicsubtitle>
                    To open the Camera to read codes, you must first register callbacks to the necessary events and then call the method to open the Camera. See the code below.
                    <br>
                    <br>
                    Note that the Camera will open in a Popup so as not to interrupt your application. Camera has its own interface for user interaction, in which you can customize it. Note that the Camera interface will automatically close
                    once a code is read, although the user can close it before that too.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //Check if the device can open the Camera
    if (NAT.Camera.isCameraSupported() == true)
    {
        //First, register the callbacks...

        //- onCameraReadCode(codeReaded)
        NATEvents.onCameraReadCode += (string result) =>
        {
            Debug.Log("The result of Scanned Code is " + result);
        };
        //- onCameraClose()
        NATEvents.onCameraClose += () =>
        {
            Debug.Log("The Camera was closed before read a code.");
        };

        //Second, call the code of the NAT C# API

        new NAT.Camera.CameraNative(NAT.Camera.CameraMode.CodeReader, ScreenOrientation.AutoRotation)
            .setTitle("Code Reader")
            .setCodeReaderMessage("Point to a Bar/QR Code and center it on the Screen")
            .OpenThisCamera();
    }
    if (NAT.Camera.isCameraSupported() == false)
        Debug.LogError("Camera is not supported on this device!");
}
                    </code></doc.code>
                    The NAT Camera is not limited to just reading QR Codes or Barcodes. See a list of all supported code formats...
                    <doc.list>
                        <doc.listr>
                            1D
                            <doc.list>
                                <doc.listr>UPC_A</doc.listr>
                        <doc.listr>UPC_E</doc.listr>
                        <doc.listr>EAN_8</doc.listr>
                        <doc.listr>EAN_13</doc.listr>
                        <doc.listr>UPC_EAN_EXTENSION</doc.listr>
                    </doc.list>
                    </doc.listr>
                    <doc.listr>
                            1D Industrial
                            <doc.list>
                                <doc.listr>CODE_39</doc.listr>
                    <doc.listr>CODE_93</doc.listr>
                    <doc.listr>CODE_128</doc.listr>
                    <doc.listr>CODABAR</doc.listr>
                    <doc.listr>ITF</doc.listr>
                    </doc.list>
                    </doc.listr>
                    <doc.listr>
                            2D
                            <doc.list>
                                <doc.listr>QR_CODE</doc.listr>
                    <doc.listr>DATA_MATRIX</doc.listr>
                    <doc.listr>AZTEC</doc.listr>
                    <doc.listr>PDF_417</doc.listr>
                    <doc.listr>MAXICODE</doc.listr>
                    <doc.listr>RSS_14</doc.listr>
                    <doc.listr>RSS_EXPANDED</doc.listr>
                    </doc.list>
                    </doc.listr>
                    </doc.list>
                    And the best of all. To use NAT Camera to read codes, the user device does NOT need code reader apps installed. Only the NAT Camera can read codes without problem, and without relying on installed third-party
                    applications in any way.
                    <doc.info>
                        As some devices have weaker hardware, they may need the user to rotate the device to Landscape so that the code can be read correctly or keep the Camera pointed towards the code for a little longer. This may not be
                        necessary on all devices that have weak hardware.
                    </doc.info>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Camera and Record Audio (optional)=>androidx.camera.camera2, androidx.camera.core, androidx.camera.view, androidx.camera.video, com.google.mlkit.vision.barcode, com.google.mlkit.vision.common (and its dependencies)=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Camera: Generate QR Code from String -->
                <doc.topic topicid="139">
                    <doc.topictitle>Camera: Generate QR Code from String</doc.topictitle>

                    To convert a String into a Texture2D of a QR Code, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- GetGeneratedQRCode(stringToBeEncoded);
    Texture2D resultQrCode = NAT.Camera.GetGeneratedQRCode("This is a simple text!");
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>com.google.zxing (and its dependencies)=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Microphone: About This Class -->
                <doc.topic topicid="144">
                    <doc.topictitle>Microphone: About This Class</doc.topictitle>

                    The Microphone class allows your application to have access to the device's microphone, in addition to offering tools related to this Hardware. With this class, for example, your application will be able to record the
                    device's audio, interpret speech, etc.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Microphone: Recording audio through Microphone -->
                <doc.topic topicid="145">
                    <doc.topictitle>Microphone: Recording audio through Microphone</doc.topictitle>

                    In this topic you will learn how to use this NAT class to record audio from the device's microphone. Follow all the next subtopics to delve deeper into this topic.

                    <doc.topicsubtitle>The basic</doc.topicsubtitle>
                    In order for you to start recording device audio, your application needs to have the <doc.detach>Record Audio</doc.detach> permission granted by the user. That's why you should first check if your application has this
                    permission. If not, you must request it from the user.
                    <br>
                    <br>
                    The next step then is to check if the device supports Microphone. So if all this is guaranteed, you can start recording the audio from the device. Continue reading the next topics.

                    <doc.topicsubtitle>Requesting Permissions</doc.topicsubtitle>
                    As mentioned in the last topic, permission to access the Microphone is mandatory for your application to be able to record audio from the user's device. Without it, the recording API will not work, as the system will not
                    grant access to the Microphone for your application.
                    <br>
                    <br>
                    To request microphone access permission for the user, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    new NAT.Permissions.PermissionRequester()
        .addPermissionToRequest(NAT.Permissions.AndroidPermission.RecordAudio)
        .RequestThisPermissions();
}
                    </code></doc.code>
                    To check if your application has access to the Microphone, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    bool havePermission = NAT.Permissions.isPermissionGuaranteed(NAT.Permissions.AndroidPermission.RecordAudio);
}
                    </code></doc.code>

                    <doc.topicsubtitle>Checking if device supports Microphone</doc.topicsubtitle>
                    It is extremely important to check if the device has Microphone hardware support as this method will check if the Microphone is available and supported by the device. Therefore, before starting to work with the
                    Microphone, always carry out this check. See the code below for example.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isMicrophoneSupported();
    bool microphoneSupported = NAT.Microphone.isMicrophoneSupported();
}
                    </code></doc.code>
                    <doc.warn>
                        Note that this method will return false if your application does not have Record Audio permission. Furthermore, this method can also return false if the microphone is already very busy with another job or
                        application.
                    </doc.warn>

                    <doc.topicsubtitle>Starting to record device audio</doc.topicsubtitle>
                    Before starting to record audio from the device, you should in addition to making sure that your application has permission to access the Microphone, you should also verify that the device supports the Microphone and
                    that there is not already an audio recording currently being made. Then you must register the callback in the recording event and then call the recording start method. See the example below.
                    <br>
                    <br>
                    NAT will not allow more than one recording to happen at the same time.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //Checks if the device supports microphone and if there is already a recording taking place
    if (NAT.Microphone.isMicrophoneSupported() == true && NAT.Microphone.isRecordingMicrophone() == false)
    {
        //First, register the callbacks...

        //- onMicrophoneStopRecording(resultAudioPath)
        NATEvents.onMicrophoneStopRecording += (string audioPath) =>
        {
        Debug.Log("Recording is complete. The path for audio file is " + audioPath);
        };

        //Second, call the code of the NAT C# API

        //- StartRecordingMicrophone();
        NAT.Microphone.StartRecordingMicrophone();
    }
    if (NAT.Microphone.isMicrophoneSupported() == false)
        Debug.LogError("Microphone is not supported.");
    if (NAT.Microphone.isRecordingMicrophone() == true)
        Debug.LogError("There is already a recording being made.");
}
                    </code></doc.code>
                    <doc.warn>
                        It is recommended that your application is not using the Microphone in other jobs (such as Video, Speech-To-Text and others) at the time it starts recording, to avoid possible problems.
                    </doc.warn>
                    <doc.info>
                        By default, recordings made by the Native Android Toolkit are in AAC format, with a bitrate of 96000 and a sample rate of 44100.
                    </doc.info>
                    <doc.info>
                        You don't need file permissions to manipulate the result Audio in the path returned by the recording finish event!
                    </doc.info>

                    <doc.topicsubtitle>Checking if a recording is in progress</doc.topicsubtitle>
                    To check if there is a recording in progress, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isRecordingMicrophone();
    bool isRecording = NAT.Microphone.isRecordingMicrophone();
}
                    </code></doc.code>
                    <doc.info>
                        Note that this method only refers to recordings made by the Native Android Toolkit, using the <doc.detach>StartRecordingMicrophone()</doc.detach> method. This method does not detect recordings being made by other
                        applications or plugins.
                    </doc.info>

                    <doc.topicsubtitle>Stopping a recording in progress</doc.topicsubtitle>
                    To stop a recording in progress, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //Check if have a recording in progress
    if (NAT.Microphone.isRecordingMicrophone() == true)
    {
        //- StopRecordingMicrophone();
        NAT.Microphone.StopRecordingMicrophone();
    }
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Record Audio=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Microphone: Using the Speech-To-Text -->
                <doc.topic topicid="146">
                    <doc.topictitle>Microphone: Using the Speech-To-Text</doc.topictitle>

                    In this topic you will learn how to use this class to use the Speech-To-Text of the Android system. That is, the user will be able to say something close to the device's Microphone, the device itself will listen to the
                    user speaking and the speech will pass through the device speech recognition engine, so your application will receive a String with the content that was spoken by the user. And it even works with automatic language
                    recognition, without the need to set a language programmatically.

                    <doc.topicsubtitle>The basic</doc.topicsubtitle>
                    First, In order for the Native Android Toolkit to be able to query and communicate with the device speech recognition engine, you need to apply a setting in the NAT Preferences. To do so, open the Preferences and then
                    go to the <doc.detach>NAT Core Library</doc.detach> category. In the <doc.detach>Enable Package Queries</doc.detach> option, choose <doc.detach>Yes</doc.detach>. Now just click on
                    <doc.detach>Save Preferences</doc.detach> to apply the configuration.
                    <br>
                    <br>
                    In order for you to use Speech-To-Text, your application needs to have the <doc.detach>Record Audio</doc.detach> permission granted by the user. That's why you should first check if your application has this permission.
                    If not, you must request it from the user.
                    <br>
                    <br>
                    The next step then is to check if the device supports Microphone and whether it supports speech recognition. So if all this is guaranteed, you can start Speech-To-Text of device. Continue reading the next topics so that
                    you understand how to do all this.

                    <doc.topicsubtitle>Requesting Permissions</doc.topicsubtitle>
                    As mentioned in the last topic, permission to access the Microphone is mandatory for your application to be able to use Speech-To-Text. Without it, the recording API will not work, as the system will not grant access to
                    the Microphone for your application.
                    <br>
                    <br>
                    To request microphone access permission for the user, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    new NAT.Permissions.PermissionRequester()
        .addPermissionToRequest(NAT.Permissions.AndroidPermission.RecordAudio)
        .RequestThisPermissions();
}
                    </code></doc.code>
                    To check if your application has access to the Microphone, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    bool havePermission = NAT.Permissions.isPermissionGuaranteed(NAT.Permissions.AndroidPermission.RecordAudio);
}
                    </code></doc.code>

                    <doc.topicsubtitle>Checking if device supports Microphone</doc.topicsubtitle>
                    It is extremely important to check if the device has Microphone hardware support as this method will check if the Microphone is available and supported by the device. Therefore, before starting to work with the
                    Microphone, always carry out this check. See the code below for example.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isMicrophoneSupported();
    bool microphoneSupported = NAT.Microphone.isMicrophoneSupported();
}
                    </code></doc.code>
                    <doc.warn>
                        Note that this method will return false if your application does not have Record Audio permission. Furthermore, this method can also return false if the microphone is already very busy with another job or
                        application.
                    </doc.warn>

                    <doc.topicsubtitle>Checking if Speech-To-Text is supported by the device</doc.topicsubtitle>
                    To check if speech recognition is supported by the device, we use the following code.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isSpeechToTextSupported();
    bool speechToTextSupported = NAT.Microphone.isSpeechToTextSupported();
}
                    </code></doc.code>
                    <doc.warn>
                        If <doc.detach>Enable Package Queries</doc.detach> in the NAT Preferences is <doc.detach>No</doc.detach>, this method will always return false.
                    </doc.warn>

                    <doc.topicsubtitle>Using Speech-To-Text</doc.topicsubtitle>
                    Once you have the NAT Preferences already configured, have the Microphone access permission, checked if the device supports Microphone and speech recognition, you can use this method. Then you just need to register the
                    callbacks to the required events and then call the method to start speech recognition. To use Speech-To-Text (speech recognition) in your application, use the code below. Note that speech recognition, once started, is
                    controlled by the system, so recognition will stop automatically as soon as the system notices that the user has stopped speaking.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //Checks that the microphone is supported, that speech recognition is supported, and that it is already listening to speech
    if (NAT.Microphone.isMicrophoneSupported() == true && NAT.Microphone.isSpeechToTextSupported() == true && NAT.Microphone.isListeningSpeechToText() == false)
    {
        //First, register the callbacks...
        
        //- onMicrophoneSpeechToTextStarted
        NATEvents.onMicrophoneSpeechToTextStarted += () =>
        {
            Debug.Log("The user began to be heard.");
        };
        //- onMicrophoneSpeechToTextFinished(responseStatus, responseText)
        NATEvents.onMicrophoneSpeechToTextFinished += (NAT.Microphone.SpeechToTextResult result, string textResult) =>
        {
            //If error
            if (result != NAT.Microphone.SpeechToTextResult.NoError)
                Debug.Log("Error on listen!");
            
            //If success
            if (result == NAT.Microphone.SpeechToTextResult.NoError)
                Debug.Log("Listened is: " + textResult + "!");
        };
        
        //Second, call the code of the NAT C# API
        
        //- StartListeningSpeechToText();
        NAT.Microphone.StartListeningSpeechToText();
    }
    if (NAT.Microphone.isMicrophoneSupported() == false)
        Debug.LogError("The device does not support Microphone.");
    if (NAT.Microphone.isSpeechToTextSupported() == false)
        Debug.LogError("The device does not support Speech-To-Text.");
    if (NAT.Microphone.isListeningSpeechToText() == true)
        Debug.LogError("The device is already listening to the user.");
}
                    </code></doc.code>
                    <doc.warn>
                        It is recommended that your application is not using the Microphone in other jobs (such as Video, Audio Recording and others) at the time it starts recording, to avoid possible problems.
                    </doc.warn>

                    <doc.topicsubtitle>Checking if Speech-To-Text is in use</doc.topicsubtitle>
                    To check if Speech-To-Text is currently in use and if the user is being heard, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isListeningSpeechToText();
    bool isHearing = NAT.Microphone.isListeningSpeechToText();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Record Audio=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Applications: About This Class -->
                <doc.topic topicid="153">
                    <doc.topictitle>Applications: About This Class</doc.topictitle>

                    This class allows your application to interact with other applications installed on the user's device, it also allows your application to make queries, etc.

                    <doc.topicsubtitle>Action Required</doc.topicsubtitle>
                    If you intend to use this class to interact with other applications, like opening a certain application by sending parameters, checking if the application is installed, etc. You need to take action. This happens because
                    the Android system imposes a series of limitations to preserve the security and privacy of each application installed on the user's device. Therefore, to use the methods of this class, you need to know the
                    <doc.detach>Package Name</doc.detach> of each application with which your application will interact.

                    <doc.topicsubtitle>What do I need to do?</doc.topicsubtitle>
                    First, you need to change option <doc.detach>Enable Package Queries</doc.detach> to <doc.detach>Yes</doc.detach> in NAT Preferences.
                    <doc.image src="DocumentationFiles/images/91"></doc.image>
                    Now go to the <doc.detach>Applications</doc.detach> category and then add the <doc.detach>Package Name</doc.detach> of each application that your application intends to interact with. For example, if your application
                    intends to open or check if the <doc.detach>Facebook</doc.detach> application is installed on device, then add the Facebook <doc.detach>com.facebook.katana</doc.detach> to the
                    <doc.detach>Queries Visible Packages</doc.detach>.
                    <br>
                    <br>
                    The <doc.detach>Queries Visible Packages</doc.detach> is an area of the Native Android Toolkit where you can tell the <doc.detach>Package Name</doc.detach> of all the applications your application intends to interact
                    with. That's why you need to know the <doc.detach>Package Name</doc.detach> of each application your application will interact with.
                    <doc.image src="DocumentationFiles/images/92"></doc.image>
                    <doc.warn>
                        If you don't do this, your app will NOT be able to interact with the other app you want!
                    </doc.warn>

                    <doc.topicsubtitle>What if I want to interact with ALL apps installed on the user device?</doc.topicsubtitle>
                    If your application is going to interact with ANY application on the user device, there is no way for you to know the <doc.detach>Package Name</doc.detach> of every application installed on the user device. So you can
                    enable <doc.detach>Query All Packages</doc.detach> permission in NAT Preferences. By enabling this permission, your application will be able to interact with any application installed on the user's device, even without
                    placing the application's <doc.detach>Package Name</doc.detach> in the NAT Preferences.
                    <br>
                    <br>
                    But note that the <doc.detach>Query All Packages</doc.detach> permission is a permission considered very dangerous by Google Play. Google Play will only accept your app with this permission enabled if the core
                    functionality or one of your app core functionality requires a broad view of the user's app inventory. Still, there are reports on the Internet of people who, even with their applications having these characteristics,
                    were refused. <b>Be careful with this permission.</b>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Applications: Check if a Application is installed -->
                <doc.topic topicid="154">
                    <doc.topictitle>Applications: Check if a Application is installed</doc.topictitle>

                    To check if an application is installed on the user's device, you must use the code below, informing the <doc.detach>Package Name</doc.detach> of the application to be interacted with.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isApplicationInstalled(appPackageName);
    bool isInstalled = NAT.Applications.isApplicationInstalled("com.google.android.youtube");
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Applications: Open a Application -->
                <doc.topic topicid="155">
                    <doc.topictitle>Applications: Open a Application</doc.topictitle>

                    To open an application installed on the user's device, you must use the code below, informing the <doc.detach>Package Name</doc.detach> of the application to be interacted with.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- OpenApplication(appPackageName);
    NAT.Applications.OpenApplication("com.google.android.youtube");
}
                    </code></doc.code>
                    <doc.warn>
                        Before calling this method, always use <doc.detach>isApplicationInstalled()</doc.detach> to verify that the application is installed on the user's device.
                    </doc.warn>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Applications: Open a Application With Parameters -->
                <doc.topic topicid="156">
                    <doc.topictitle>Applications: Open a Application With Parameters</doc.topictitle>

                    If you need to open another application, but need to pass parameters to that application, this is the method to use. You must use the code below, informing the <doc.detach>Package Name</doc.detach> of the application
                    to be interacted with.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- new NAT.Applications.OpenApplicationWithExtras(appPackageName)
    new NAT.Applications.OpenApplicationWithExtras("com.google.android.youtube")
        .putExtra("key", "value")
        .putExtra("screen", "register")
        .OpenTheApplicationNow();
}
                    </code></doc.code>
                    In the other application, in the main Activity (launcher Activity) that will be opened in the other application, it must have a code to receive the parameters sent by your application. See the example below written in
                    <doc.detach>Java</doc.detach> that is in the <doc.detach>onCreate()</doc.detach> method of the main Activity to be opened in the other application, and that receives the parameters sent by you.
                    <doc.code language="java"><code>
@Override
protected void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    Intent intent = getIntent();   //<- Get the intent that started this application from C# code of your Unity Application with NAT

    if (intent.hasExtra("my_extra_key")) {
      String sharedText = intent.getStringExtra("my_extra_key");    //<- Get the String value of the key of Extra sended by C# code of your Unity Application with NAT
      Log.w("TextFromApp1", "This is the text passed by the Unity Application: " + sharedText);
    }

}
                    </code></doc.code>
                    <doc.warn>
                        Before calling this method, always use <doc.detach>isApplicationInstalled()</doc.detach> to verify that the application is installed on the user's device.
                    </doc.warn>
                    <doc.info>
                        Note: You can only send parameters of type <doc.detach>String</doc.detach> to other applications!
                    </doc.info>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Applications: Get this Application Package Name -->
                <doc.topic topicid="157">
                    <doc.topictitle>Applications: Get this Application Package Name</doc.topictitle>

                    To get the <doc.detach>Package Name</doc.detach> of your application, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- GetThisApplicationPackageName();
    string appPackageName = NAT.Applications.GetThisApplicationPackageName();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Applications: Check if Play Store is available -->
                <doc.topic topicid="158">
                    <doc.topictitle>Applications: Check if Play Store is available</doc.topictitle>

                    To find out if the Play Store is installed and available on the user's device, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isPlayStoreAvailable();
    bool isPlayStoreAvailable = NAT.Applications.isPlayStoreAvailable();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Applications: Open Application in Play Store -->
                <doc.topic topicid="159">
                    <doc.topictitle>Applications: Open Application in Play Store</doc.topictitle>

                    To open an app, in the Play Store, you must use the code below, informing the <doc.detach>Package Name</doc.detach> of the application to be interacted with.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- OpenApplicationInPlayStore(appPackageName);
    NAT.Applications.OpenApplicationInPlayStore("com.google.android.youtube");
}
                    </code></doc.code>
                    <doc.warn>
                        Before trying to open an app from the Play Store, always use the <doc.detach>isPlayStoreAvailable()</doc.detach> method to make sure the Play Store is available on the user device.
                    </doc.warn>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Date Time: About This Class -->
                <doc.topic topicid="161">
                    <doc.topictitle>Date Time: About This Class</doc.topictitle>

                    This class offers tools so your application can work with time. In addition, it also provides several uses for your application to get times, such as NTP internet time, time selection or date using the default
                    system popup, know how long the application has been closed and so on.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Date Time: Calendar Util Class -->
                <doc.topic topicid="162">
                    <doc.topictitle>Date Time: Calendar Util Class</doc.topictitle>

                    Native Android Toolkit <doc.detach>Calendar</doc.detach> class is a class created to make it easier to manipulate date and time in your programming logic in your application. It is a class written entirely in C# and that
                    does not depend on any native Android code, but was completely written as a utils class for Native Android Toolkit users.
                    <br>
                    <br>
                    As stated, the purpose of this class is to facilitate calculation operations involving date and time. In addition, class <doc.detach>Calendar</doc.detach> acts as an elegant date and time storage, whether in conventional
                    format, <doc.detach>Ticks</doc.detach> or <doc.detach>Unix Millis</doc.detach>.
                    <br>
                    <br>
                    You can for example, create the <doc.detach>Calendar</doc.detach> class with Unix Time, manually defined, you can serialize or desiccate a date contained in an <doc.detach>Calendar</doc.detach> object, you can subtract
                    or add more time to an <doc.detach>Calendar</doc.detach> object, get this formatted time in String automatically, Set new times, add or subtract time to a <doc.detach>Calendar</doc.detach> object, without the need to
                    create a new <doc.detach>Calendar</doc.detach> object and more!

                    <doc.topicsubtitle>How to use the Calendar class?</doc.topicsubtitle>
                    It's quite simple! All you need to do is instantiate a type <doc.detach>Calendar</doc.detach> object and then start using the methods provided by this class! See a small example...
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //Instantiating the class with the time 15:32:00 2022/12/23
    NAT.DateTime.Calendar currentTime = new NAT.DateTime.Calendar(2022, 12, 23, 15, 32, 0);
    
    //Adding hours
    currentTime.IncreaseThisIn(5, NAT.DateTime.TimeSpanValue.Hours);
    
    //Obtaining the time in String, auto-formatted for 2 digits
    Debug.Log("Current Time is " + currentTime.HourString + ":" + currentTime.MinuteString);
}
                    </code></doc.code>
                    See the forms of instance an object of class <doc.detach>Calendar</doc.detach>.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //Create the variable
    NAT.DateTime.Calendar currentTime = null;
    
    //Instantiating the class with the current local time, of the System
    currentTime = new NAT.DateTime.Calendar();
    
    //Instantiating the class with the Unix Millis time
    currentTime = new NAT.DateTime.Calendar(1670717356000);
    
    //Instantiating the class with a custom hour
    currentTime = new NAT.DateTime.Calendar(2020, 08, 15, 12, 17, 0);
    
    //Instantiating the class with another Calendar class
    currentTime = new NAT.DateTime.Calendar(new NAT.DateTime.Calendar());
}
                    </code></doc.code>
                    <doc.warn>
                        When instantiating the <doc.detach>Calendar</doc.detach> class you must always be inserted Local times, never UTC times. The <doc.detach>Calendar</doc.detach> class uses Local dates and hours to do the time
                        manipulations and operations in its internal code. However, when you will redeem the time of a <doc.detach>Calendar</doc.detach> class you will always have an option to redeem time in Local format or automatically
                        converted to UTC!
                    </doc.warn>
                    See below, a table that contains all the parameters and methods of the <doc.detach>Calendar</doc.detach> class, as well as a description of each. So you can know everything you can do with this class.
                    <doc.table>
                        <doc.tablecw>25%=>8%=>auto</doc.tablecw>
                        <doc.tablec>Element=>Type=>Description</doc.tablec>
                        <doc.tabler>Year=>PROPERTY=>Returns the Years of this object. Formatted as a number.</doc.tabler>
                        <doc.tabler>Month=>PROPERTY=>Returns the Months of this object. Formatted as a number.</doc.tabler>
                        <doc.tabler>Day=>PROPERTY=>Returns the Days of this object. Formatted as a number.</doc.tabler>
                        <doc.tabler>Hour=>PROPERTY=>Returns the Hours of this object. Formatted as a number.</doc.tabler>
                        <doc.tabler>Minute=>PROPERTY=>Returns Minutes year of this object. Formatted as a number.</doc.tabler>
                        <doc.tabler>Second=>PROPERTY=>Returns the Seconds of this object. Formatted as a number.</doc.tabler>
                        <doc.tabler>YearString=>PROPERTY=>Returns the Years of this object. Formatted as a string.</doc.tabler>
                        <doc.tabler>MonthString=>PROPERTY=>Returns the Months of this object. Formatted as a string. If the value is less than 10, a 0 is added at the front.</doc.tabler>
                        <doc.tabler>DayString=>PROPERTY=>Returns the Days of this object. Formatted as a string. If the value is less than 10, a 0 is added at the front.</doc.tabler>
                        <doc.tabler>HourString=>PROPERTY=>Returns the Hours of this object. Formatted as a string. If the value is less than 10, a 0 is added at the front.</doc.tabler>
                        <doc.tabler>MinuteString=>PROPERTY=>Returns the Minutes of this object. Formatted as a string. If the value is less than 10, a 0 is added at the front.</doc.tabler>
                        <doc.tabler>SecondString=>PROPERTY=>Returns the Seconds of this object. Formatted as a string. If the value is less than 10, a 0 is added at the front.</doc.tabler>
                        <doc.tabler>GetUnixMillisTime=>METHOD=>Obtain the time of this object, converted to Unix Millis.</doc.tabler>
                        <doc.tabler>GetThisCalendarTicks=>METHOD=>Obtain the time of this object, converted to Ticks.</doc.tabler>
                        <doc.tabler>GetDateTime=>METHOD=>Get the time of this object, converted to C# DateTime.</doc.tabler>
                        <doc.tabler>GetTimeSpan=>METHOD=>Get the time of this object, converted to C# TimeSpan.</doc.tabler>
                        <doc.tabler>SerializeToString=>METHOD=>Get the time of this object, but Serialized for a string that can be saved and later read again by a Calendar object, restoring that time that was saved.</doc.tabler>
                        <doc.tabler>DeserializeFromString=>METHOD=>Deserialize a time that has been Serialized for string format by another Calendar object in another moment, thus restoring the time.</doc.tabler>
                        <doc.tabler>IncreaseThisIn=>METHOD=>Increases the time of this object using the preference unit.</doc.tabler>
                        <doc.tabler>DecreaseThisIn=>METHOD=>Decreases the time of this object using the preference unit.</doc.tabler>
                        <doc.tabler>IncreaseThisWithDate=>METHOD=>Increases the time of this object using another Calendar object.</doc.tabler>
                        <doc.tabler>DecreaseThisWithDate=>METHOD=>Decreases the time of this object using another Calendar object.</doc.tabler>
                        <doc.tabler>SetThisToZero=>METHOD=>Defines the time of this object as zero.</doc.tabler>
                        <doc.tabler>SetThisToCurrentSystemDateTime=>METHOD=>Defines the time of this object as the current and Local system time.</doc.tabler>
                        <doc.tabler>isEqualsToZero=>METHOD=>Check if the time of this object is zero.</doc.tabler>
                        <doc.tabler>isEqualTo=>METHOD=>Compare this object with another Calendar object. Check if it is equal to another Calendar object.</doc.tabler>
                        <doc.tabler>isNotEqualTo=>METHOD=>Compare this object with another Calendar object. Check if it is different from another Calendar object.</doc.tabler>
                        <doc.tabler>isGreaterThan=>METHOD=>Compare this object with another Calendar object. Check if it is greater than another Calendar object.</doc.tabler>
                        <doc.tabler>isLessThan=>METHOD=>Compare this object with another Calendar object. Check if it is less than another Calendar object.</doc.tabler>
                        <doc.tabler>isGreaterThanOrEqualTo=>METHOD=>Compare this object with another Calendar object. Checks whether it is greater or equal to another Calendar object.</doc.tabler>
                        <doc.tabler>isLessThanOrEqualTo=>METHOD=>Compare this object with another Calendar object. Checks whether it is less or equal to another Calendar object.</doc.tabler>
                    </doc.table>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Date Time: Open Hour Picker -->
                <doc.topic topicid="163">
                    <doc.topictitle>Date Time: Open Hour Picker</doc.topictitle>

                    To open a native Android system dialogue so that the user can select a hour and minutes, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //First, register the callbacks...
    
    //- onDateTimeHourPicked(hourPicked)
    NATEvents.onDateTimeHourPicked += (NAT.DateTime.Calendar hourPicked) =>
    {
        Debug.Log("The Hour picked is " + hourPicked.HourString + ":" + hourPicked.MinuteString + "!");
    };
    
    //Second, call the code of the NAT C# API
    
    //- OpenHourPicker(dialogTitle);
    NAT.DateTime.OpenHourPicker("Select a Hour");
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Date Time: Open Date Picker -->
                <doc.topic topicid="164">
                    <doc.topictitle>Date Time: Open Date Picker</doc.topictitle>

                    To open a native Android system dialogue so that the user can select a date, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //First, register the callbacks...

    //- onDateTimeDatePicked(datePicked)
    NATEvents.onDateTimeDatePicked += (NAT.DateTime.Calendar datePicked) =>
    {
        Debug.Log("The Date picked is " + datePicked.MonthString + "/" + datePicked.DayString + "/" + datePicked.YearString + "!");
    };

    //Second, call the code of the NAT C# API

    //- OpenDatePicker(dialogTitle, minDateRange, maxDateRange);
    NAT.DateTime.OpenDatePicker("Select a Date", new NAT.DateTime.Calendar(2022, 1, 1, 0, 0, 0), new NAT.DateTime.Calendar(2022, 12, 31, 0, 0, 0));
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Date Time: Load Current Time of NTP Server -->
                <doc.topic topicid="165">
                    <doc.topictitle>Date Time: Load Current Time of NTP Server</doc.topictitle>

                    To get the current time through the internet using the NTP protocol, use the code below.
                    <br>
                    <br>
                    You can configure up to 5 NTPs servers to be used by this method in NAT Preferences. With each call to this method, the NAT will use one of these 5 servers randomly to better distribute the requests to the servers. If
                    one fails, the next of list is tempted and so on. If the 5 fail, then the event will report that there was no success when load the time.
                    <br>
                    <br>
                    Note that if there is no internet access, the event will report that there was no success when obtaining the time.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //First, register the callbacks...

    //- onDateTimeDoneNTPRequest(isSuccessfully, timeReceivedFromNtp, serverThatHaveSendedTime)
    NATEvents.onDateTimeDoneNTPRequest += (bool succesfully, NAT.DateTime.Calendar timeReceived, string responseServer) =>
    {
        //If error
        if (succesfully == false)
            Debug.Log("There was an error getting the time from the NTP server");

        //If success
        if (succesfully == true)
            Debug.Log("This was the time taken from the NTP server " + timeReceived.MonthString + "/" + timeReceived.DayString + "/" + timeReceived.YearString + " " + timeReceived.HourString + ":" + timeReceived.MinuteString + "!");
    };

    //Second, call the code of the NAT C# API

    //- LoadCurrentTimeOfNTP();
    NAT.DateTime.LoadCurrentTimeOfNTP();
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Date Time: Get Elapsed Realtime Since Boot -->
                <doc.topic topicid="166">
                    <doc.topictitle>Date Time: Get Elapsed Realtime Since Boot</doc.topictitle>

                    You can get the total device activity time. This time is called as "time since the device boot". It is a clock that measures the elapsed time since the device has been turned on, and it is a clock that works in realtime.
                    It continues to run normally WITHOUT ANY interruption, even if the device is in deep sleep. In addition, it is a clock that cannot be changed by the User, such as the default system clock the user can change time in the
                    settings. In addition, this clock is monotonic, ie it does not jump forward or back like when there is summer time for example.
                    <br>
                    <br>
                    All of these characteristics make this clock a great candidate to measure time reliably, without the User interference. It can be used for example, knowing elapsed time since the last call to this method,
                    time checks, validations and other things.
                    <br>
                    <br>
                    To get the time elapsed since the boot, use the method below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- GetElapsedRealtimeSinceBoot();
    NAT.DateTime.Calendar elapsedTime = NAT.DateTime.GetElapsedRealtimeSinceBoot();
}
                    </code></doc.code>
                    <doc.info>
                        Note that the time of this clock, the time elapsed since the device was booted is always reseted when the phone is rebooted!
                    </doc.info>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Date Time: Know Elapsed Time While Application is Closed -->
                <doc.topic topicid="167">
                    <doc.topictitle>Date Time: Know Elapsed Time While Application is Closed</doc.topictitle>

                    The Date Time class has an event called <doc.detach>onDateTimeGetElapsedTimeSinceLastCloseUntilThisRun_PostInitialize</doc.detach> and you can register a callback in it to receive information and time elapsed while your
                    application has been closed. This can be a great way to always know how long your application elapsed closed, since the last time it has been closed by the user. Very useful for building games that use the time the game
                    has spent closed to reduce the remaining time of buildings (such as Clans of Clans for example).
                    <br>
                    <br>
                    This event is not accompanied by any method and to use it, you must register a callback on this event <b>BEFORE</b> initializing the NAT. Thus, whenever NAT is initialized by your application, it will inform how long it
                    has passed while your app has been closed. This is why it is important that you always initialize the NAT at the beginning of your app, and of course, registering a callback on this event before you initialize it.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- onDateTimeGetElapsedTimeSinceLastCloseUntilThisRun_PostInitialize(timeElapsedWhileClosed)
    NATEvents.onDateTimeGetElapsedTimeSinceLastCloseUntilThisRun_PostInitialize += (NAT.DateTime.TimeElapsedWhileClosed timeElapsedWhileClosed) =>
    {
        //Get the data
        NAT.DateTime.Calendar time = timeElapsedWhileClosed.timeElapsed_accordingSystemClock;

        Debug.Log("Time elapsed while closed " + time.YearString + "y, " + time.MonthString + "m, " + time.DayString + "d, " + time.HourString + "h, " + time.MinuteString + "m and " + time.SecondString + "s");
    };

    //Second, call the code of the NAT C# API

    if (NativeAndroidToolkit.isInitialized == false)
        NativeAndroidToolkit.Initialize();

    //...
}
                    </code></doc.code>
                    See now, the characteristics about how this event works, so that you understand all the details of the operation.
                    <doc.list>
                        <doc.listr>This event has an error tolerance of 10 seconds late or advance in the returned time for the time the application has been closed.</doc.listr>
                        <doc.listr>This event has no other method that can be called with this event, just registering a callback to this event is enough.</doc.listr>
                        <doc.listr>
                            This event returns an object of the <doc.detach>TimeElapsedWhileClosed</doc.detach>. This object contains the elapsed time while the application is closed according to different types of clock and each has its own characteristics.
                            <doc.list>
                                <doc.listr>The time elapsed while the app was closed, returned by the variable <doc.detach>timeElapsed_accordingSystemClock</doc.detach> uses the system clock. This returned time is not 100% reliable as the user system clock can be changed while your app is closed, causing divergences at this time returned.</doc.listr>
                    </doc.list>
                    </doc.listr>
                    <doc.listr>If your app is resumed after being paused (by minimization or etc), this event will not be called. This event is only called after NAT initialization and only one time per session. If you want to know about the time elapsed while the app was paused, use the event of next topic.</doc.listr>
                    <doc.listr>This event begins to count the time as soon as the user closes your application, or when the user minimizes your application (or blocks the device) and does not open it again.</doc.listr>
                    </doc.list>
                    <doc.info>
                        This event used together with event <doc.detach>onDateTimeGetElapsedTimeSinceLastPauseUntilThisResume_PostAppResume</doc.detach>, offers a super complete kit to monitor the time while its application was Closed,
                        Minimized, Blocked, Suspended, Unfocused, Paused and so on. It's worth testing!
                    </doc.info>
                    If you want or need a much more reliable method than this event to calculate how long the application has passed closed, instead of this event you can use your own method based on NTP and require the user, an internet
                    connection so that you can make this calculation using the network time, which can not be changed by the user, as it will be on the server. You can, for example, save every 60 seconds the current time NTP, and in the
                    next initialization of your application you can subtract the current NTP time loaded on start by the old NTP time that was saved, and the result will be the elapsed time when your app was closed. As the NTP time will be
                    stored every 60 seconds, if your application is closed, your application will simply stop saving a new NTP time, and then the last time saved will be considered the approximate time that your application was closed.
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Date Time: Know Elapsed Time While Application is Paused/Minimized/Unfocused/Blocked or Suspended -->
                <doc.topic topicid="168">
                    <doc.topictitle>Date Time: Know Elapsed Time While Application is Paused/Minimized/Unfocused/Blocked or Suspended</doc.topictitle>

                    The DateTime class has an event called <doc.detach>onDateTimeGetElapsedTimeSinceLastPauseUntilThisResume_PostAppResume</doc.detach> and you can register a callback on this event to receive information and the time
                    elapsed while your app was paused, suspended, out of focus and so on. According to the Android system, your app is paused while minimized, the user is using another app but has not closed their app, out of focus, or
                    while the device is locked, but has not closed your application for example. This can be a great way to always know how long your application elapsed paused. Very useful for building games that use the time the game has
                    spent paused to reduce the remaining time of buildings (such as Clans of Clans for example).
                    <br>
                    <br>
                    This event is not accompanied by any method. To use this event, just register a callback to this event once per session of your application. You don't have to register a callback always, registering once a session is
                    enough. After that, this event will run your code whenever the application is resumed, after being paused.
                    <br>
                    <br>
                    Ideally, you register a callback to this event <b>BEFORE</b> you initialize the Native Android Toolkit. Thus, the event will be monitoring your application from the beginning.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- onDateTimeGetElapsedTimeSinceLastPauseUntilThisResume_PostAppResume(timeElapsedWhilePaused)
    NATEvents.onDateTimeGetElapsedTimeSinceLastPauseUntilThisResume_PostAppResume += (NAT.DateTime.TimeElapsedWhilePaused timeElapsedWhilePaused) =>
    {
        //Get the data
        NAT.DateTime.Calendar time = timeElapsedWhilePaused.timeElapsed_accordingRealtimeClockAfterBoot;
        
        Debug.Log("Time elapsed while paused " + time.YearString + "y, " + time.MonthString + "m, " + time.DayString + "d, " + time.HourString + "h, " + time.MinuteString + "m and " + time.SecondString + "s");
    };

    //Second, call the code of the NAT C# API

    if (NativeAndroidToolkit.isInitialized == false)
        NativeAndroidToolkit.Initialize();

    //...
}
                    </code></doc.code>
                    See now, the characteristics about how this event works, so that you understand all the details of the operation.
                    <doc.list>
                        <doc.listr>This event has a tolerance of error of 1 second delay or advance in the returned time for the time the application has passed paused.</doc.listr>
                        <doc.listr>This event has no other method that can be called with this event, just registering a callback in this event is enough.</doc.listr>
                        <doc.listr>After registering a callback to this event once, you do not need to register it again to have future callbacks, just register once and whenever the app is paused and resumed your registered code will be executed.</doc.listr>
                        <doc.listr>
                            This event returns an object of type <doc.detach>TimeElapsedWhilePaused</doc.detach>. This object contains the elapsed time when the application has been paused according to different types of clock and each has its own characteristics.
                            <doc.list>
                                <doc.listr>The time elapsed while the app was paused, returned by the variable <doc.detach>timeElapsed_accordingRealtimeClockAfterBoot</doc.detach> uses the user device RealtimeClock. This returned time is super reliable, as RealTimeClock of the user device cannot be changed and is always counted, even while the device is in sleep, locked or something. It is only interacted to verify whether or not the user device has Root, so you can be sure that the system has not been modified and the device RealtimeClock is reliable.</doc.listr>
                    </doc.list>
                    </doc.listr>
                    <doc.listr>If your app is closed while paused, or the user device is restarted while your app is paused, the event <doc.detach>onDateTimeGetElapsedTimeSinceLastCloseUntilThisRun_PostInitialize</doc.detach> will be called rather than this event.</doc.listr>
                    <doc.listr>This event begins to count the time as soon as your app is paused, minimized, suspended, out of focus and so on.</doc.listr>
                    </doc.list>
                    <doc.info>
                        This event used together with event <doc.detach>onDateTimeGetElapsedTimeSinceLastCloseUntilThisRun_PostInitialize</doc.detach>, offers a super complete kit to monitor the time while its application was Closed,
                        Minimized, Blocked, Suspended, Unfocused, Paused and so on. It's worth testing!
                    </doc.info>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: About This Class -->
                <doc.topic topicid="170">
                    <doc.topictitle>Files: About This Class</doc.topictitle>

                    The Native Android Toolkit Files class allows your application to safely interact with the file system of any Android device, regardless of the device's Android version. This class becomes very useful, even more so if we
                    take into account the complexity that exists in interacting with files on devices and on different versions of the Android system.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: About The Android Scoped Storage -->
                <doc.topic topicid="171">
                    <doc.topictitle>Files: About The Android Scoped Storage</doc.topictitle>

                    Android System Scoped Storage was an update that began rolling out in Android 10 and completed rolling out in Android 11. The intent of this update was to establish scopes that would be accessible to Android apps so that
                    only certain locations in the internal memory would be available for these applications. Android system scopes were created to provide greater user security, provide better file organization, and also control how other
                    apps access files created by the user or created by other apps.
                    <br>
                    <br>
                    Let's take an example. Prior to Android 10, your application could create and read files anywhere on the device's internal memory as long as it had <doc.detach>READ_EXTERNAL_STORAGE</doc.detach> and
                    <doc.detach>WRITE_EXTERNAL_STORAGE</doc.detach> permissions granted to your application. Now, with Scoped Storage your application can only read and create files in scopes predefined by the system (such as Downloads,
                    DCIM, Musics and similar folders that are at the root of the device's internal memory). Also, applications now, from Android 10 onwards can only read files that are in scopes and only if your application has the
                    <doc.detach>Access Files And Media</doc.detach> permission granted by the user. There are scopes that are completely free and your application can create and read files there without requesting any type of permission, as
                    you will see in the next topic.
                    <br>
                    <br>
                    You can click <a href="https://developer.android.com/about/versions/11/privacy/storage?hl=pt-br" target="_blank">here</a> for more details about the Scoped Storage implemented in Android.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: What you need to know before interacting with device Files using the NAT Files API -->
                <doc.topic topicid="172">
                    <doc.topictitle>Files: What you need to know before interacting with device Files using the NAT Files API</doc.topictitle>

                    Before using NAT Files API to interact with users files, you need to understand that this API is fully focused on the Scoped Storage architecture of the Android system. This means that this API obeys all the rules of
                    Scoped Storage and tries to abstract most of the difficulty of using Scoped Storage into a simple to use API. Although Scoped Storage is only available on devices running Android 10 or higher, this API is compatible with
                    any version of Android starting from version 4.4 Kit Kat. This compatibility is due to the fact that this API replicates the same Scoped Storage rules for versions of Android 9 or older as well, so your application will
                    be able to interact with files on Android devices regardless of the Android version.
                    <br>
                    <br>
                    Following the changes applied in the most recent versions of the Android system by Google, NAT follows the Scoped Storage model. This means that for each call to NAT Files API, you need to inform which internal memory
                    <doc.detach>scope</doc.detach> that call will be executed in, in addition to informing other things such as the file directory and etc. The <doc.detach>scope</doc.detach> is nothing more than a directory of the internal
                    memory in which that API call will work. For example, using the <doc.detach>Downloads</doc.detach> scope in the <doc.detach>OpenFile()</doc.detach> API will open a file located in the <doc.detach>Downloads</doc.detach>
                    folder of the device internal memory. The <doc.detach>OpenFile()</doc.detach> API will not be able to open a file that is outside the <doc.detach>Downloads</doc.detach> folder because the scope of the call was informed
                    to be the <doc.detach>Downloads</doc.detach> scope. Each scope has its characteristics and must store different types of files. Later on you will delve deeper into the differences between each scope.

                    <doc.topicsubtitle>Existing Scopes and its Characteristics</doc.topicsubtitle>
                    Now, see below all existing scopes in the NAT API. Each of the scopes below is a scope predefined by the Android system, in which your application can use the NAT Files API to interact with each one of them.
                    <doc.table>
                        <doc.tablecw>20%=>auto</doc.tablecw>
                        <doc.tablec>Scope=>Corresponding absolute path in internal memory</doc.tablec>
                        <doc.tabler>AppFiles=>/storage/emulated/0/Android/data/&lt;your.application.package.name&gt;/files</doc.tabler>
                        <doc.tabler>AppCache=>/storage/emulated/0/Android/data/&lt;your.application.package.name&gt;/cache</doc.tabler>
                        <doc.tabler>DCIM=>/storage/emulated/0/DCIM</doc.tabler>
                        <doc.tabler>Documents=>/storage/emulated/0/Documents</doc.tabler>
                        <doc.tabler>Downloads=>/storage/emulated/0/Download</doc.tabler>
                        <doc.tabler>Movies=>/storage/emulated/0/Movies</doc.tabler>
                        <doc.tabler>Music=>/storage/emulated/0/Music</doc.tabler>
                        <doc.tabler>Pictures=>/storage/emulated/0/Pictures</doc.tabler>
                        <doc.tabler>Podcasts=>/storage/emulated/0/Podcasts</doc.tabler>
                        <doc.tabler>Recordings=>/storage/emulated/0/Podcasts/Recordings</doc.tabler>
                        <doc.tabler>Ringtones=>/storage/emulated/0/Ringtones</doc.tabler>
                        <doc.tabler>Screenshots=>/storage/emulated/0/Pictures/Screenshots</doc.tabler>
                    </doc.table>
                    Now, see the characteristics of the scopes.
                    <doc.table>
                        <doc.tablecw>20%=>auto</doc.tablecw>
                        <doc.tablec>Scope=>Features</doc.tablec>
                        <doc.tabler>
                            AppFiles & AppCache
                            =>
                            <doc.list>
                                <doc.listr>These scopes refer to the <b>"files"</b> and <b>"cache"</b> folders respectively and are exclusive to your application use. These folders are in <b>"Android/data/&lt;your.package.name&gt;/"</b> in internal memory of device.</doc.listr>
                                <doc.listr>These scopes support ANY type of content and are dedicated for your application's use only.</doc.listr>
                                <doc.listr>NO permissions are needed to write and read files in these scopes. Their use is completely free for your application.</doc.listr>
                                <doc.listr>Files stored in the <b>"AppCache"</b> scope are actually treated as cache files and may or may not be automatically deleted by the Android system, when necessary.</doc.listr>
                                <doc.listr>Files stored in these scopes will also be deleted if the user uninstalls your app.</doc.listr>
                            </doc.list>
                        </doc.tabler>
                        <doc.tabler>
                            DCIM, Documents, Downloads, Movies, Music, Pictures, Podcasts, Recordings, Ringtones & Screenshots
                            =>
                            <doc.list>
                                <doc.listr>These scopes refer to folders that are present at the root of the device internal memory. They are scopes that can be accessed by any application, however, they have several restrictions and are not free like scopes <b>"AppFiles"</b> and <b>"AppCache"</b>.</doc.listr>
                                <doc.listr>The types of files to be stored in these scopes must be filtered by type. For example, videos should be stored in scope "Movies", screenshots in scope "Screenshots", music in scope "Music" and so on. They are media collections well defined by the Android system and must be respected because each one has a purpose, rules, organization and supported file types, which you will be able to see later.</doc.listr>
                                <doc.listr>To write and read files in these scopes your application MUST have <doc.detach>Access Files And Media</doc.detach> permission granted by the user.</doc.listr>
                                <doc.listr>Other applications that have the <doc.detach>Access Files And Media</doc.detach> permission will also be able to read and write files here.</doc.listr>
                                <doc.listr>Files written to these scopes will never be deleted after uninstalling your app.</doc.listr>
                            </doc.list>
                        </doc.tabler>
                    </doc.table>
                    Now, see the characteristics and needs that each scope has, as well as the file types supported by each one. Each scope has its limitations and characteristics. They must be respected, because if you try to do something
                    that goes against the characteristics or set of rules of a certain scope, the operation you are trying to do will simply be ignored by the system and will fail silently. see the table below for more information.
                    <doc.table>
                        <doc.tablecw>10%=>20%=>20%=>20%=>30%</doc.tablecw>
                        <doc.tablec>Scope=>Your app can Read=>Your app can Write=>Your app can Delete=>Supported types</doc.tablec>
                        <doc.tabler>AppFiles=>Anything. It doesn't need permissions=>Anything. It doesn't need permissions=>Anything. It doesn't need permissions=>Any</doc.tabler>
                        <doc.tabler>AppCache=>Anything. It doesn't need permissions=>Anything. It doesn't need permissions=>Anything. It doesn't need permissions=>Any</doc.tabler>
                        <doc.tabler>DCIM=>Yes, but need permission=>Own app files=>Own app files=>bmp, gif, jpg, jpeg, png, psd, svg, tiff, webp, mp4, avi, mov, 3gp, flv, webm, mpeg, mkv, wmv & ogv</doc.tabler>
                        <doc.tabler>Documents=>Yes, but need permission=>Own app files=>Own app files=>bmp, gif, jpg, jpeg, png, psd, svg, webp, tga, tiff, mp4, avi, mov, 3gp, flv, webm, mpeg, mkv, wmv, ogv, ogg, aac, mp3, amr, wav, mid, m4a, raw, wma, cda, doc, docx, html, htm, xml, xhtml, css, js, php, aspx, cs, java, json, ini, txt, odt, oxps, pdf, ps, rtf, wpd, wp, wp7, ppt, pptx, db, sql, gdoc, log, md, ttf, odf, xlsx & xls</doc.tabler>
                        <doc.tabler>Downloads=>Yes, but need permission=>Own app files=>Own app files=>bmp, gif, jpg, jpeg, png, psd, svg, webp, tga, tiff, mp4, avi, mov, 3gp, flv, webm, mpeg, mkv, wmv, ogv, ogg, aac, mp3, amr, wav, mid, m4a, raw, wma, cda, doc, docx, html, htm, xml, xhtml, css, js, php, aspx, cs, java, json, ini, txt, odt, oxps, pdf, ps, rtf, wpd, wp, wp7, ppt, pptx, db, sql, gdoc, log, md, ttf, odf, xlsx & xls</doc.tabler>
                        <doc.tabler>Movies=>Yes, but need permission=>Own app files=>Own app files=>mp4, avi, mov, 3gp, flv, webm, mpeg, mkv, wmv & ogv</doc.tabler>
                        <doc.tabler>Music=>Yes, but need permission=>Own app files=>Own app files=>ogg, aac, mp3, amr, wav, mid, m4a & wma</doc.tabler>
                        <doc.tabler>Pictures=>Yes, but need permission=>Own app files=>Own app files=>bmp, gif, jpg, jpeg, png, psd, svg, webp, tiff, mp4, avi, mov, 3gp, flv, webm, mpeg, mkv, wmv & ogv</doc.tabler>
                        <doc.tabler>Podcasts=>Yes, but need permission=>Own app files=>Own app files=>ogg, aac, mp3, amr, wav, mid, m4a & wma</doc.tabler>
                        <doc.tabler>Recordings=>Yes, but need permission=>Own app files=>Own app files=>ogg, aac, mp3, amr, wav, mid, m4a & wma</doc.tabler>
                        <doc.tabler>Ringtones=>Yes, but need permission=>Own app files=>Own app files=>ogg, aac, mp3, amr, wav, mid, m4a & wma</doc.tabler>
                        <doc.tabler>Screenshots=>Yes, but need permission=>Own app files=>Own app files=>bmp, gif, jpg, jpeg, png, psd, svg, webp, tiff, mp4, avi, mov, 3gp, flv, webm, mpeg, mkv, wmv & ogv</doc.tabler>
                    </doc.table>
                    If your app tries to do something that is outside the rules of some scope or create a file with an extension not supported by a certain scope, for example, the operation will fail silently and the exeception
                    <doc.detach>UnauthorizedAccessException</doc.detach> will be thrown by the Android system. If your application does not have permission to access the files and tries to read files from a permission-protected scope, the
                    system will throw exception <doc.detach>FileNotFoundException</doc.detach> and the API will fail silently.
                    <doc.info>
                        The most suitable scopes for your app to store files are the <doc.detach>AppFiles</doc.detach> or <doc.detach>AppCache</doc.detach> scopes because these two scopes do not have ANY type of restriction to manipulate
                        and manage files. Use the other scopes only to store useful files for the user such as recordings, prints, documents, texts, photos and other media that would be useful for the user even after uninstalling your app.
                        Aside from the fact that the <doc.detach>AppFiles</doc.detach> or <doc.detach>AppCache</doc.detach> scopes don't have ANY kind of restriction on manipulating the files, they also don't require the
                        <doc.detach>Access Files And Media</doc.detach> permission for you to be able to manipulate the files in these scopes.
                    </doc.info>

                    <doc.topicsubtitle>File ownership system</doc.topicsubtitle>
                    The Scoped Storage system also has a file ownership system. When your application creates a file in any scope other than <doc.detach>AppFiles</doc.detach> or <doc.detach>AppCache</doc.detach>, that file will be
                    registered as belonging to your application. Other applications that have the <doc.detach>Access Files And Media</doc.detach> permission will be able to read the files created by your application, but not be able to edit
                    or delete them. The same goes for your application. If your application has the <doc.detach>Access Files And Media</doc.detach> permission, then your application can read files created by it and other applications,
                    but it cannot delete or edit files that were created by other applications. Your application can only edit or delete files that it created.
                    <br>
                    <br>
                    If the user uninstalls and reinstalls your application, the files that were created by your application will no longer be considered as "created by your app" and so your app will need to request the
                    <doc.detach>Access Files And Media</doc.detach> permission if it wants to read them.
                    <doc.warn>
                        Due to this file ownership mechanic, if you use NAT Files API to create a file that already exists in a scope other than <doc.detach>AppFiles</doc.detach> or <doc.detach>AppCache</doc.detach>, but the already
                        existing file does not belong to your application, the API will fail because it does not it is possible to overwrite a file created by another application.
                    </doc.warn>

                    <doc.topicsubtitle>Best and most correct approach to use NAT Files API</doc.topicsubtitle>
                    If you're reading this topic from the beginning, you should have already understood the concept and rules of scopes and Scoped Storage in the Android system, as well as the differences between each scope.
                    <br>
                    <br>
                    Now is the time to start working with NAT Files API! Before your application starts interacting with the device's filesystem, it needs to do a few checks. See below what needs to be checked.
                    <doc.list>
                        <doc.listr>Is the memory mounted?</doc.listr>
                        <doc.listr>Is the memory available for use?</doc.listr>
                        <doc.listr>Is the scope I want to work on available for use?</doc.listr>
                        <doc.listr>Is file access permission (if required for this scope) granted by the user?</doc.listr>
                        <doc.listr>Is the device not connected to a USB?</doc.listr>
                    </doc.list>
                    Knowing this, the Native Android Toolkit has a method called <doc.detach>GetScopeAvailability()</doc.detach> that already checks ALL these questions and returns a response that says if everything is ok. To use this
                    method you must inform it which scope you intend to work with, then a response will be returned. Very simple! See how to use this method below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    bool isScopeAvailable = false;
    
    //- GetScopeAvailability(scopeToWork);
    if (NAT.Files.GetScopeAvailability(NAT.Files.Scope.Music) == NAT.Files.ScopeStatus.AvailableToUse)
        isScopeAvailable = true;
}
                    </code></doc.code>
                    This is why the <doc.detach>GetScopeAvailability()</doc.detach> method should ALWAYS be used for your application to check that everything is ready before starting to work with files on the device. This greatly reduces
                    the chances of errors during the operation of your application. In the example below, we are going to create a text file in scope <doc.detach>Documents</doc.detach>, but first let's check that everything is ok before
                    creating the file!
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //Check if the "Documents" scope is available
    if (NAT.Files.GetScopeAvailability(NAT.Files.Scope.Documents) == NAT.Files.ScopeStatus.AvailableToUse)
    {
        //Create a text file into "Documents" scope
        NAT.Files.WriteAllText(NAT.Files.Scope.Documents, "folder1/folder2", "myName.txt", "My name is Samuel.");
    }
    if (NAT.Files.GetScopeAvailability(NAT.Files.Scope.Documents) != NAT.Files.ScopeStatus.AvailableToUse)
        Debug.LogError("The scope is not available for use.");
}
                    </code></doc.code>
                    <doc.info>
                        It is recommended that you always do this check, regardless of which scope you intend to work.
                    </doc.info>
                    <doc.warn>
                        If you are going to create larger files, download files, and so on, it is also interesting to check if there is enough free memory on the device. For that you can use the
                        <doc.detach>GetInternalMemoryUsageInfo()</doc.detach> method, which will be discussed in the next topics.
                    </doc.warn>

                    <doc.topicsubtitle>Requesting permissions</doc.topicsubtitle>
                    If you plan to work with files that ARE NOT in scope <doc.detach>AppFiles</doc.detach> or <doc.detach>AppCache</doc.detach>, your application must have <doc.detach>Access Files And Media</doc.detach> permission granted
                    by the user. If your application does not have the permission, the Files API that your application calls will fail silently and will not fulfill its purpose.
                    <br>
                    <br>
                    To request the permission for the user, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    new NAT.Permissions.PermissionRequester()
        .addPermissionToRequest(NAT.Permissions.AndroidPermission.AccessFilesAndMedia)
        .RequestThisPermissions();
}
                    </code></doc.code>
                    And to check if your application already has the permission granted, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    bool havePermission = NAT.Permissions.isPermissionGuaranteed(NAT.Permissions.AndroidPermission.AccessFilesAndMedia);
}
                    </code></doc.code>
                    <br>
                    <br>
                    <doc.achiev>
                        Basically, those were all the things you needed to know before using NAT Files API. If you read this entire topic from the beginning, you are now on top of everything! Keep reading the next topics to learn about
                        all methods of NAT Files class!
                    </doc.achiev>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: Get Absoluth Path For Scope -->
                <doc.topic topicid="173">
                    <doc.topictitle>Files: Get Absoluth Path For Scope</doc.topictitle>

                    To get a complete absolute path, equivalent to a scope, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- GetAbsolutePathForScope(scopeToWork);
    string absolutePathForDownloads = NAT.Files.GetAbsolutePathForScope(NAT.Files.Scope.Downloads);
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: Get Internal Memory Usage Info -->
                <doc.topic topicid="175">
                    <doc.topictitle>Files: Get Internal Memory Usage Info</doc.topictitle>

                    For information related to device memory statistics, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- GetInternalMemoryUsageInfo();
    NAT.Files.StorageInfo info = NAT.Files.GetInternalMemoryUsageInfo();
    
    Debug.Log("Total Memory is " + info.totalMemory.ToGigabytes + " GB");
    Debug.Log("Free Memory is " + info.freeMemory.ToGigabytes + " GB");
    Debug.Log("Used Memory is " + info.usedMemory.ToGigabytes + " GB");
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: Save Media and Do It Available To Gallery -->
                <doc.topic topicid="176">
                    <doc.topictitle>Files: Save Media and Do It Available To Gallery</doc.topictitle>

                    This method allows a media present in the internal memory to be scanned by the Android system. This way the system will know that it exists and will show it in the gallery and other things. When you call this method, you
                    should tell you what type of media it is and also the way to the media you want to save.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- SaveMediaAndMakesItAvailableToGallery(mediaType, mediaPath)
    NAT.Files.SaveMediaAndMakesItAvailableToGallery(NAT.Files.MediaType.Photo, "/storage/emulated/0/DCIM/myProfilePhoto.jpg");
}
                    </code></doc.code>
                    The table below shows the types of media you can select in this method.
                    <doc.table>
                        <doc.tablecw>20%=>auto</doc.tablecw>
                        <doc.tablec>Media Type=>Description</doc.tablec>
                        <doc.tabler>Screenshot=>The media will be saved in scope Screentshots.</doc.tabler>
                        <doc.tabler>Picture=>The media will be saved in scope Pictures.</doc.tabler>
                        <doc.tabler>Photo=>The media will be saved in scope DCIM.</doc.tabler>
                        <doc.tabler>Music=>The media will be saved in scope Music.</doc.tabler>
                        <doc.tabler>Recording=>The media will be saved in scope Recordings.</doc.tabler>
                        <doc.tabler>Video=>The media will be saved in scope Movies.</doc.tabler>
                        <doc.tabler>Document=>The media will be saved in scope Documents.</doc.tabler>
                    </doc.table>
                    <doc.info>
                        When the media is saved, it is actually copied from where you reported that it is and then is paste to the correct location where it should stay and after that is scanned by the system.
                    </doc.info>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: Check if a Folder is Scannable by the System -->
                <doc.topic topicid="177">
                    <doc.topictitle>Files: Check if a Folder is Scannable by the System</doc.topictitle>

                    The Android system from time to time scan all the internal memory of the device in search of new media files. When he finds a media file that was not scanned before, he automatically scans him and makes it available in
                    the gallery for example. However, it is possible to define which folders are scanning or not and if a folder has been defined as non-scanable, Android will ignore any media file within it.
                    <br>
                    <br>
                    To check whether a folder is scanable or not, use the method below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{

        //- isFolderScannable(scopeToWork, pathOfFolderInsideScope);
        bool isScanable = NAT.Files.isFolderScannable(NAT.Files.Scope.Documents, "");   //<- Check if the "Documents" scope is scanable

        //- isFolderScannable(scopeToWork, pathOfFolderInsideScope);
        bool isScanable = NAT.Files.isFolderScannable(NAT.Files.Scope.Documents, "Example/Test");   //<- Check if the folder "Example/Test" inside "Documents" scope scope is scanable
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: Set a Folder as Scannable/Unscannable -->
                <doc.topic topicid="178">
                    <doc.topictitle>Files: Set a Folder as Scannable/Unscannable</doc.topictitle>

                    To define if a folder can be scanned by the Android system, use the method below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- SetFolderAsScannable(scopeToWork, folderPathInsideScope, setAsScanable);
    NAT.Files.SetFolderAsScannable(NAT.Files.Scope.Documents, "Example/Folder1", false); //<- Here we define that the folder "Example/Folder1" within scope "Documents" is no longer scanable
}
                    </code></doc.code>
                    <doc.info>
                        Outside the <doc.detach>AppFiles</doc.detach> and <doc.detach>AppCache</doc.detach> scopes, you can only define as non-scanable the folders that were created by your application.
                    </doc.info>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: Get List of Files And Folders of a Directory -->
                <doc.topic topicid="179">
                    <doc.topictitle>Files: Get List of Files And Folders of a Directory</doc.topictitle>

                    For a list of all files and folders contained in a directory, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- GetListOfFilesAndFolders(scopeToWork, folderPathInsideScope, showFullPathInList);
    NAT.Files.ItemsList fileList = NAT.Files.GetListOfFilesAndFolders(NAT.Files.Scope.Documents, "Example/Folder1", false);   //<- Get a list of all files contained in the folder "Example/Folder1" that is within scope "Documents"

    foreach (string folder in fileList.folders)
        Debug.Log("Folder Found: " + folder);

    foreach (string file in fileList.files)
        Debug.Log("File Found: " + file);
}
                    </code></doc.code>
                    <doc.info>
                        The last parameter of method <doc.detach>GetListOfFilesAndFolders()</doc.detach> determines whether or not the returned list should contain the full path to each file or folder listed.
                    </doc.info>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: Check if File/Folder Exists -->
                <doc.topic topicid="180">
                    <doc.topictitle>Files: Check if File/Folder Exists</doc.topictitle>

                    To check if a file or folder exists, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //=============  Checking if a FILE exists  =============//

    //- Exists(scopeOfWork, filePathInsideScope, isFolder)
    bool fileExists = NAT.Files.Exists(NAT.Files.Scope.Documents, "to-do-list.txt", false);   //<- Checking if file "to-do-list.txt" exists within scope "Documents"

    //=============  Checking if a FOLDER exists  =============//

    //- Exists(scopeOfWork, folderPathInsideScope, isFolder)
    bool folderExists = NAT.Files.Exists(NAT.Files.Scope.Documents, "Example/Folder1", true);   //<- Checking if folder "Example/Folder1" exists within scope "Documents"
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: Get all Attributes from File/Folder -->
                <doc.topic topicid="181">
                    <doc.topictitle>Files: Get all Attributes from File/Folder</doc.topictitle>

                    To get all attributes of a file or folder, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- GetAllAttributes(scopeToWork, fileOrFolderPathInsideScope);
    NAT.Files.Attributes fileAttributes = NAT.Files.GetAllAttributes(NAT.Files.Scope.Documents, "to-do-list.txt");  //<- Get attributes of file "to-do-list.txt" that is within scope "Documents"

    Debug.Log("File Name: " + fileAttributes.pureName);
    Debug.Log("File Extension: " + fileAttributes.extension);
    Debug.Log("File Size: " + fileAttributes.size.ToBytes);
}
                    </code></doc.code>
                    The table below contains all attribute values that can be read from a file or folder. All attributes work for files or folders. All these attributes are contained in the <doc.detach>Attributes</doc.detach> object
                    returned by this method.
                    <doc.table>
                        <doc.tablecw>25%=>auto</doc.tablecw>
                        <doc.tablec>Attribute=>Description</doc.tablec>
                        <doc.tabler>isFile=>Indicates whether it is a file.</doc.tabler>
                        <doc.tabler>isFolder=>Indicates whether it is a folder.</doc.tabler>
                        <doc.tabler>size=>Reports the file size. If it's a folder, it tells you the total size of the folder.</doc.tabler>
                        <doc.tabler>lastModify=>Indicates the date of the last modification.</doc.tabler>
                        <doc.tabler>parentPath=>Informs the path to the folder that owns this file or folder.</doc.tabler>
                        <doc.tabler>isHidden=>Tells you if this is a hidden file or folder.</doc.tabler>
                        <doc.tabler>isWritable=>Informs whether this file or folder can be overwritten.</doc.tabler>
                        <doc.tabler>isReadable=>Tells you whether this file or folder is readable.</doc.tabler>
                        <doc.tabler>pureName=>Contains the pure name of this file or folder. In the case of a file, it contains the name without extension.</doc.tabler>
                        <doc.tabler>extension=>In case it is a file, this attribute contains the file extension.</doc.tabler>
                    </doc.table>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: Copy File/Folder -->
                <doc.topic topicid="182">
                    <doc.topictitle>Files: Copy File/Folder</doc.topictitle>

                    To copy a file or folder, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- CopyTo(targetScopeToWork, targetFileOrFolderToCopy, destinationScopeToWork, destinationPathToPaste)
    NAT.Files.CopyTo(NAT.Files.Scope.Documents, "Example/to-do-list.txt", NAT.Files.Scope.Documents, "Example/Folder1");   //<- Copies the file "to-do-list.txt" that is inside the scope "Documents" to the folder "Example/Folder1" that is also inside the scope "Documents"
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: Move File/Folder -->
                <doc.topic topicid="183">
                    <doc.topictitle>Files: Move File/Folder</doc.topictitle>

                    To move a file or folder, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- MoveTo(targetScopeToWork, targetFileOrFolderToCut, destinationScopeToWork, destinationPathToPaste);
    NAT.Files.MoveTo(NAT.Files.Scope.Documents, "Example/to-do-list.txt", NAT.Files.Scope.Documents, "Example/Folder1");   //<- Move the file "to-do-list.txt" that is inside the scope "Documents" to the folder "Example/Folder1" that is also inside the scope "Documents"
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: Rename File/Folder -->
                <doc.topic topicid="184">
                    <doc.topictitle>Files: Rename File/Folder</doc.topictitle>

                    To rename a folder or file, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- Rename(scopeToWork, targetFileOrFolderPath, newNameToSetToFileOrFolder);
    NAT.Files.Rename(NAT.Files.Scope.Documents, "Example/Folder1/to-do-list.txt", "checklist.txt");   //<- Renames the "to-do-list.txt" file that is within the scope "Documents" to "checklist.txt". The file remains in the same directory
}
                    </code></doc.code>
                    <doc.warn>
                        This method was created only for renaming files and folders. Do not try to use it to move files or folders, for that purpose use method <doc.detach>MoveTo()</doc.detach> instead.
                    </doc.warn>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: Delete File/Folder -->
                <doc.topic topicid="185">
                    <doc.topictitle>Files: Delete File/Folder</doc.topictitle>

                    To delete a file or folder, use this code.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- Delete(scopeToWork, fileOrFolderPathToDelete);
    NAT.Files.Delete(NAT.Files.Scope.Documents, "Example/to-do-list.txt");   //<- Deletes the "to-do-list.txt" file that is in the "Documents" scope
}
                    </code></doc.code>
                    <doc.info>
                        If the path you provided to be deleted is a folder, the folder will be automatically deleted recursively. All files contained in the folder will be deleted, followed by the folder itself.
                    </doc.info>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: Create Folder -->
                <doc.topic topicid="186">
                    <doc.topictitle>Files: Create Folder</doc.topictitle>

                    To create a folder, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- CreateFolder(scopeToWork, destinationPathOfFolderInsideScope, folderNameToCreate);
    NAT.Files.CreateFolder(NAT.Files.Scope.Documents, "", "Example");   //<- We create a folder called "Example" which is at the root of scope "Documents"
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: Create File -->
                <doc.topic topicid="187">
                    <doc.topictitle>Files: Create File</doc.topictitle>

                    To create a file, use the code below. You will need to provide the bytes of the file.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

public byte[] fileBytes;

void Example()
{
    //- CreateFile(scopeToWork, destinationPathInsideScope, fileNameToCreateOnDestination, fileBytes);
    NAT.Files.CreateFile(NAT.Files.Scope.Pictures, "Example/Folder1", "my-picture.png", fileBytes);   //<- Creates a file in scope "Pictures" named "my-picture.png" inside folder "Folder1"
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: Load All Bytes From File -->
                <doc.topic topicid="188">
                    <doc.topictitle>Files: Load All Bytes From File</doc.topictitle>

                    To read all bytes from a file, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- LoadAllBytesOfFile(scopeToWork, filePathInsideScope);
    byte[] fileBytes = NAT.Files.LoadAllBytesOfFile(NAT.Files.Scope.Documents, "to-do-list.txt");   //<- Here we load all the bytes of the file "to-do-list.txt" that is in the root of scope "Documents"
}
                    </code></doc.code>
                    <doc.warn>
                        This method is not recommended for loading very large files as it can cause bottlenecks in your application. If you need to load large files, it is best to move or copy the file to the root of the
                        <doc.detach>AppFiles</doc.detach> scope and then use <doc.detach>Application.persistentDataPath</doc.detach> along with the C# File API to load the file asynchronously, with its own logic. The
                        <doc.detach>AppFiles</doc.detach> scope and <doc.detach>Application.persistentDataPath</doc.detach> Unity property point to the same path
                        (<doc.detach>/storage/emulated/0/Android/data/&lt;your.application.package.name&gt;/files</doc.detach>) on Android devices.
                    </doc.warn>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: Write All Text -->
                <doc.topic topicid="189">
                    <doc.topictitle>Files: Write All Text</doc.topictitle>

                    To create a text file with the contents of a String, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- WriteAllText(scopeToWork, destinationPathForTheTextFile, fileNameToCreate, fileTextContent);
    NAT.Files.WriteAllText(NAT.Files.Scope.Documents, "", "my-book.txt", "This my first text file! :)");   //<- Here we create a text file named "my-book.txt" at the root of scope "Documents"
}
                    </code></doc.code>
                    To create a text file with the contents of a array of Strings, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

public string[] textLines;

void Example()
{
    //- WriteAllLines(scopeToWork, destinationPathForTheTextFile, fileNameToCreate, textLinesToSave);
    NAT.Files.WriteAllLines(NAT.Files.Scope.Documents, "Example/Folder1", "my-book.txt", textLines);   //<- Here we create a text file named "my-book.txt" inside the scope "Documents"
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: Read All Text From File -->
                <doc.topic topicid="190">
                    <doc.topictitle>Files: Read All Text From File</doc.topictitle>

                    To read the entire contents of a text file into a String, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- ReadAllTextOfFile(scopeToWork, filePathToRead);
    string fileContent = NAT.Files.ReadAllTextOfFile(NAT.Files.Scope.Documents, "my-book.txt");   //<- Here we load all the text content of the "my-book.txt" file that is in the root of the "Documents" scope
}
                    </code></doc.code>
                    To read a text file by spliting each line to an array element, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- ReadAllLinesOfFile(scopeToWork, filePathToRead);
    string[] linesOfText = NAT.Files.ReadAllLinesOfFile(NAT.Files.Scope.Documents, "Example/Folder1/my-book.txt");   //<- Here we load all lines of the "my-book.txt" file that is inside of the "Documents" scope
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: Open File With Default Application -->
                <doc.topic topicid="193">
                    <doc.topictitle>Files: Open File With Default Application</doc.topictitle>

                    To open a file with the best default application, use the code below. The Android system will automatically choose the best application to open the file, but if it cannot do so, it will let the user choose an
                    application.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- OpenWithDefaultApplication(scopeToWork, openingDialogTitle, filePathInsideTheScope);
    NAT.Files.OpenWithDefaultApplication(NAT.Files.Scope.Documents, "Select a Application To Open", "mybook.txt");   //<- Here we are opening the file "my-book.txt" which is in the root of scope "Documents"
}
                    </code></doc.code>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Files: Using the system File Picker to "Save As" or "Open" a File -->
                <doc.topic topicid="194">
                    <doc.topictitle>Files: Using the system File Picker to "Save As" or "Open" a File</doc.topictitle>

                    You can use the File Picker native of the Android system, using NAT. The Android System File Picker allows your application to open a system file explorer interface so that the user can select a file or directory. Works
                    like the "Save As" windows of other operating systems such as Windows OS. After the user has already selected a directory or file, the File Picker will return to your application, the path in the internal memory of the
                    device, where the user selected the file or directory. Once you have the path corresponding to the file or directory selected by the user, just perform the operation your application needs!
                    <br>
                    <br>
                    To use NAT File Picker you need to register the callback in the event and then use a constructor to open the File Picker. When the user completes the operation with the File Picker, the code you registered in the event
                    will be executed. See examples below...
                    <br>
                    <br>
                    <b>To Open a "Save As" style File Picker</b>
                    <br>
                    <br>
                    You should use this File Picker when you want the user to choose a directory to save the file your application will create. This File Picker will allow the user to select a directory from the device internal memory, and
                    will also allow the user to create a name for the file he intends to save.
                    <doc.code language="csharp"><code>
using System.IO;
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //First, register the callbacks...
    
    //- onFilesFilePickerOperationFinished(filePickerOperationStatus, filePickerResponse)
    NATEvents.onFilesFilePickerOperationFinished += (NAT.Files.FilePickerOperationStatus status, NAT.Files.FilePickerOperationResponse response) =>
    {
        if (status == NAT.Files.FilePickerOperationStatus.Successfully)
            if (response.operationType == NAT.Files.FilePickerAction.CreateFile)
            {
                NAT.Files.WriteAllText(response.scopeOfOperation, Path.GetDirectoryName(response.pathFromOperationInScope), Path.GetFileName(response.pathFromOperationInScope), "This is the text file saved!");
                
                
                Debug.Log("The file \"" + Path.GetFileName(response.pathFromOperationInScope) + "\" was saved!");
            }
        
        
        if (status == NAT.Files.FilePickerOperationStatus.InvalidScope)
            NAT.Dialogs.ShowSimpleAlertDialog("File Picker Operation Result", "Invalid scope! Please select another location!", false);
        if (status == NAT.Files.FilePickerOperationStatus.Canceled)
            NAT.Dialogs.ShowSimpleAlertDialog("File Picker Operation Result", "The File Picker operation has been canceled by the user!", false);
        if (status == NAT.Files.FilePickerOperationStatus.Unknown)
            NAT.Dialogs.ShowSimpleAlertDialog("File Picker Operation Result", "An internal error occurred in File Picker!", false);
    };
    
    //Second, call the code of the NAT C# API
    
    //- new NAT.Files.FilePickerOperation(filePickerInterfaceOrientation, filePickerDialogTitle)
    new NAT.Files.FilePickerOperation(NAT.Files.FilePickerInterfaceMode.LandscapeFullscreen, "Select a Place To Create File")
        .setCreateFileOperation(NAT.Files.FilePickerDefaultScope.Documents, "textFileCreated.txt")
        .setMimeType(NAT.Files.MimeType.TXT)
        .OpenFilePicker();
}
                    </code></doc.code>
                    With method <doc.detach>setCreateFileOperation()</doc.detach> we can specify that this File Picker will be "Save As" style and we can specify the scope that the user will see when opening the File Picker, as well as the
                    name of the file that will be suggested to the user, since he can change this name to whatever name you prefer.
                    <doc.info>
                        The system will not allow any files to be overwritten when using File Picker. If the user chooses to save the file in a location where a file with the same name already exists, the system will return to your
                        application, a path where the name of the file you want to save contains a suffix number (for example <doc.detach>My File (1).txt</doc.detach>).
                    </doc.info>
                    <br>
                    <br>
                    <b>To Open a "Open" style File Picker</b>
                    <br>
                    <br>
                    You should use this File Picker when you need the user to select a file to open so your application can read it. This File Picker will allow the user to browse the internal memory of the device and select a file, then
                    your application will receive the path to the file selected by the user.
                    <doc.code language="csharp"><code>
using System.IO;
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //First, register the callbacks...

    //- onFilesFilePickerOperationFinished(filePickerOperationStatus, filePickerResponse)
    NATEvents.onFilesFilePickerOperationFinished += (NAT.Files.FilePickerOperationStatus status, NAT.Files.FilePickerOperationResponse response) =>
    {
        if (status == NAT.Files.FilePickerOperationStatus.Successfully)
        if (response.operationType == NAT.Files.FilePickerAction.OpenFile)
        {
            string fileContent = NAT.Files.ReadAllTextOfFile(response.scopeOfOperation, response.pathFromOperationInScope);


            Debug.Log("The content of the file \"" + Path.GetFileName(response.pathFromOperationInScope) + "\" is \"" + fileContent + "\".");
        }


        if (status == NAT.Files.FilePickerOperationStatus.InvalidScope)
            NAT.Dialogs.ShowSimpleAlertDialog("File Picker Operation Result", "Invalid scope! Please select another location!", false);
        if (status == NAT.Files.FilePickerOperationStatus.Canceled)
            NAT.Dialogs.ShowSimpleAlertDialog("File Picker Operation Result", "The File Picker operation has been canceled by the user!", false);
        if (status == NAT.Files.FilePickerOperationStatus.Unknown)
            NAT.Dialogs.ShowSimpleAlertDialog("File Picker Operation Result", "An internal error occurred in File Picker!", false);
    };

    //Second, call the code of the NAT C# API

    //- new NAT.Files.FilePickerOperation(filePickerInterfaceOrientation, filePickerDialogTitle)
    new NAT.Files.FilePickerOperation(NAT.Files.FilePickerInterfaceMode.LandscapeFullscreen, "Select a File To Be Openned")
        .setOpenFileOperation(NAT.Files.FilePickerDefaultScope.Documents)
        .setMimeType(NAT.Files.MimeType.All)
        .OpenFilePicker();
}
                    </code></doc.code>
                    With method <doc.detach>setOpenFileOperation()</doc.detach> we can specify that this File Picker will be "Open" style and we can specify the scope that the user will see when opening the File Picker.
                    <br>
                    <br>
                    <b>Defining visible file types in File Picker</b>
                    <br>
                    <br>
                    To define which file types will be visible to the user in the File Picker you can use the <doc.detach>setMimeType()</doc.detach> method and define the file type. There is also the
                    <doc.detach>setCustomMimeType()</doc.detach> method which allows you to define a custom file type. These methods only work in the File Picker constructor, see the example below to display only PNG files in the File
                    Picker.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    new NAT.Files.FilePickerOperation(NAT.Files.FilePickerInterfaceMode.LandscapeFullscreen, "Select a File To Be Openned")
        .setOpenFileOperation(NAT.Files.FilePickerDefaultScope.DCIM)
        .setMimeType(NAT.Files.MimeType.PNG)
        .OpenFilePicker();
}
                    </code></doc.code>
                    <br>
                    <br>
                    <b>Processing File Picker response</b>
                    <br>
                    <br>
                    Once the user has selected the directory or file with the File Picker, it will close and return a response to your application through the <doc.detach>onFilesFilePickerOperationFinished</doc.detach> event. In this event,
                    the <doc.detach>FilePickerOperationStatus</doc.detach> object brings the status that indicates whether the file selection operation was successful as the <doc.detach>FilePickerOperationResponse</doc.detach> event brings
                    the scope in which the file or directory was selected by the user, as well as the path to the file or directory inside that scope. Your application should only try to read object
                    <doc.detach>FilePickerOperationResponse</doc.detach> if object <doc.detach>FilePickerOperationStatus</doc.detach> returned a status of <doc.detach>Successfully</doc.detach>. See the example below, where the File Picker
                    was opened for the user to select a text file.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    NATEvents.onFilesFilePickerOperationFinished += (NAT.Files.FilePickerOperationStatus status, NAT.Files.FilePickerOperationResponse response) =>
    {
        if (status == NAT.Files.FilePickerOperationStatus.Successfully)
            if (response.operationType == NAT.Files.FilePickerAction.OpenFile)
            {
                string textFileContent = NAT.Files.ReadAllTextOfFile(response.scopeOfOperation, response.pathFromOperationInScope);
            }
    };
}
                    </code></doc.code>
                    In the <doc.detach>FilePickerOperationResponse</doc.detach> object, in the <doc.detach>pathFromOperationInScope</doc.detach> variable that indicates the path of the file or directory selected by the user, you can use the
                    C# <doc.detach>Path.GetFileName()</doc.detach> method to extract the file name.
                    <doc.warn>
                        If the user selects an invalid, inaccessible, non-existent file from the "Downloads" tab or from an SD Card, FilePicker will inform the status of <doc.detach>InvalidScope</doc.detach> in the callback event, so you
                        need to ask the user to choose another scope/file. The "Downloads" tab of File Picker in particular contains many system restrictions through FilePicker, so it should be avoided. The only allowed scopes for selecting
                        files are <doc.detach>DCIM</doc.detach>, <doc.detach>Documents</doc.detach>, <doc.detach>Movies</doc.detach>, <doc.detach>Music</doc.detach>, <doc.detach>Pictures</doc.detach>, <doc.detach>Podcasts</doc.detach> and
                        <doc.detach>Ringtones</doc.detach>. Therefore, when using the File Picker constructor, you must supply one of these scopes by default. If the user goes back and changes the scope or selects a file that is not within
                        these allowed scopes, there will be the result of <doc.detach>InvalidScope</doc.detach>. The File Picker UI is managed by the system and therefore the Native Android Toolkit is not able to block the user from
                        navigating through different scopes other than those mentioned above.
                    </doc.warn>
                    <br>
                    <br>
                    <b>The recommended usage flow for File Picker</b>
                    <br>
                    <br>
                    This is the best recommended workflow for using NAT File Picker...
                    <doc.list isnumeric="true">
                        <doc.listr>Defines which scope you want to save or open a file.</doc.listr>
                        <doc.listr>Inform the user that the system file picker will open and he cannot leave the default folder that the file picker opens. Tell the user the name of the folder where he should keep the file picker. For example, if your app needs to save/open a file inside the <doc.detach>DCIM</doc.detach> folder, inform the user that he can save/open the file anywhere inside the <doc.detach>DCIM</doc.detach> folder, but he cannot go to other folders in the memory root, such as <doc.detach>Android</doc.detach>, <doc.detach>Screenshots</doc.detach> and etc.</doc.listr>
                        <doc.listr>Use the builder to open the NAT File Picker, and set the desired scope as the default. For example, if your app needs to save/open in <doc.detach>DCIM</doc.detach>, then set the <doc.detach>DCIM</doc.detach> scope as default in the File Picker constructor.</doc.listr>
                        <doc.listr>Your application will receive the callback from the <doc.detach>onFilesFilePickerOperationFinished</doc.detach> event. Check that the status is <doc.detach>Success</doc.detach> and then check that the scope where the user selected the file/folder is what your app needs to save/open. For example, if your app needs to save in the <doc.detach>DCIM</doc.detach> scope, check the event result, if the location selected by the user is in the <doc.detach>DCIM</doc.detach> scope.</doc.listr>
                        <doc.listr>If it's not in the scope your app needs, send an error message to the user and explain to them that they need to select a location within the scope your app needs. Tell him that this is necessary due to restrictions on access to files and folders imposed by the Android system in favor of user privacy.</doc.listr>
                        <doc.listr>If the user has selected the scope your application needs, then just process the result and do what you need to do, like create the file, read the file, and so on.</doc.listr>
                    </doc.list>
                    <doc.info>
                        The default scope that can be set in the File Picker constructor defines where the system FilePicker will open to the user, however this does not work for Android 7.1 or older devices.
                    </doc.info>

                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (Recommended For File Picker)=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Audio Player: About This Class -->
                <doc.topic topicid="196">
                    <doc.topictitle>Audio Player: About This Class</doc.topictitle>

                    This class provides tools for your application to play audio files of various types using the device streaming media system. That way, your application can play audios using the system native Media Player, without
                    going through Unity and much faster, even if the file is very large.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Audio Player: Get Audio File Information -->
                <doc.topic topicid="197">
                    <doc.topictitle>Audio Player: Get Audio File Information</doc.topictitle>

                    To get metadata and information from an audio file, use the code below. Note that this method uses the Android system Scoped Storage system, you can learn about it <a href="#171">here</a> and <a href="#172">here</a>.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- GetAudioDataWithoutPlay(scopeToWork, audioPathInsideScope);
    NAT.AudioPlayer.AudioData audioData = NAT.AudioPlayer.GetAudioDataWithoutPlay(NAT.Files.Scope.AppFiles, "exampleMusic.mp3");   //<- Here we get the data of audio "exampleMusic.mp3" that is in the root of scope "AppFiles"

    Debug.Log("Audio Title: " + audioData.title);
    Debug.Log("Audio Artist: " + audioData.artist);
}
                    </code></doc.code>
                    The table below contains all the data that object <doc.detach>AudioData</doc.detach> returned by method <doc.detach>GetAudioDataWithoutPlay()</doc.detach> can contain.
                    <doc.table>
                        <doc.tablecw>25%=>auto</doc.tablecw>
                        <doc.tablec>Property=>Description</doc.tablec>
                        <doc.tabler>path=>Informs the absolute path to the read file.</doc.tabler>
                        <doc.tabler>isAudio=>Informs if the readed file is really a valid audio file and supported by the system.</doc.tabler>
                        <doc.tabler>title=>Returns the title or name of the audio file, according to the metadata.</doc.tabler>
                        <doc.tabler>artist=>Returns the artist name of the audio file, according to the metadata.</doc.tabler>
                        <doc.tabler>album=>Returns the album name of the audio file, according to the metadata.</doc.tabler>
                        <doc.tabler>duration=>Informs the total duration of this audio file.</doc.tabler>
                    </doc.table>
                    <doc.warn>
                        Note that if you are accessing an audio file outside the <doc.detach>AppFiles</doc.detach> and <doc.detach>AppCache</doc.detach> scopes, you will need <doc.detach>Access Files And Media</doc.detach> permission.
                    </doc.warn>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Audio Player: Playing Audios Files natively using streaming without loading to Unity -->
                <doc.topic topicid="198">
                    <doc.topictitle>Audio Player: Playing Audios Files natively using streaming without loading to Unity</doc.topictitle>

                    In this topic you will learn how to natively play audio files that are in the device memory, using the Media Player of the Android system. Note that the Media Player on the Android system is not an "application" but a
                    feature for playing media files that uses streaming to play audio files. That way you can play audios in your application, without Unity processing them, making it very easy to play and control audios, even if they are
                    huge files. Thanks to this class, your application will be able to play audio from the device's internal memory, without causing delays or crashes on the device while your application is running.

                    <doc.topicsubtitle>What to do before starting to play</doc.topicsubtitle>
                    First, you need to keep in mind that NAT will not allow more than one audio file to be played at the same time. That's why it's important to check if there isn't already an audio file being played. For that you can use
                    the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isPlayingAudio();
    bool isAlreadyPlaying = NAT.AudioPlayer.isPlayingAudio();
}
                    </code></doc.code>

                    <doc.topicsubtitle>Starting to play</doc.topicsubtitle>
                    To start playing an audio file your application must first check that there isn't already an audio file being played. If it doesn't exist then it is only necessary to register a callback in the related event and use the
                    NAT API method to start playing the audio. See example below!
                    <br>
                    <br>
                    Note that this method uses the Android system Scoped Storage system, you can learn about it <a href="#171">here</a> and <a href="#172">here</a>.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //Check if is already playing audio
    if (NAT.AudioPlayer.isPlayingAudio() == false)
    {
        //First, register the callbacks...

        //- onAudioPlayerFinishedPlaying()
        NATEvents.onAudioPlayerFinishedPlaying += () =>
        {
            Debug.Log("The audio file has reached the end.");
        };

        //Second, call the code of the NAT C# API

        //- PlayAudio(scopeToWork, audioPathInsideScope);
        NAT.AudioPlayer.PlayAudio(NAT.Files.Scope.AppFiles, "amazing-music.mp3");   //<- Here we start playing the "amazing-music.mp3" audio that is at the root of the "AppFiles" scope
    }
    if (NAT.AudioPlayer.isPlayingAudio() == true)
        Debug.LogError("There is already an audio file being played.");
}
                    </code></doc.code>
                    <doc.info>
                        If you try to play an audio file not supported by the device, or if you try to play a file that is not an audio file (such as txt, avi, etc) the sound player will simply not start playing and nothing will happen.
                        <br>
                        <br>
                        Before starting to play the audio file, if you like, you can use the <doc.detach>GetAudioDataWithoutPlay()</doc.detach> method to check that the file is indeed a valid audio file.
                    </doc.info>

                    <doc.topicsubtitle>Pausing playback</doc.topicsubtitle>
                    To pause the playback of the audio file, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- PauseAudio();
    NAT.AudioPlayer.PauseAudio();
}
                    </code></doc.code>
                    <doc.info>
                        Even if you pause the audio file that is playing, method <doc.detach>isPlayingAudio()</doc.detach> will still return <doc.detach>true</doc.detach>.
                    </doc.info>
                    To continue playing the audio file, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- PlayAudio();
    NAT.AudioPlayer.PlayAudio();
}
                    </code></doc.code>
                    <doc.warn>
                        Note that these two methods will not work if there is no audio file playing!
                    </doc.warn>

                    <doc.topicsubtitle>Stopping audio file playback</doc.topicsubtitle>
                    To stop playing the currently playing audio file, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- StopAudio();
    NAT.AudioPlayer.StopAudio();
}
                    </code></doc.code>
                    <doc.info>
                        If there is an audio file being played, and you use this method, then the audio file will be completely stopped and method <doc.detach>isPlayingAudio()</doc.detach> will return <doc.detach>false</doc.detach>. Waiting
                        until the audio file reaches the end will stop playing the audio file completely and automatically as well.
                    </doc.info>
                    <doc.warn>
                        Note that these method will not work if there is no audio file playing!
                    </doc.warn>

                    <doc.topicsubtitle>Getting playback progress</doc.topicsubtitle>
                    To get the playback progress, use the code below. This method returns a percentage value from <doc.detach>0.0</doc.detach> to <doc.detach>1.0</doc.detach> that indicates the current progress of the audio being played.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- GetAudioPart();
    float currentProgressOfPlayback = NAT.AudioPlayer.GetAudioPart();
}
                    </code></doc.code>
                    <doc.warn>
                        Note that these method will not work if there is no audio file playing!
                    </doc.warn>

                    <doc.topicsubtitle>Defining the part of the audio to be played</doc.topicsubtitle>
                    To manually define the part of the audio to be played, use the code below. This method defines the part of the audio that will be played, you must use a value from <doc.detach>0.0</doc.detach> to
                    <doc.detach>1.0</doc.detach> indicating the progress.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- SetAudioPart(desiredPart);
    NAT.AudioPlayer.SetAudioPart(0.5f);   //<- Here we define that the audio playback should skip halfway
}
                    </code></doc.code>
                    <doc.warn>
                        Note that these method will not work if there is no audio file playing!
                    </doc.warn>

                    <doc.topicsubtitle>Setting the playback volume</doc.topicsubtitle>
                    To set the playback volume, use the method below. In this method you must inform a value between <doc.detach>0.0</doc.detach> and <doc.detach>100.0</doc.detach> float.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- SetAudioVolume(leftVolume, rightVolume);
    NAT.AudioPlayer.SetAudioVolume(75.0f, 75.0f);   //<- Here we set the volume of the left and right sides to 75%
}
                    </code></doc.code>
                    <doc.warn>
                        Note that these method will not work if there is no audio file playing!
                    </doc.warn>

                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>Access Files And Media (depending of scope)=>None=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Play Games: About This Class -->
                <doc.topic topicid="206">
                    <doc.topictitle>Play Games: About This Class</doc.topictitle>

                    This class allows your application to connect to and use Google Play Games. It is an easy way to implement Google Play Games in your app or game supporting all Google Play Games features like friends list, achievements,
                    events, cloud saving in a very functional and easy to manage way and etc.

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Play Games: Configuring Play Games, Achievements, Events and Leaderboars for your Application -->
                <doc.topic topicid="207">
                    <doc.topictitle>Play Games: Configuring Play Games, Achievements, Events and Leaderboars for your Application</doc.topictitle>

                    In this topic, the process of configuring Google Play Games on the Google Play Console will be discussed and after that the process of configuring the Native Android Toolkit to prepare it for the use of Google Play
                    Games. In the next topics, how to implement and use Google Play Games in your application code will be covered.
                    <doc.warn>
                        Note that this topic assumes that you already have your application published on the Google Play Store.
                    </doc.warn>

                    <doc.topicsubtitle>Enabling Play Games in your app on Google Play Console</doc.topicsubtitle>
                    Before you can start using Google Play Games with the Native Android Toolkit, you need to prepare your project on the Google Play Console to support Play Games.
                    <doc.info>
                        If you already have Google Play Games enabled for your application on the Google Play Console, then you can skip this subtopic and move on to the next subtopic. You will only need to enter your application's
                        <doc.detach>App ID</doc.detach>, <doc.detach>Package Name</doc.detach> and <doc.detach>XML Resources</doc.detach> in the NAT Preferences.
                        <br>
                        <br>
                        If Google Play Games is not enabled for your application, continue with the steps below.
                    </doc.info>
                    <doc.list isnumeric="true">
                        <doc.listr>Make sure your app on the Play Games Console is marked as "Game", go to the Google Play Console, select your game, go to Growth &gt; Store Presence &gt; Store Settings &gt; App Category &gt; App Or Game &gt; Check "Game"</doc.listr>
                        <doc.listr>Go to Growth &gt; Google Play Games Related Services &gt; Settings & Management &gt; Setup</doc.listr>
                        <doc.listr>
                            If you've already configured Google Play Games in your app, skip this step, but if you've never configured it, choose one of the options below...
                            <doc.list>
                                <doc.listr><b>Yes, my game already uses Google APIs:</b> Choose this option if your app already uses a service (such as Firebase or Google Maps) and has a project on Google Cloud. When choosing this option you will only need to select which Google Cloud project references your app.</doc.listr>
                        <doc.listr><b>My game does not use Google APIs:</b> Choose this option if your app does not use any Google services and does not have a project linked to it on Google Cloud.</doc.listr>
                    </doc.list>
                    Click the "Use" button in the bottom right corner to continue. A Play Games project will be created and linked to your new or existing Google Cloud project. You will be taken to the Google Play Games configuration screen
                    in your app.
                    </doc.listr>
                    <doc.listr>In the "Properties" section you can provide name, description, icon and other resources for your game on Google Play Games.<br><br><b>REMEMBER:</b> If you edit your game properties, leave the "Saved Games" option as "On" to allow the Native Android Toolkit Google Play Games saving features to work in the future.</doc.listr>
                    <doc.listr>
                        If the objective "Create the OAuth permission screen on Google Cloud Platform" appears as not completed in the settings screen, a warning will appear in the "Credentials" section asking you to configure your OAuth consent screen before adding credentials.
                        <doc.list>
                            <doc.listr>In this warning do nothing for now</doc.listr>
                    <doc.listr>Return to Google Cloud and select your project to work on</doc.listr>
                    <doc.listr>Click the menu in the upper left corner and then APIs and Services &gt; APIs and Services enabled &gt; OAuth Permission Screen</doc.listr>
                    <doc.listr>Select "Externally" to make the OAuth consent screen available to everyone</doc.listr>
                    <doc.listr>Provide an app name and user support email. The app name must be spelled exactly the same as it is on the Play Store. DO NOT provide a logo image as it is not required and if you do, this OAuth consent screen will need to go through validation by the Google team, which can take 4-6 weeks. if you follow this guide without uploading a logo image, your OAuth consent screen will not need to pass validation as it is an OAuth consent screen in the standard format for use by Google Play Games! You also don't need to provide the "App Domain" data.</doc.listr>
                    <doc.listr>Click "Save and Continue"</doc.listr>
                    <doc.listr>Click "Add or Remove Scopes"</doc.listr>
                    <doc.listr>
                        Search for the "games", "games_lite" and "drive.appdata" scopes and mark them. After checking all, click "Update".
                        <doc.list>
                            <doc.listr>If you don't find these scopes, go to "Library" and search for "Google Play Game Services" API and enable it.</doc.listr>
                    <doc.listr>Press F5 to refresh the Google Cloud page.</doc.listr>
                    <doc.listr>Return to "OAuth Permission Screen" to continue.</doc.listr>
                    </doc.list>
                    </doc.listr>
                    <doc.listr>Click "Save and Continue"</doc.listr>
                    <doc.listr>Add test users. You MUST add your google account email linked to this project so you can test Play Games.</doc.listr>
                    <doc.listr>Click "Save and Continue"</doc.listr>
                    <doc.listr>In the Summary, click "Back to Dashboard"</doc.listr>
                    <doc.listr>After returning to the Dashboard, click on "Publish Application" and then click on "Confirm"</doc.listr>
                    <doc.listr>As we prepare an OAuth screen for use in Google Play Games, after we publish it it will already be public available, however, if you make sensitive changes in the future, you will need to send it for verification so that the Google team can verify it.</doc.listr>
                    <doc.listr>Go back to the Google Play Console, on the screen before and click "Refresh" on the prompt.</doc.listr>
                    </doc.list>
                    </doc.listr>
                    <doc.listr>
                        If the "Create Credentials" objective appears on the settings screen, click "Add Credential" in the "Credentials" section.
                        <doc.list>
                            <doc.listr>You will be redirected to the "Add Credential" screen</doc.listr>
                    <doc.listr>Under "Type": Select "Android"</doc.listr>
                    <doc.listr>In "Name": Leave the name of your application</doc.listr>
                    <doc.listr>In "Enable Anti-Piracy": Leave "Enabled"</doc.listr>
                    <doc.listr>Click "Save Changes" to continue.</doc.listr>
                    <doc.listr>
                        In the Authorization section, under "OAuth Client", select an OAuth Client for your game.
                        <doc.list>
                            <doc.listr>If none appear, click "Create an OAuth Client". Save the "Type", "Name", "Digital Fingerprint" and "Package Name" information. Do not close this window.</doc.listr>
                    <doc.listr>Return to Google Cloud and select your project to work on.</doc.listr>
                    <doc.listr>Click the menu in the top left corner and then APIs and Services &gt; APIs and Services enabled &gt; Credentials &gt; Create Credentials &gt; OAuth Client ID</doc.listr>
                    <doc.listr>Enter the TYPE of application, based on the information you saved from the instruction window. (make sure you don't make any mistakes like accidentally adding extra spaces)</doc.listr>
                    <doc.listr>Enter the NAME of the application, based on the information you saved from the instruction window. (make sure you don't make any mistakes like accidentally adding extra spaces)</doc.listr>
                    <doc.listr>Enter the PACKAGE NAME of the application, based on the information you saved from the instruction window. (make sure you don't make any mistakes like accidentally adding extra spaces)</doc.listr>
                    <doc.listr>Enter the Fingerprint for SHA-1 certification, based on the information you saved from the instruction window. (make sure you don't make any mistakes like accidentally adding extra spaces)</doc.listr>
                    <doc.listr>Click "Create"</doc.listr>
                    <doc.listr>Now the OAuth Client ID is ready. This change can take anywhere from 5 minutes to a few hours to complete.</doc.listr>
                    <doc.listr>Go back to the Google Play Console and close the window with the instructions by clicking "Done"</doc.listr>
                    <doc.listr>The OAuth Client created earlier should now appear. Select it under "OAuth Client" in the "Authorization" section</doc.listr>
                    </doc.list>
                    </doc.listr>
                    <doc.listr>Click "Save Changes" now to continue.</doc.listr>
                    <doc.listr>Click Growth &gt; Google Play Games Related Services &gt; Settings & Management &gt; Setup, to go back to the previous screen.</doc.listr>
                    </doc.list>
                    </doc.listr>
                    <doc.listr>If the objective "Add the Google Play Game Services SDK to your production APK to use the APIs" appears in the settings screen, you must submit a new APK/AAR version of your app containing the Native Android Toolkit at your project.</doc.listr>
                    <doc.listr>Still on the settings screen, check below your app name. You will find a number in format like 477600566033 next to "Project ID". This is your App ID for your Google Play Games project. Copy that number and go back to Unity, then go to Tools &gt; MT Assets &gt; Native Android Toolkit &gt; Preferences &gt; Play Games. Paste the App ID you copied into the "Play Games App ID" field. In the same Play Console screen, in the credentials, copy the package name and paste it in "Play Games Pack. Name" in the NAT, and then click "Save Preferences".</doc.listr>
                    </doc.list>
                    <doc.achiev>
                        If you successfully completed all the previous steps, then your application is ready to run Google Play Games. Publish the changes made to the Google Play Games project and publish the new version of your APK,
                        uploaded containing the Native Android Toolkit installed in the Unity project, and follow along to understand how to add achievements, events, leaderboards, etc.
                    </doc.achiev>

                    <doc.topicsubtitle>Configuring your application so that you can test Google Play Games</doc.topicsubtitle>
                    When you download your application that has Google Play Games enabled directly from the Play Store, your application will be able to access Play Games, however, if you compile your Unity project into an APK and install
                    it on your device, Play Games may not work because your app was taken from Unity. In this subtopic you will learn how to configure your application in the Play Store Console to allow you to test Google Play Games without
                    the need to upload your APKs to the Play Store.
                    <br>
                    <br>
                    You can also configure the Google Play Console to allow you to be able to sign in to Google Play Games while you develop and test your game, without the need to upload APKs to Google Play. That way you can build your
                    APKs while developing your game, send them to your phone and even test with the Google Play Games login, without the need to send a new version of your APK to Google Play and publish it to be able to test how it's
                    working. To do so, follow the steps below...
                    <doc.list isnumeric="true">
                        <doc.listr>Go to the Google Play Console and access your app.</doc.listr>
                        <doc.listr>In the "Versions" section click Test &gt; Internal test</doc.listr>
                        <doc.listr>Create at least one version of your APK with the Native Android Toolkit installed and submit it to the internal test track. You DO NOT need to promote this version to "Production" later if you prefer.</doc.listr>
                        <doc.listr>Still under "Internal Testing" go to the "Testers" tab</doc.listr>
                        <doc.listr>Access the list of standard testers</doc.listr>
                        <doc.listr>Make sure your Google account email is added to the list under "Added email addresses". If not, add your email.</doc.listr>
                        <doc.listr>Click "Save Changes"</doc.listr>
                        <doc.listr>In the section "How testers can participate in your test" click on "Copy link", open a new tab of your browser, paste the copied link and access it.</doc.listr>
                        <doc.listr>Click on "Accept Invitation" and that way you will be included in the track of internal tests, enabled as a tester. Whenever you want, you can leave or enter the internal test, whenever you prefer, just access the same link used. Go back to the Play Console</doc.listr>
                        <doc.listr>In growth, go to Google Play Games Related Services &gt; Setup & Management &gt; Testers</doc.listr>
                        <doc.listr>In the "Testers" tab, click "Add testers", enter your email address and click "Add"</doc.listr>
                        <doc.listr>In the "Release Tracks" tab, click "Add Tracks", select the "Internal" release track that has your app name and click "Add Track"</doc.listr>
                        <doc.listr>
                            Now we need to get the SHA-1 for your keystore file, which you use to sign your app when you build your APKs in Unity. To do so, follow the steps below...
                            <doc.list>
                                <doc.listr>Look on your computer where your JDK is installed. Access it and then go to the "bin" directory and make a note of the path of your JDK "bin" folder.</doc.listr>
                        <doc.listr>Browse your computer for the keystore file you use to sign your APKs when building with Unity, make a note of the path to the keystore file you use.</doc.listr>
                        <doc.listr>
                            Open your operating system terminal and type the commands below, substituting the necessary values (no need to remove quotes)...
                            <doc.list>
                                <doc.listr>cd "path-to-your-JDK-bin-folder"</doc.listr>
                        <doc.listr>keytool -exportcert -keystore "path-to-your-Keystore-file" -list -v</doc.listr>
                    </doc.list>
                    </doc.listr>
                    <doc.listr>Enter your keystore password (this is the same password you enter for Unity when building your APK)</doc.listr>
                    <doc.listr>After entering your keystore password, you will be able to see all information regarding your key. You will also be able to see the SHA-1 digital signature, copy it and keep it as we will need it later.</doc.listr>
                    </doc.list>
                    </doc.listr>
                    <doc.listr>Go to your Google Cloud. Access the project for your application.</doc.listr>
                    <doc.listr>Click on the 3 bar menu in the top left corner, then APIs and Services &gt; Enabled APIs and Services &gt; Credentials.</doc.listr>
                    <doc.listr>On your credentials screen, you will notice that you already have a previously created credential for the Play Games service in your app. This credential refers to your app APKs, which are distributed through Google Play, as Google Play signs your APK with a different certificate and SHA-1. You do not need to, and should not, modify this credential. Now we need to create one more credential that will refer to the APKs built by your Unity during its development and internal tests while you develop your app.</doc.listr>
                    <doc.listr>Click Create Credentials &gt; OAuth Client ID</doc.listr>
                    <doc.listr>Under "Application type", select "Android"</doc.listr>
                    <doc.listr>In "Name", put the exact name of your app, just like it is in the Play Store, and also put the suffix " (Unity)". For example: "Native Android Toolkit App (Unity)". This way we will know that this credential refers to Unity, for internal testing and development.</doc.listr>
                    <doc.listr>In "Package Name", put your app's package name. It should be the same name as the package, which appears in your Google Play Games project.</doc.listr>
                    <doc.listr>In "Digital Fingerprint for SHA-1 certification" put the SHA-1 fingerprint you copied earlier.</doc.listr>
                    <doc.listr>Click "Create". That's it, the credential referring to the internal tests for APKs built by Unity is already ready.</doc.listr>
                    <doc.listr>Now, go back to the Google Play Console and sign in to your app.</doc.listr>
                    <doc.listr>Under Growth, go to Google Play Game Related Services &gt; Setup & Management &gt; Setup</doc.listr>
                    <doc.listr>Now we need to add one more credential, in this Google Play Games project, referring to the new Client ID we created earlier. In the "Credentials" section, click "Add Credential".</doc.listr>
                    <doc.listr>In "Type", leave "Android"</doc.listr>
                    <doc.listr>In "Name", leave the name the way it is, exactly as it is in the Play Store, as it needs to be the same as the name of the app in the Play Store.</doc.listr>
                    <doc.listr>In "Use for new installations" leave it UNCHECKED, as this credential should not be used as the default for new installations, as it is only for internal testing.</doc.listr>
                    <doc.listr>In "Enable Anti-Piracy" leave "Disabled"</doc.listr>
                    <doc.listr>Under "OAuth Client", select the OAuth client we created earlier on Google Cloud, the one with the suffix " (Unity)"</doc.listr>
                    <doc.listr>Click "Save Changes".</doc.listr>
                    <doc.listr>Under Growth, go to Google Play Game Related Services &gt; Setup & Management &gt; Setup</doc.listr>
                    <doc.listr>Click the "Review and Publish" button</doc.listr>
                    <doc.listr>You will be taken to the "Publishing" screen. Now click on "Publish" and confirm by clicking on "Publish Changes".</doc.listr>
                    </doc.list>
                    Wait a few minutes. Find the "Google Play Services" app on your Android device and clear the app's cache. Now, go back to Unity, make sure the Play Games information in the Native Android Toolkit Preferences is correct.
                    Build your game, generating an APK signed with your Unity keystore, the normal procedure. Install this APK on your Android device (You can also click "Build And Run"). Now it's just testing Google Play Games in your game
                    while developing it in-house! People who download your game through the Play Store, publicly, will log in to Play Games using the default public credential and you, while developing your game, as a tester, will use the
                    credential that we just created, with the suffix " (Unity)", only during testing while developing your game.
                    <br>
                    <br>
                    If you want to download your application from the Play Store, the public version of your app, as if you were a normal user of your app, you need to access the internal test link and exit the internal test. If you want to
                    download the internal test version of your app as a tester from the Play Store, you must go to the link and join the internal test. You can also submit new versions for internal testing, and others who follow the link
                    and accept your invitation to participate in internal testing will be able to download those versions that you submit. Later if you want, you can just promote a certain version of the internal test to become a Production
                    version, which will make the internal test version you promoted, become a public, Production version, available to everyone users of the Play Store platform.
                    <br>
                    <br>
                    <b>One more tip for your development</b>
                    <br>
                    <br>
                    As you implement NAT Play Games in your application, you can have NAT Play Games emit detailed logs to debug how NAT Play Games works in your app. For that, you need a logcat tool to access the logs emitted by your app.
                    You can use Unity <doc.detach>Android Logcat</doc.detach>, which can be obtained through the Package Manager. To execute the ADB command that activates the emission of the logs, you can use the tool
                    <a href="https://assetstore.unity.com/packages/tools/utilities/native-android-debugger-mt-wireless-debug-adb-manager-more-198639" target="_blank">Native Android Debugger MT</a> which is free, created by MT Assets as
                    well. So with your phone connected via ADB, use the command <doc.detach>adb shell setprop log.tag.Games VERBOSE</doc.detach> and then you'll only need to monitor the logs emitted by your app in
                    <doc.detach>Android Logcat</doc.detach> and debug. To disable NAT Play Games logging, use the <doc.detach>adb shell setprop log.tag.Games INFO</doc.detach> command. With NAT Play Games logging turned on, you might be
                    able to get valuable information to debug your application in case you encounter any bugs or issues like error logging into Play Games or other things.

                    <doc.topicsubtitle>Configuring your application Achievements</doc.topicsubtitle>
                    Before using NAT Play Games Achievements API, you need to create one or more achievements for your app in the Google Play Console. To do so, follow the steps below...
                    <doc.list isnumeric="true">
                        <doc.listr>Go to the Google Play Console and access your app.</doc.listr>
                        <doc.listr>In growth, go to Google Play Game Related Services &gt; Setup & Management &gt; Achievements</doc.listr>
                        <doc.listr>Click "Create Achievement"</doc.listr>
                        <doc.listr>Provide a name, description, icon.</doc.listr>
                        <doc.listr>Under "Incremental Achievement", check if you want achievement to be the basis of progress. It will be necessary to use NAT Play Games API to provide progress, until the player reaches the maximum by completing the achievement and unlocking it.</doc.listr>
                        <doc.listr>Under "Initial state" select "revealed" or "hidden". If you select "hidden", you will need to use NAT Play Games API to reveal it.</doc.listr>
                        <doc.listr>In points, define how many points that achievement will be worth. Each application can distribute a limited amount of points, so it is advisable that you set this to "5".</doc.listr>
                        <doc.listr>Click "Save as draft".</doc.listr>
                        <doc.listr>In growth, go to Google Play Game Related Services &gt; Setup & Management &gt; Achievements</doc.listr>
                        <doc.listr>Click "Review and Publish"</doc.listr>
                        <doc.listr>On the screen you were taken to, click "Publish" and then "Publish Changes".</doc.listr>
                        <doc.listr>That's it, the achievement has already been set up in the Google Play Console. Repeat these steps to keep creating more achievements!</doc.listr>
                    </doc.list>
                    <doc.info>
                        Whenever you add a new achievement, event or leaderboard to the Google Play Developer Console, you need to click on "View Resources", "Android (XML)" and then copy everything in the text field
                        and paste in Unity, under Tools &gt; MT Assets &gt; Native Android Toolkit &gt; Preferences &gt; Play Games &gt; Play Games Resources. Then click "Save Preferences". That's how the Native Android Toolkit
                        will know about all existing achievements, events and leaderboards for your game and make them available in C# code so you can access them in your app using the NAT Play Games C# API!
                    </doc.info>

                    <doc.topicsubtitle>Configuring Events for your application</doc.topicsubtitle>
                    Before using the Play Games NAT Events API, you need to create one or more events for your app on Google Play Games. Events are methods of getting metrics from your game. For example, you create an event named "Dead
                    Spiders", so every time a player kills a spider in your game, you use the NAT API to increment it, informing how many spiders were killed at the end of each battle. That way, on your Play Console, you can see that count.
                    To create an event, follow the steps below...
                    <doc.list isnumeric="true">
                        <doc.listr>Go to the Google Play Console and access your app.</doc.listr>
                        <doc.listr>In growth, go to Google Play Game Related Services &gt; Setup & Management &gt; Events</doc.listr>
                        <doc.listr>Click "Create Event"</doc.listr>
                        <doc.listr>Provide a name.</doc.listr>
                        <doc.listr>Provide the event type. "None" if it's just a standard count, "Coin Source" if it's amounts of any coins earned, "Coin Spend" if it's an amount of coins spent.</doc.listr>
                        <doc.listr>Provide the format.</doc.listr>
                        <doc.listr>By checking the "Include custom units" box, you can enter a custom name that will be placed next to the number. For example, supplying "Day" will cause the number to appear as "342Days".</doc.listr>
                        <doc.listr>Provide an icon, mark the initial state of the event, whether it will be Revealed or Hidden.</doc.listr>
                        <doc.listr>Click "Save as draft".</doc.listr>
                        <doc.listr>In growth, go to Google Play Game Related Services &gt; Setup & Management &gt; Events</doc.listr>
                        <doc.listr>Click "Review and Publish"</doc.listr>
                        <doc.listr>On the screen you were taken to, click "Publish" and then "Publish Changes".</doc.listr>
                        <doc.listr>That's it, the event has already been set up in the Google Play Console. Repeat these steps to continue creating more events!</doc.listr>
                    </doc.list>
                    <doc.info>
                        Whenever you add a new achievement, event or leaderboard to the Google Play Developer Console, you need to click on "View Resources", "Android (XML)" and then copy everything in the text field
                        and paste in Unity, under Tools &gt; MT Assets &gt; Native Android Toolkit &gt; Preferences &gt; Play Games &gt; Play Games Resources. Then click "Save Preferences". That's how the Native Android Toolkit
                        will know about all existing achievements, events and leaderboards for your game and make them available in C# code so you can access them in your app using the NAT Play Games C# API!
                    </doc.info>

                    <doc.topicsubtitle>Configuring Leaderboards for your application</doc.topicsubtitle>
                    Before using the Play Games NAT Leaderboards API, you need to create a leaderboard for your app on Google Play Games. Leaderboards are a score ranking that organizes the best scores down to the worst scores. For example,
                    you create a Leaderboard called "The richest", then you can use the NAT API to send the amount of coins that a certain player has, and then if he is the player with the most coins in your friend circle, in the country or
                    in the world, it will be in 1st place according to the applied filter. To create a leaderboard, follow the steps below...
                    <doc.list isnumeric="true">
                        <doc.listr>Go to the Google Play Console and access your app.</doc.listr>
                        <doc.listr>In growth, go to Google Play Game Related Services &gt; Setup & Management &gt; Leaderboards</doc.listr>
                        <doc.listr>Click "Create Scoreboard"</doc.listr>
                        <doc.listr>Provide a name.</doc.listr>
                        <doc.listr>Provide the format.</doc.listr>
                        <doc.listr>By checking the "Include custom units" box, you can enter a custom name that will be placed next to the number. For example, supplying "Day" will cause the number to appear as "342Days".</doc.listr>
                        <doc.listr>Provide an icon, choose the sort order, and enable Tamper Protection.</doc.listr>
                        <doc.listr>You can also set the highest allowed score, or the lowest allowed score.</doc.listr>
                        <doc.listr>Click "Save as draft".</doc.listr>
                        <doc.listr>In growth, go to Google Play Game Related Services &gt; Setup & Management &gt; Leaderboards</doc.listr>
                        <doc.listr>Click "Review and Publish"</doc.listr>
                        <doc.listr>On the screen you were taken to, click "Publish" and then "Publish Changes".</doc.listr>
                        <doc.listr>That's it, the leaderboard has already been set up in the Google Play Console. Repeat these steps to continue creating more leaderboards!</doc.listr>
                    </doc.list>
                    <doc.info>
                        Whenever you add a new achievement, event or leaderboard to the Google Play Developer Console, you need to click on "View Resources", "Android (XML)" and then copy everything in the text field
                        and paste in Unity, under Tools &gt; MT Assets &gt; Native Android Toolkit &gt; Preferences &gt; Play Games &gt; Play Games Resources. Then click "Save Preferences". That's how the Native Android Toolkit
                        will know about all existing achievements, events and leaderboards for your game and make them available in C# code so you can access them in your app using the NAT Play Games C# API!
                    </doc.info>

                    <doc.topicsubtitle>A little more knowledge</doc.topicsubtitle>
                    If you prefer, you can read Google <a href="https://developers.google.com/games/services/checklist" target="_blank">list of best practices</a> to prevent your game from rapidly consuming Google Cloud quota when using the
                    Play Games APIs, as well as other best practices.
                    <br>
                    <br>
                    This <a href="https://developer.android.com/games/pgs/android/troubleshooting" target="_blank">link</a> may be helpful if you have any issues with Play Games in your app.
                    <doc.warn>
                        If you followed all the steps of this topic correctly for configuring your Google Play Games project, you shouldn't have any problems, but if you do, check the link above. If still, you have
                        difficulties, need some information regarding the Native Android Toolkit, or believe that something in the Native Android Toolkit is incorrect, please, contact MT Assets Support.
                    </doc.warn>
                    <br>
                    <br>
                    <doc.achiev>
                        And here was the whole theory! If you read this entire topic, you learned how to... Enable Google Play Games for your app, Enable internal testing for Google Play Games, Configure Events, Configure Achievements,
                        Configure Leaderboards and more!
                        <br>
                        <br>
                        Now, in the next topic we will talk about practice! You'll learn the basics of integrating NAT Play Games into your application's C# code.
                    </doc.achiev>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Play Games: Everything you need to know about the NAT Play Games API -->
                <doc.topic topicid="208">
                    <doc.topictitle>Play Games: Everything you need to know about the NAT Play Games API</doc.topictitle>

                    Before we start talking about the basics of integrating Play Games in your application, you need to keep in mind that the Native Android Toolkit needs to be configured in order to be able to use Google Play Games in your
                    application. Your application <doc.detach>App ID</doc.detach> referring to Google Play Games, <doc.detach>Package Name</doc.detach> and <doc.detach>Play Games XML Resources</doc.detach> need to be informed to Native
                    Android Toolkit through Preferences. To learn how to do this and more, see this thread.

                    <doc.topicsubtitle>Starting</doc.topicsubtitle>
                    To start with, you need to register a callback for the <doc.detach>onPlayGamesInitializationComplete</doc.detach> event <b>BEFORE</b> your application initialize the Native Android Toolkit. See sample code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- onPlayGamesInitializationComplete(userIsSignedIn, userDataIfSigned)
    NATEvents.onPlayGamesInitializationComplete += (bool userSignedIn, NAT.PlayGames.UserData userData) =>
    {
        if (userSignedIn == true)
        {
            Debug.Log("Hello " + userData.displayName + "! You have been connected to Google Play Games!");
        }
    };
    
    //Second, call the code of the NAT C# API
    
    if (NativeAndroidToolkit.isInitialized == false)
        NativeAndroidToolkit.Initialize();
    
    //...
}
                    </code></doc.code>
                    It is extremely necessary that <doc.detach>onPlayGamesInitializationComplete</doc.detach> event has a callback registered <b>BEFORE</b> your application initializes the NAT because when the Native Android Toolkit is
                    initialized by your application, it automatically initializes the Google Play Games module. Registering just one callback for this event is enough.
                    <br>
                    <br>
                    This way, when Play Games is started you will receive a callback through this event that will inform you if the user is currently logged in or not. In addition to also returning ALL user data (like level, display name,
                    etc), if he is logged in.
                    <br>
                    <br>
                    Event <doc.detach>onPlayGamesInitializationComplete</doc.detach> will always run when NAT is initialized. This event will always return a BOOL value that indicates if the user is currently logged in and will also return
                    an object of type <doc.detach>UserData</doc.detach> that contains all the user's data, but only if the user is logged in. Therefore, before seeing the user's data, use the BOOL value to check if the user is logged in.
                    See the example below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    NATEvents.onPlayGamesInitializationComplete += (bool userSignedIn, NAT.PlayGames.UserData userData) =>
    {
        if (userSignedIn == true)
        {
            Debug.Log("The user is logged in!");
            Debug.Log("Nickname: " + userData.displayName);
            Debug.Log("Level: " + userData.currentLevel);
            Debug.Log("Player ID: " + userData.playerId);
        }
        if (userSignedIn == false)
        {
            Debug.Log("The user is NOT logged in.");
        }
    };
}
                    </code></doc.code>
                    In the table below you can see all the properties that can be read in the <doc.detach>UserData</doc.detach> object returned by this event...
                    <doc.table>
                        <doc.tablecw>25%=>auto</doc.tablecw>
                        <doc.tablec>Property/Method=>Description</doc.tablec>
                        <doc.tabler>lastUserDataUpdate=>The date on which the last update of user data occurred.</doc.tabler>
                        <doc.tabler>displayName=>The user's display name (or nickname).</doc.tabler>
                        <doc.tabler>title=>Contains the user's title.</doc.tabler>
                        <doc.tabler>playerId=>Returns this user's unique Google Play Games ID.</doc.tabler>
                        <doc.tabler>hasIconImage=>Informs if this user has a profile picture.</doc.tabler>
                        <doc.tabler>iconImagePathInAppFilesScope=>Informs the path to the user's profile image, within the <doc.detach>AppFiles</doc.detach> scope (if the user has a photo)</doc.tabler>
                        <doc.tabler>currentLevel=>Returns the current user level.</doc.tabler>
                        <doc.tabler>currentLevelMinXp=>Returns the lowest amount of XP at the user's current level.</doc.tabler>
                        <doc.tabler>currentLevelMaxXp=>Returns the highest amount of SP at this level the user is on, needed for the next level.</doc.tabler>
                        <doc.tabler>currentXpTotal=>Shows the total, current XP of the user.</doc.tabler>
                        <doc.tabler>lastLevelUp=>Informs the date referring to the last time the user leveled up.</doc.tabler>
                        <doc.tabler>nextLevel=>Informs what will be the next level of the user.</doc.tabler>
                        <doc.tabler>nextLevelMinXp=>Returns the minimum amount of XP at the next level.</doc.tabler>
                        <doc.tabler>nextLevelMaxXp=>Returns the maximum amount of XP at the next level.</doc.tabler>
                        <doc.tabler>isMaxLevel=>Informs if the user is currently in the last level.</doc.tabler>
                        <doc.tabler>GetUserIconImage()=>Returns an object of type <doc.detach>Texture2D</doc.detach> which is the user's profile picture (if he has one).</doc.tabler>
                    </doc.table>
                    <doc.info>
                        When NAT initialize Play Games, the Google service will always try to authenticate the user automatically, once he has already done the first authentication. Registering the
                        <doc.detach>onPlayGamesInitializationComplete</doc.detach> event always before initializing the NAT, your application will receives a response when the initialization is completed and to know if the user is already
                        logged in or not.
                    </doc.info>
                    <doc.info>
                        Note that the only way to get player data is through this event! Therefore, after receiving the callback of this event, save the player data in your application cache so that it can always be consulted.
                    </doc.info>

                    <doc.topicsubtitle>Logging User into Google Play Games</doc.topicsubtitle>
                    Your application will not be able to use any of the Google Play Games APIs without the user being logged into Play Games first. Therefore, your application must maintain a user verification and login flow.
                    <br>
                    <br>
                    As previously mentioned in the subtopic above, whenever your application initializes the NAT, the NAT initializes Play Games and then Google services will always try to automatically login the user, which causes the
                    <doc.detach>onPlayGamesInitializationComplete</doc.detach> event to run, sending the auto-login callback automatically for your application.
                    <br>
                    <br>
                    Your application after receiving the callback must check whether the user is logged in or not and if the user is not logged in, provide buttons so that the user can perform a manual login. Automatic login of Google
                    Services is only performed if the user has logged in to your application at least once. Therefore, if the user has never logged in to Google Play Games in your application, the automatic login will not be
                    performed. So, whenever your application receives the response from event <doc.detach>onPlayGamesInitializationComplete</doc.detach>, it must check whether the user is logged in or not, and if not, display a button for
                    the user to click and log in. This is where method <doc.detach>DoManualSignIn()</doc.detach> comes in. With it, your application can start a login screen for the user to log in to Google Play Games in your application.
                    See the example below on how to use this method...
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- DoManualSignIn();
    NAT.PlayGames.DoManualSignIn();
}
                    </code></doc.code>
                    <doc.info>
                        After calling method <doc.detach>DoManualSignIn()</doc.detach> to perform a login, you will receive the callback of that login attempt through the <doc.detach>onPlayGamesInitializationComplete</doc.detach> event that
                        you registered a callback to, before NAT initialization.
                        <br>
                        <br>
                        Whenever you call method <doc.detach>DoManualSignIn()</doc.detach>, the login attempt callback will always be sent to the <doc.detach>onPlayGamesInitializationComplete</doc.detach> event you registered before
                        initializing the NAT!
                    </doc.info>
                    Another way to check if the user is currently logged into Google Play Games in your application is to call method <doc.detach>isSignedIn()</doc.detach>. See an example...
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- isSignedIn();
    bool isSignedIn = NAT.PlayGames.isSignedIn();
}
                    </code></doc.code>
                    That is all!
                    <br>
                    <br>
                    <doc.achiev>
                        Well, there is no mystery here! Once you've done the Google Play Games setup in the Play Store Console, configured the Native Android Toolkit, and the user is logged into Play Games in your application, you're ready
                        to use the other NAT Play Games API methods in your application!
                    </doc.achiev>

                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>com.google.android.gms.games, com.google.android.gms.drive (and its dependencies)=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Play Games: Implementing Achievements -->
                <doc.topic topicid="212">
                    <doc.topictitle>Play Games: Implementing Achievements</doc.topictitle>

                    To use Achievements, you must have your application Google Play Games XML resources entered in <doc.detach>Play Games Resources</doc.detach> in the NAT Preferences. If you have done so, Achievements created for your app
                    in the Play Store Console will appear in an ENUM for your application code so that you can select the Achievement in the Native Android Toolkit API, to make calls. If you don't know how to do this, see
                    <a href="#207">this</a> topic.

                    <doc.topicsubtitle>Displaying user Achievements</doc.topicsubtitle>
                    To open a Interface that displays all the achievements of your application, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- ShowAllAchievements();
    NAT.PlayGames.ShowAllAchievements();
}
                    </code></doc.code>

                    <doc.topicsubtitle>Unlocking an Achievement</doc.topicsubtitle>
                    To unlock an achievement for the user, use the code below. You need to select the achievement to be unlocked in the method ENUM.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- UnlockAchievement(achievementToUnlock)
    NAT.PlayGames.UnlockAchievement(PlayGamesResources.Achievement.example_achievement_name);
}
                    </code></doc.code>
                    <doc.info>
                        This method will give the achievement to the user whether it is revealed or not. if the achievement is not revealed yet and you call this method, the achievement will be automatically revealed and unlocked for the
                        user.
                    </doc.info>

                    <doc.topicsubtitle>Revealing a hidden Achievement</doc.topicsubtitle>
                    To reveal an achievement that is hidden from the user, use the code below. You need to select the achievement to be revealed in the method ENUM.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- RevealAchievement(achievementToReveal)
    NAT.PlayGames.RevealAchievement(PlayGamesResources.Achievement.example_achievement_name);
}
                    </code></doc.code>
                    <doc.info>
                        This method will only reveal the achievement. To give it to the user, you'll still need to call <doc.detach>UnlockAchievement()</doc.detach>.
                    </doc.info>

                    <doc.topicsubtitle>Incrementing an Achievement</doc.topicsubtitle>
                    To increment an achievement for the user, use the code below. You need to select the achievement to be incremented in the method ENUM.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- IncrementAchievement(achievementToIncrement, amountToIncrement)
    NAT.PlayGames.IncrementAchievement(PlayGamesResources.Achievement.example_achievement_name, 1);
}
                    </code></doc.code>
                    <doc.info>
                        This method unlocks the achievement (whether it is revealed or not) when the user hits the target points needed to achieve the achievement. For example, if when creating an achievement, you enabled it to be
                        incremental, and it takes 20 steps to complete it, you will need to call this method and pass the parameter <doc.detach>1</doc.detach> whenever the user manages to complete <doc.detach>1</doc.detach> step. When this
                        method is called 20 times, then the achievement will be unlocked for the user automatically, without the need to call <doc.detach>UnlockAchievement()</doc.detach>. Also, you also don't need to implement any
                        additional code in your game to limit the amount of calls to this method or things like that, as it will ignore subsequent calls when the achievement has already been given to the user and will automatically unlock
                        it for the user. when the user completes all the steps.
                    </doc.info>

                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>com.google.android.gms.games, com.google.android.gms.drive (and its dependencies)=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Play Games: Implementing Events -->
                <doc.topic topicid="216">
                    <doc.topictitle>Play Games: Implementing Events</doc.topictitle>

                    To use Events, you must have your application Google Play Games XML resources entered in <doc.detach>Play Games Resources</doc.detach> in the NAT Preferences. If you have done so, Events created for your app
                    in the Play Store Console will appear in an ENUM for your application code so that you can select the Event in the Native Android Toolkit API, to make calls. If you don't know how to do this, see
                    <a href="#207">this</a> topic.

                    <doc.topicsubtitle>Loading Events data</doc.topicsubtitle>
                    To load data from an event, use the code below. You need to select the event to be loaded in the method ENUM.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //First, register the callbacks...
    
    //- onPlayGamesEventDataLoaded(isLoadSuccess, eventDataIfSuccessToLoad)
    NATEvents.onPlayGamesEventDataLoaded += (bool isSuccessfully, NAT.PlayGames.EventData eventData) =>
    {
        if (isSuccessfully == true)
        {
            Debug.Log("Event data loaded! Name: " + eventData.name + ", Value: " + eventData.unformattedValue);
        }
    };
    
    //Second, call the code of the NAT C# API
    
    //- LoadEventData(eventToLoadData, clearCacheAndLoad);
    NAT.PlayGames.LoadEventData(PlayGamesResources.Event.example_event_name, false);
}
                    </code></doc.code>
                    Event <doc.detach>onPlayGamesEventDataLoaded</doc.detach> will return the result of loading the desired event data. This event returns a BOOL value that indicates whether the event data was successfully loaded. Only if
                    this BOOL value is <doc.detach>true</doc.detach> should you try to read object <doc.detach>EventData</doc.detach> to extract the loaded event data. The table below informs all data contained in object
                    <doc.detach>EventData</doc.detach> of a loaded event.
                    <doc.table>
                        <doc.tablecw>25%=>auto</doc.tablecw>
                        <doc.tablec>Property/Method=>Description</doc.tablec>
                        <doc.tabler>name=>Returns the name of the event.</doc.tabler>
                        <doc.tabler>id=>Informs the event ID.</doc.tabler>
                        <doc.tabler>description=>Returns the event description.</doc.tabler>
                        <doc.tabler>formattedValue=>Contains the value of this event, however, formatted in a String.</doc.tabler>
                        <doc.tabler>unformattedValue=>Contains the raw value of this event, without formatting.</doc.tabler>
                        <doc.tabler>isVisible=>Informs if this event is visible to everyone.</doc.tabler>
                        <doc.tabler>iconImagePathInAppFilesScope=>Contains the path to the icon image from this event, within scope <doc.detach>AppFiles</doc.detach> (if have)</doc.tabler>
                        <doc.tabler>GetEventIconImage()=>Returns an object of type <doc.detach>Teture2D</doc.detach> that is the icon of this event (if any)</doc.tabler>
                    </doc.table>
                    <doc.info>
                        This method allows you to clear the cache before loading event data. Only do this if really necessary as this can consume your game processing quota on Google Cloud, if your code always clears the cache and many
                        players end up making calls to this API while playing.
                    </doc.info>

                    <doc.topicsubtitle>Incrementing an Event</doc.topicsubtitle>
                    To increment the value of an event, use the code below. You need to select the event to be incremented in the method ENUM.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- IncrementEvent(eventToIncrement, amountToIncrement);
    NAT.PlayGames.IncrementEvent(PlayGamesResources.Event.example_event_name, 1);
}
                    </code></doc.code>

                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>com.google.android.gms.games, com.google.android.gms.drive (and its dependencies)=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Play Games: Implementing Leaderboards -->
                <doc.topic topicid="218">
                    <doc.topictitle>Play Games: Implementing Leaderboards</doc.topictitle>

                    To use Leaderboards, you must have your application Google Play Games XML resources entered in <doc.detach>Play Games Resources</doc.detach> in the NAT Preferences. If you have done so, Leaderboards created for your app
                    in the Play Store Console will appear in an ENUM for your application code so that you can select the Leaderboard in the Native Android Toolkit API, to make calls. If you don't know how to do this, see
                    <a href="#207">this</a> topic.

                    <doc.topicsubtitle>Show Leaderboards</doc.topicsubtitle>
                    To display leaderboards to the user, use the code below. You need to select the leaderboard to be displayed in the method ENUM.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- ShowTheLeaderboard(leaderboardToShow);
    NAT.PlayGames.ShowTheLeaderboard(PlayGamesResources.Leaderboard.example_leaderboard_name);
}
                    </code></doc.code>

                    <doc.topicsubtitle>Submitting scores to a Leaderboard</doc.topicsubtitle>
                    To submit scores to leaderboards, use the code below. You need to select the leaderboard to send the score in the method ENUM.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- SubmitScoreToLeaderboard(leaderboardToSend, scoreToSend);
    NAT.PlayGames.SubmitScoreToLeaderboard(PlayGamesResources.Leaderboard.example_leaderboard_name, 1);
}
                    </code></doc.code>
                    <doc.info>
                        With this method you are able to update the player score on the leaderboard. You can use this method to update the player's score on the leaderboard, whenever a game ends for example, or from time to time.
                    </doc.info>
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>com.google.android.gms.games, com.google.android.gms.drive (and its dependencies)=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Play Games: Accessing the User Friends List -->
                <doc.topic topicid="220">
                    <doc.topictitle>Play Games: Accessing the User Friends List</doc.topictitle>

                    With NAT Play Games it is possible to access and load the user's friends list. Then you can display the user's friends list, as well as open the profile view, encourage interaction and much more!
                    <br>
                    <br>
                    To load the user's friends list you need to follow this flow...
                    <doc.list>
                        <doc.listr>Check if the user friends list is accessible</doc.listr>
                        <doc.listr>If not, request access</doc.listr>
                        <doc.listr>If accessible, load the user's friends list</doc.listr>
                    </doc.list>
                    Continue reading the next subtopics to understand more about each step.

                    <doc.topicsubtitle>Checking the accessibility of the user Friends List</doc.topicsubtitle>
                    To check the accessibility of the user's friends list, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    bool isAccessible = false;

    //- isFriendListAccessible();
    if (NAT.PlayGames.isFriendListAccessible() == NAT.PlayGames.FriendListAccessibility.Accessible)
        isAccessible = true;
}
                    </code></doc.code>

                    <doc.topicsubtitle>Requesting access to the user Friends List</doc.topicsubtitle>
                    To request access to the user friends list you must first register a callback on the required event and then call the API to request access. See, as below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //First, register the callbacks...
    
    //- onPlayGamesFriendListRequestResult(requestResultStatus)
    NATEvents.onPlayGamesFriendListRequestResult += (bool isUserFriendListAccessibleNow) =>
    {
        if (isUserFriendListAccessibleNow == true)
            Debug.Log("The user friends list is accessible now!");
        
        if (isUserFriendListAccessibleNow == false)
            Debug.Log("The user friends list is not accessible.");
    };
    
    //Second, call the code of the NAT C# API
    
    //- RequestFriendListAccess(requestInterfaceOrientation);
    NAT.PlayGames.RequestFriendListAccess(NAT.PlayGames.FriendAccessInterfaceMode.LandscapeFullscreen);
}
                    </code></doc.code>

                    <doc.topicsubtitle>Loading the user Friends List</doc.topicsubtitle>
                    To load the user friends list you must register a callback on the required event and then call the API method to load the user friends list. In the response, in the event, you will have access to the user friends
                    list. See the example below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //First, register the callbacks...

    //- onPlayGamesUserFriendListLoaded(userFriendList);
    NATEvents.onPlayGamesUserFriendListLoaded += (NAT.PlayGames.FriendList userFriendList) =>
    {
        //Get the list of friends
        NAT.PlayGames.Friend[] userFriends = userFriendList.allUserFriends;

        if (userFriends.Length > 0)
        {
            foreach (NAT.PlayGames.Friend friend in userFriends)
                Debug.Log("Friend found! Name: " + friend.displayName);
        }
        if (userFriends.Length == 0)
            Debug.Log("This user has no friends.");
    };

    //Second, call the code of the NAT C# API

    //- LoadUserFriendList(clearCacheAndLoad);
    NAT.PlayGames.LoadUserFriendList(false);
}
                    </code></doc.code>
                    The <doc.detach>onPlayGamesUserFriendListLoaded</doc.detach> event returns an object of type <doc.detach>FriendList</doc.detach> that contains the variable <doc.detach>allUserFriends</doc.detach> that contains an array
                    containing an object <doc.detach>Friend</doc.detach> for each friend of the user. Querying each <doc.detach>Friend</doc.detach> object you are able to obtain the information of each user's friend. The table below shows
                    all the properties that are possible to read in object <doc.detach>Friend</doc.detach>...
                    <doc.table>
                        <doc.tablecw>25%=>auto</doc.tablecw>
                        <doc.tablec>Property/Method=>Description</doc.tablec>
                        <doc.tabler>lastUserDataUpdate=>The date on which the last update of user data occurred.</doc.tabler>
                        <doc.tabler>displayName=>The user's display name (or nickname).</doc.tabler>
                        <doc.tabler>title=>Contains the user's title.</doc.tabler>
                        <doc.tabler>playerId=>Returns this user's unique Google Play Games ID.</doc.tabler>
                        <doc.tabler>currentLevel=>Returns the current user level.</doc.tabler>
                        <doc.tabler>hasIconImage=>Informs if this user has a profile picture.</doc.tabler>
                        <doc.tabler>iconImagePathInAppFilesScope=>Informs the path to the user's profile image, within the <doc.detach>AppFiles</doc.detach> scope (if the user has a photo)</doc.tabler>
                        <doc.tabler>GetFriendIconImage()=>Returns an object of type <doc.detach>Texture2D</doc.detach> which is the user's profile picture (if he has one).</doc.tabler>
                    </doc.table>
                    <doc.info>
                        This method allows you to clear the cache before loading Friends List. Only do this if really necessary as this can consume your game processing quota on Google Cloud, if your code always clears the cache and many
                        players end up making calls to this API while playing.
                    </doc.info>

                    <doc.topicsubtitle>Opening the Profile Comparer</doc.topicsubtitle>
                    When calling this method you can open a window that compares the profile of the player currently logged in and a friend of his, or someone who has an account on Google Play Games, but you need to inform this method the
                    ID of the other player that will be compared, the name of that other player in your game (or just something like "Your Friend"), and the name of the currently logged in Play Games player in your game (or something like
                    "You"). To open the profile comparer, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //- OpenProfileComparation(theOtherPlayerId, theOtherPlayerInGameNickname, loggedPlayerInGameNickname);
    NAT.PlayGames.OpenProfileComparation("user_friend_player_id", "Your Friend", "You");
}
                    </code></doc.code>

                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>com.google.android.gms.games, com.google.android.gms.drive (and its dependencies)=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Play Games: Loading and Saving progress to Cloud -->
                <doc.topic topicid="224">
                    <doc.topictitle>Play Games: Loading and Saving progress to Cloud</doc.topictitle>

                    With NAT Play Games it is possible to save or load games to the Google Cloud. The cloud used is the logged in user Google Drive. Your application save file is placed in a location that is not accessible to the user,
                    inside his Google Drive storage, in a secure way.
                    <doc.warn>
                        Before you start using the NAT Play Games Cloud Save API, make sure your game has save games enabled in the Google Play Developer Console settings. For this, sign in to the Google Play Console and select your
                        application. Go in Growth &gt; Services Related to Google Play Games &gt; Configuration and Management &gt; Configuration &gt; Edit Properties &gt; Saved Games &gt; Enabled. Then click "Save Changes" and publish the
                        changes.
                    </doc.warn>

                    <doc.topicsubtitle>Opening the Cloud Save interface</doc.topicsubtitle>
                    Opening the Cloud Save Interface will allow the player to select a saved game to load, or the player to save their game. If you want the user to load or save a game, you must call the
                    <doc.detach>OpenCloudSaveUI()</doc.detach> method. This method will open a Google Play Games UI that will allow the user to create a Save Game or Load an existing one. Before calling this method, you
                    must register the <doc.detach>onPlayGamesCloudSaveUIResult</doc.detach> event, as it will return a callback to your game, saying what the user did, informing if the window was just closed, if the user clicked on "Create"
                    or if the user chose a Saved Game to be loaded. the event also contains a String that indicates the name of the file that the user wants to be saved or loaded, and then based on the information provided by this callback,
                    you use the NAT API to load or save a game on the Cloud. To open the interface, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //First, register the callbacks...

    //- onPlayGamesCloudSaveUIResult(cloudSaveResult, fileNameToBeCreatedOrLoaded)
    NATEvents.onPlayGamesCloudSaveUIResult += (NAT.PlayGames.CloudSaveUIResponse cloudSaveResult, string fileNameToBeCreatedOrLoaded) =>
    {
        if (cloudSaveResult == NAT.PlayGames.CloudSaveUIResponse.CreateNew)
        {
            Debug.Log("The user wants to save a new file in the cloud called " + fileNameToBeCreatedOrLoaded);

            //Use method "CreateFileOnCloudSave()" to save the new file to the cloud
        }

        if (cloudSaveResult == NAT.PlayGames.CloudSaveUIResponse.LoadSave)
        {
            Debug.Log("The user wants to load a existing file in the cloud called " + fileNameToBeCreatedOrLoaded);

            //Use method "ReadFileOfCloudSave()" to load the existing file of the cloud
        }

        if (cloudSaveResult == NAT.PlayGames.CloudSaveUIResponse.Canceled)
        {
            Debug.Log("The user closed the interface without having done anything.");
        }
    };

    //Second, call the code of the NAT C# API

    //- OpenCloudSaveUI(interfaceOrientation, interfaceTitle, allowUserSave, allowUserDelete);
    NAT.PlayGames.OpenCloudSaveUI(NAT.PlayGames.CloudSaveInterfaceMode.LandscapeFullscreen, "Native Android Toolkit App Cloud Saving", true, true);
}
                    </code></doc.code>
                    To save or load a save file from the Play Games cloud, you need to enter the name of the save file you want to load or save. When using this Cloud Save UI calling the <doc.detach>OpenCloudSaveUI()</doc.detach> method it
                    will always return in its <doc.detach>onPlayGamesCloudSaveUIResult</doc.detach> event the name of the file that the user wants to load or create. In case the user wants to create a file, you must receive the file name in
                    the callback and then call the <doc.detach>CreateFileOnCloudSave()</doc.detach> method informing the name you received from the <doc.detach>onPlayGamesCloudSaveUIResult</doc.detach> event. And to load a file from Cloud
                    Save, you need to call the <doc.detach>ReadFileOfCloudSave()</doc.detach> method, informing the file name you received in the <doc.detach>onPlayGamesCloudSaveUIResult</doc.detach> event.

                    <doc.topicsubtitle>Saving a file to the cloud</doc.topicsubtitle>
                    To save the game to the cloud, you should get the binary of your game save file and then use this method. Before calling this method, you can register the <doc.detach>onPlayGamesCloudSaveCreateFileResult</doc.detach>
                    event to receive a callback that informs you if the save was successful. Note that if a file with the name entered already exists, it will be overwritten in the cloud and if a file with the name entered here does not
                    exist, it will be created. Additionally, when creating a save file (or overwriting one) it is possible to inform things like the description, time played, progress and etc.
                    <br>
                    <br>
                    When entering the played time by the user, you need to use the NAT Calendar, and since Google uses a UNIX time, you need to enter the minimum date of 01/01/1970. For example, to report that the player has played for 5
                    minutes, use <doc.detach>new Calendar(1970, 1, 1, 0, 5, 0)</doc.detach>.
                    <br>
                    <br>
                    To save the game to the cloud, use the code below.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

public byte[] saveGameBytes;

void Example()
{
    //First, register the callbacks...

    //- onPlayGamesCloudSaveCreateFileResult(isSaveSuccessfully)
    NATEvents.onPlayGamesCloudSaveCreateFileResult += (bool isSuccessfully) =>
    {
        if (isSuccessfully == true)
            Debug.Log("The game has been successfully saved to the cloud!");

        if (isSuccessfully == false)
            Debug.Log("There was a problem saving the game to the cloud.");
    };

    //Second, call the code of the NAT C# API

    //- CreateFileOnCloudSave(fileNameToBeSavedOnCloud, saveDescription, gameProgressValue, playedTime, bytesOfTheSaveGameFile, saveImageCover);
    NAT.PlayGames.CreateFileOnCloudSave("file_name_to_save_to_cloud", "This is the description!", 25.3f, new NAT.DateTime.Calendar(1970, 1, 1, 0, 5, 0), saveGameBytes, ScreenCapture.CaptureScreenshotAsTexture());
}
                    </code></doc.code>
                    <doc.info>
                        If event <doc.detach>onPlayGamesCloudSaveCreateFileResult</doc.detach> informs that the save operation in the cloud was successful, but the user has the device disconnected from the internet, Google Play Games
                        Services will keep the save file stored locally and as soon as the device connects to the internet, the file will be automatically uploaded to the cloud.
                    </doc.info>

                    <doc.topicsubtitle>Loading a file from the cloud</doc.topicsubtitle>
                    With this method you are able to load a save file from the Google Play Games cloud. Before calling this method, you must register the <doc.detach>onPlayGamesCloudSaveReadFileResult</doc.detach> event, as it is through
                    this event that this method will inform whether the loading was successful and will return the bytes of the loaded save file.
                    <br>
                    <br>
                    <b>IMPORTANT:</b> When the file you want to load has already been overwritten several times (because of previous saves), a conflict between versions of this save file can happen, and Google Play Games Services will
                    always try to resolve this conflict, so when calling this method you must inform the conflict resolution policy that should be used, that is, the criteria that will be used to define which is the correct file to be
                    loaded, in case of conflict.
                    <br>
                    <br>
                    Use the code below to load a save file from the cloud.
                    <doc.code language="csharp"><code>
using MTAssets.NativeAndroidToolkit;

void Example()
{
    //First, register the callbacks...

    //- onPlayGamesCloudSaveReadFileResult(isLoadSuccessfully, saveGameBytesLoadedIfSuccess)
    NATEvents.onPlayGamesCloudSaveReadFileResult += (NAT.PlayGames.CloudSaveLoadStatus loadStatus, byte[] saveGameLoadedBytes) =>
    {
        if (loadStatus == NAT.PlayGames.CloudSaveLoadStatus.Success)
        {
            Debug.Log("File loaded successfully! The file has " + saveGameLoadedBytes.Length + " bytes!");
        }

        if (loadStatus == NAT.PlayGames.CloudSaveLoadStatus.ErrorOnFind)
            Debug.LogError("Could not find the file in the cloud.");
        if (loadStatus == NAT.PlayGames.CloudSaveLoadStatus.ErrorOnRead)
            Debug.LogError("Unable to read the cloud file.");
    };

    //Second, call the code of the NAT C# API

    //- ReadFileOfCloudSave(fileNameToBeLoadedOfCloud);
    NAT.PlayGames.ReadFileOfCloudSave("file_name_to_load_from_cloud", NAT.PlayGames.CloudSaveConflictResolution.ResolveByHighestProgressValue);
}
                    </code></doc.code>
                    <br>
                    <b>Tip for resolving conflicts with files loaded from the Cloud!</b>
                    <br>
                    <br>
                    When a player plays your game from multiple devices, and load or saves his saves to the cloud from multiple devices, there may happen to be a conflict at some point. Because of this, good practice is to start a timer
                    as soon as a player starts playing your game for the first time. This time counter must measure the player game time and must be saved inside the player save game. Then, when calling the
                    <doc.detach>CreateFileOnCloudSave()</doc.detach> method, inform the current, true, game time of the player. This will give you more control and more confidence when loading and saving files to the cloud because when you
                    call the <doc.detach>ReadFileOfCloudSave()</doc.detach> method and get the save file, you can readily compare the playing time of the cloud save file, with the game time of the user device, and in case the game time of
                    the file obtained from the cloud is less than the game time of the user mobile phone, then it means the cloud file is old and cannot overwrite the game file which is currently on the player phone. So, you can tell the
                    player that the save file from the cloud is older (or less played) than the save file that is currently on his cell phone and therefore it is not advisable to continue with the load.
                    <doc.table>
                        <doc.tablecw>25%=>25%=>25%=>25%</doc.tablecw>
                        <doc.tablec>Required Permissions=>Required Dependencies=>Works In Editor=>Works In Android</doc.tablec>
                        <doc.tabler>None=>com.google.android.gms.games, com.google.android.gms.drive (and its dependencies)=>Yes, Not Emulated=>Yes</doc.tabler>
                    </doc.table>

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Optimization Tips For Using Native Android Toolkit -->
                <doc.topic topicid="226">
                    <doc.topictitle>Optimization Tips For Using Native Android Toolkit</doc.topictitle>

                    <b>Avoid calling functions often in a short time interval (as in Update for example): </b> Each time you call a NAT function, Unity has to communicate with native Android. If the functions are called excessively, this
                    can cause performance problems, so avoid calling functions in methods such as Update.
                    <br>
                    <br>
                    <b>Avoid working with giant files: </b> Working with very large files, may cause memory loss on some devices, be careful!

                </doc.topic>
                <!-- #endregion -->

                <!-- #region Demo Scene -->
                <doc.topic topicid="227">
                    <doc.topictitle>Demo Scene</doc.topictitle>

                    The Native Android Toolkit has some demonstration scenes. The demo scenes start with the prefix "DemoScene".
                </doc.topic>
                <!-- #endregion -->

                <!-- #region Contact and Support -->
                <doc.topic topicid="228">
                    <doc.topictitle>Contact and Support</doc.topictitle>

                    <center>
                        <font style="font-size: 18px; color: #00771d;">mtassets@windsoft.xyz</font>
                    </center>
                    <br>
                    <doc.achiev>
                        Congratulations, you have reached the end of the documentation! Thanks for reading!
                        <br>
                        <br>
                        If you need to contact me for any difficulty, feature suggestion, bug fix, question or support, just contact me through my email above!
                    </doc.achiev>
                </doc.topic>
                <!-- #endregion -->



                <!-- --------------------------------------------------------------------------- END OF DOCUMENTATION CONTENT --------------------------------------------------------------------------- -->
            </div>
        </div>

        <div class="endOfBodyContentPoint" id="contentEndPoint"></div>
        <!-- #region FOOTER -->
        <div class="footer">
            <center>
                <small>
                    <b>Developed with â¤ by Marcos Tomaz (MT Assets)</b>
                    <br>
                    <div class="processingTimeResult">
                        Page processed in <div id="processingTime">0</div> ms
                    </div>
                    <br>
                    <a href="https://assetstore.unity.com/publishers/40306" target="_blank">See More Assets From MT Assets</a>
                    â€¢
                    <a href="https://windsoft.xyz/mtassets" target="_blank">MT Assets Website</a>
                    â€¢
                    <a href="https://www.youtube.com/channel/UCqAgiYBwAWajjFUqyJ6_xyw" target="_blank">MT Assets On YouTube</a>


                    <div style="display: inline; margin-left: 8px; margin-right: 8px;">|</div>
                    <a href="https://github.com/marcos4503/documentation-template" target="_blank">
                        <div style="display: inline;"><img src="DocumentationFiles/footer/github" style="width: 14px; height: 14px; border-radius: 14px; transform: translateY(2px);"></div> See This Documentation Template On GitHub!
                    </a>
                </small>
            </center>
        </div>
        <div class="footerSpacement"></div>
        <div class="gotoTopButton" id="gotoTopButtonItem" onclick="GoToToButton();"><img src="DocumentationFiles/tools/up.webp" title="Click here to go to top of page." /></div>
        <!-- #endregion -->
    </body>

</html>